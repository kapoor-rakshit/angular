
MEAN stack
MongoDB , Express , Angular , Node

MERN stack
MongoDB , Express , React , Node



FRONTEND CLIENT side FRAMEWORK(s) which use HTML, JS, TS, Dart for building application(s)
Angular , React
Angular works on REAL DOM.
React works on VIRTUAL DOM , better performance as compared to Angular.

BACKEND SERVER(s)
NodeJs , ExpressJs , ASP.NET , J2EE



Traditional Web Application  |  Single Page Application
                             -  Initial load (JS, CSS, HTML) on index.html (Single Page)
                             -  Initally slow on index.html but subsequent requests are faster
                             -  Client - Browser loads/remove/modify DOM coz they have ANGULAR/REACT libs
Check reference screenshots too.



Angular Versioning
================================
AngularJs   --->   Angular 1.x
Angular     --->   Angular 2 onwards
Angular uses SEMVER (SEMANTIC VERSIONING) ie adding meaning to VERSION.
eg: 2.5.8
    2 --> Major Version   (Breaking Change , ie there is need to modify existing code , eg: AngularJS to Angular)
    5 --> New Feature     (not breaking)
    8 --> Patch, bugfixes (not breaking)

Angular 3 does not exist
Reason : angular/router module in core library of Angular was at v3.x.x plus ahead of v2.x.x for other modules.
         Now if Angular v3 is released , angular/router module will be at v4.x.x while others will be at v3.x.x
         So to avoid cofusion it was dropped and moved to v4 directly.

Every six months , one major release is made to Angular Version.



METADATA
===============
Tells angular how to process a class ie qualifying a class with the attributes which angular framework can understand.
Consists of decorators. Eg: @Component, @Injectable, @NgModule, @Pipe.
NOTE : a class immediately succeeded by METADATA decorator will only act as ANGULAR specific.

Transpiler is used to convert TS to JS.
This is done either by browser or before providng production build to browser for faster response.



NPM
================
NPM is a NODE PACKAGE MANAGER which gets installed with nodeJS   just  as  MAVEN, ANT, GRADLE  etc...
NPM is used to install a package, and any packages that it depends on.
> npm install
If the package has a 'package-lock' or 'shrinkwrap file', installation of dependencies will be driven by that else from 'package.json'

> npm install --save <PACKAGE_NAME>
Install the dependencies in the local node_modules folder.

> npm install -g --save <PACKAGE_NAME>
(--global), installs the current package context (ie, the current working directory) as a global package in NodeJS's 'node_modules' dir

> npm update --save
npm checks if there exist newer versions in repository that satisfy specified semantic versioning ranges as in package.json and installs them.
but leaves package.json untouched (you can change this by passing --save option).

> npm outdated
> npm install <PACKAGE_NAME>@latest --save
Updating a version that is beyond semantic versioning range requires two parts. 
First, you ask npm to list which packages have newer versions available using `npm outdated`.
Then you ask npm to install the latest (@latest) version or specific version (@4.1.6) of a package.

> npm config set registry <NPM_REPO_URL>
Set base url for npm package registry i.e. repo to download packages , Default is https://registry.npmjs.org/

> npm config set proxy <PROXY_URL>
> npm config set https-proxy <PROXY_URL>
Set proxy for a network to allow download of packages

> npm config delete <KEY>
Delete a config setting <KEY> , it can be `proxy`, `https-proxy`    etc...



SETUP
================
Refer  SetupInstructions.docx  document


node.js terminal is a CMD terminal with NODEJs and NPM path variables set for user automatically.


(MULTI-REPO)  :  every new angular project created will have its own node_modules, files (angular.json, package.json), folders.
> ng new <APP_NAME> 
> ng serve
> ng build --prod
  ng build --prod --output-hashing=none           // prevents hash-number to be attached to build artifacts

(MONO-REPO)   :  only one node_modules and common files which can be shared by all angular applications inside working directory <my-workspace>
> ng new <my-workspace> --create-application=false --defaults
> ng generate application <my-app>
> ng serve <my-app>
> ng build <my-app> --prod  
--create-application : tells the Angular CLI not to generate an initial application.
--defaults           : tells the Angular CLI not to prompt you about routing and CSS preprocessor.
NOTE : application <my-app> and its corresponding <my-app>-e2e application are in the 'projects' folder.
     : ng s <my-app> [options]    or    ng serve <my-app> [options]           will start the application

> ng update
Perform a basic update to the current stable release of the core framework and CLI.
--all=true | flase   ,  Whether to update all packages in package.json. (default=false)

> ng serve [options]
Reference : https://github.com/angular/angular-cli/wiki/serve
--port portval     :  Port to listen on
--host hostval     :  Host to listen on
--open (alias: -o) : Opens the url in default browser
--progress         : Log progress to the console while building.
--optimization     : Enables optimization of the build output.   ..... etc.. more on above link

> ng add <package>                                (MULTI-REPO)
> ng add <package> --project <my-app>             (MONO-REPO)
ng add makes adding new capabilities to your project easy. ng add will use your package manager to download new dependencies and 
invoke an installation script (implemented as a schematic) which can update your project with configuration changes, 
add additional dependencies (e.g. polyfills), or scaffold package-specific initialization code

"npm start"   command will work same as   "ng serve"    command.
because the "start" key of package.json is having value "ng serve -o".



PWA experience to Angular
===============================
Following package will add all necessary code for making an app a PWA, which otherwise had to be done manually.
It will update angular.json, package.json, app.module.ts, index.html plus create assets/ dir for relevant icons.
> ng add @angular/pwa                             (MULTI-REPO)
> ng add @angular/pwa --project <my-app>          (MONO-REPO)



Angular Material
================================
REFER : https://material.angular.io/components/categories
UI can be improved by using either Bootstrap or Angular Material.
Angular material provides functionality for PAGINATION OF TABLES, SORTING OF TABLES via column clicks ... and much more.
NOTE : @angular/material package has to be added, which will update angular.json, package.json, app.module.ts  .... etc.
> ng add @angular/material                        (MULTI-REPO)
> ng add @angular/material --project <my-app>     (MONO-REPO)

NOTE : material to be used must be imported in imports [] of '.module.ts'



Angular SSR (Server Side Rendering) and Pre-rendering with Angular Universal
===============================================================================
Angular applications are single-paged apps (SPAs) - this means a single HTML document is served to the client, 
which can then be dynamically rewritten on the client browser-based on data received from the server, instead of serving a static page when routing. 

Angular Universal allows the app to be executed on the server, which lets us generate and serve static HTML to the client in response to navigation. 
This means that when user opens Angular app, server will show user a pre-rendered version of app which they can browse while client-side application loads behind-the-scenes. 
When the client-side application has finished loading, the application switches from pre-rendered app to the fully interactive client-side app, without the user even noticing.

SSR vs Pre-rendering
- Dynamic SSR or SSR is when there will be live Node server spun up such that whenever Route is hit, it will dynamically generate and serialize application — returning that String to browser.
  Static Pre-rendering or pre-rendering is when we want to pre-render a list of routes and create static files, (ie: index.html, about-us.html, etc) and then use server of our choice to serve up those files later on.
- SSR is used when application (and the routes you need to SSR) are dynamic i.e. application structure is rendered based on JSON files where anything could change at any given moment.
  Pre-rendering is used when application (or at least the Routes you’re trying to pre-render) are a static content eg: about us, contact us. 
  dynamic content routes can be pointed to normal CSR version of your application.
- SSR is rendering client-side app to HTML on the server i.e. server compiles application(render on a server) and sends generated HTML page back to client.
  Prerendering is running client-side app at build time to capture its initial state as static HTML and saved as static HTML pages on file-system and sends same when requested.
  In both rendering technique, we generate static HTML pages. Just the major difference is the location where HTML pages are generated.
- CHECK SCREENSHOTS TOO.

The Angular CLI compiles and bundles the Universal version of the app with the Ahead-of-Time (AOT) compiler. 
Install the Angular Universal schematic to set our app up for server-side rendering and pre-rendering.
> ng add @nguniversal/express-engine
OR update
> ng update @nguniversal/express-engine

This will create following new files:
- main.server.ts             * bootstrapper for server app
- server.ts                  * express web server
- app/app.server.module.ts   * server-side application module

A sample code for estimating FCP time, write in index.html of your app
<script>
    const po = new PerformanceObserver((list) => {
      for (const entry of list.getEntriesByName('first-contentful-paint')) {
        console.log('FCP: ', entry.startTime);
        po.disconnect();
      }
    });
    po.observe({type: 'paint', buffered: true});
</script>

- client-side rendered (CSR) version of our app is served using
  > npm run start         OR       > ng serve
  The CSR app is available on port 4200 (default), which can be changed in `package.json` file.

- server-side rendered (SSR) version of our app is served using
  > npm run build:ssr && npm run serve:ssr
  These run script configuartions are available in package.json
  The SSR app is available on port 4000 (default), which can be changed in the generated `server.ts` file.

  To run SSR app in development mode, that will automatically recompile the client and server bundles and live-reload the browser.
  > npm run dev:ssr
  
- pre-rendered version of our app
  Pages that don’t need to be rendered server-side or rendered on the client every time a user makes a request. 
  Angular Universal 9 now allows you to cache these pages as static files, which can then be served to the client via your CDN or a simple server.
  Set up
  1- pre-rendered files are found at `dist/<project-name>/browser` after running following command
     > npm run prerender
     This will look for all static routes using guess-parser and prerender it. Prerendering also renders the data received from API response.
     Guess-parser is able to detect static routes, but it is unable to detect parameterized routes, so use following step.
  2- In `angular.json` file and look for the "prerender" builder (at the very end of the default angular.json). 
     The builder comes with a "routes": [], which allows to specify the routes of the app pages we wish to pre-render.
     OR specify a .txt file with each route on new line and replace "routes" key with "routesFile": "./pre-render-routes-file.txt"
  3- Deploy files in `dist/<project-name>/browser` to a server to serve pre-rendered version of app.

There are three main reasons to create a Universal version of your app:
- Facilitate web crawlers through search engine optimization (SEO)
  Angular Universal can generate a static version of your app that is easily searchable, linkable, shareable and navigable without JavaScript. 
  Universal also makes a site preview available since each URL returns a fully rendered page.
  This is evident as client-side application shows <app-root></app-root> with nothing else inside it, 
  whereas server-side app displays page CSS and all app content coming from <app-root></app-root>. This makes it much easier for a web-crawler to scrape app’s content.
- Improve performance on mobile and low-powered devices
  Some devices don't support JavaScript or execute JavaScript so poorly that the user experience is unacceptable. 
  For these cases, you may require a server-rendered, no-JavaScript version of the app. 
- Show the first page quickly with a first-contentful paint (FCP)
  With Angular Universal, you can generate landing pages for the app that look like the complete app. 
  The pages are pure HTML, and can display even if JavaScript is disabled. It will serve a static version of the landing page to hold the user's attention. 
  At same time, you'll load full Angular app behind it. User perceives near-instant performance from landing page and gets full interactive experience after full app loads. 



Session Timeout (i.e. track user inactivity)
==============================================
- npm install angular-user-idle

- app.module.ts
----------------------
import { AppComponent, UserIdleDialog } from './app.component';
import { UserIdleModule } from 'angular-user-idle';
import { MatDialogModule } from '@angular/material/dialog';
import { MatButtonModule } from '@angular/material/button';
@NgModule({
  declarations: [AppComponent, UserIdleDialog],
  entryComponents: [UserIdleDialog],
  imports: [UserIdleModule.forRoot({}), MatDialogModule, MatButtonModule],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

- app.component.ts
------------------------
import { Component, OnInit, Inject } from '@angular/core';
import { UserIdleService } from 'angular-user-idle';
import {MatDialog, MatDialogRef, MAT_DIALOG_DATA} from '@angular/material/dialog';
import { Router, NavigationStart, NavigationEnd, NavigationError, NavigationCancel, Event } from '@angular/router';
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit{
  isDialogOpen: boolean = false;

  // all times are in seconds
  userIdleTime: number = 30;
  dialogIdleTime: number = 10;

  constructor(private userIdle: UserIdleService, public dialog: MatDialog, private _router: Router) {}
  
  ngOnInit() {
  
    this._router.events.subscribe((event: Event) => {
      if (event instanceof NavigationStart) {
        let currentURL = this._router.routerState.snapshot.url;
        console.log(`START ==> ${currentURL}`);
        if(currentURL == "/") {
          // set config values
          this.userIdle.setConfigValues({idle: this.userIdleTime, timeout: 5, ping: 120});

          // Start watching for user inactivity, 
          // and start timeout seconds timer after user is IDLE for idle seconds
          this.userIdle.startWatching();
        }
      }
      else if (event instanceof NavigationEnd) {
        let currentURL = this._router.routerState.snapshot.url;
        console.log(`END ==> ${currentURL}`);
        if(currentURL == "/") {
          this.userIdle.resetTimer();
          this.userIdle.stopWatching();
        }
      }
      else if(event instanceof NavigationError || event instanceof NavigationCancel) {
        this.userIdle.resetTimer();
        this.userIdle.stopWatching();
      }
    }); 
    
    // Start watching when timeout seconds timer is starting.
    // called every second
    this.userIdle.onTimerStart().subscribe(
      (count) => {
        if(!this.isDialogOpen){
          //console.log(`Timer value USER IDLE ==> ${count}`);
        }
        else {
          //console.log(`Timer value DIALOG IDLE ==> ${count}`);
        }
      },
      (err: Error) => {
        console.error(`TIMER START ERROR ==> ${err.message}`);
      }
    );
    
    // when timeout seconds timer is up.
    // called after timer ends and internally calls stopWatching() on userIdleService
    // i.e. userIdleService will not track user inactivity anymore now.
    this.userIdle.onTimeout().subscribe(
      (data) => {
        if(!this.isDialogOpen) {
          console.log(`Time is up USER IDLE ==> ${data}`);
          this.openDialog();
        }
        else {
          this.dialog.closeAll();
          this.isDialogOpen = false;
          this.userIdle.resetTimer();
          this.userIdle.stopWatching();
          console.log(`Time is up DIALOG IDLE ==> ${data}`);

          // functionality as of logout button
          console.log(`logging out...`);
        }
      },
      (err: Error) => {
        console.error(`TIMER END ERROR ==> ${err.message}`);
      }
    );
  }
  
  openDialog(): void {
    this.isDialogOpen = true;
    this.userIdle.resetTimer();
    this.userIdle.stopWatching();

    this.userIdle.setConfigValues({idle: 1, timeout: this.dialogIdleTime, ping: 120});
    this.userIdle.startWatching();

    const dialogRef = this.dialog.open(UserIdleDialog, {
      width: '50vw',
      disableClose: true,
      data: {}
    });

    dialogRef.afterClosed().subscribe(
      (result) => {
        if(result == "stayOnPage") {
          this.isDialogOpen = false;
          this.userIdle.resetTimer();
          this.userIdle.stopWatching();

          this.userIdle.setConfigValues({idle: this.userIdleTime, timeout: 5, ping: 120});
          this.userIdle.startWatching();
          console.log(`started watching USER IDLE again...`);
        }
        else if(result == "logout") {
          this.dialog.closeAll();
          this.isDialogOpen = false;
          this.userIdle.resetTimer();
          this.userIdle.stopWatching();

          // functionality as of logout button
          console.log(`logging out...`);
        }
        console.log('The dialog was closed');
      },
      (err: Error) => {
        console.error(`DIALOG CLOSURE ERROR ==> ${err.message}`);
      }
    );
  }
}
@Component({
  selector: 'user-idle-dialog',
  templateUrl: './userIdleDialog.html',
  styleUrls: ['./app.component.css']
})
export class UserIdleDialog implements OnInit {

  timeUntilLogout: number;
  constructor(public dialogRef: MatDialogRef<UserIdleDialog>, @Inject(MAT_DIALOG_DATA) public data: any) {}

  ngOnInit() {

  }

  stayOnPageFn() {
    this.dialogRef.close("stayOnPage");
  }

  logoutFn() {
    this.dialogRef.close("logout");
  }
}

- Material Dialog HTML (userIdleDialog.html)
------------------------------------------------
<h1 mat-dialog-title>Session Timeout</h1>
<mat-dialog-content>
     You have been inactive and will be logged out. <b>Do you wish to stay on page ?</b>
</mat-dialog-content>
<mat-dialog-actions>
    <button mat-raised-button color="primary" (click)="stayOnPageFn()">Yes</button>
    <button mat-raised-button color="warn" (click)="logoutFn()">No</button>
</mat-dialog-actions>



Read (Uploaded) / Write (Download) EXCEL files
=================================================
Reference : https://javascript.info/file
            https://www.npmjs.com/package/xlsx
            https://github.com/SheetJS/sheetjs/tree/baea1798cf825a2cc8b1365cb7818605a8d4f464/demos/angular2
            
1. Install package 'XLSX'
-----------------------------
> npm install xlsx

2. READ
-------------
HTML
    <input type="file" (change)="fileChangeFn($event)" [(ngModel)]="filePath">
TS
    import * as XLSX from 'xlsx';
   /**
   * @param ev 
   */
  fileChangeFn(ev) {
    console.log(`FILE NAME/PATH ==> ${this.filePath}`);

    // create fileReader object
    const reader = new FileReader();

    //For Browsers other than IE.
    if (reader.readAsBinaryString) {

      // wire up file target
      let target: DataTransfer = <DataTransfer>(ev.target);
      if (target.files.length !== 1) throw new Error('Cannot use multiple files');

      // call READ method of FileReader()
      reader.readAsBinaryString(target.files[0]);

      // cancel the operation
      // reader.abort();

      // loading started
      reader.onloadstart = function() {
        console.log(`READER LOADING STARTED`);
      };

      // occurs during reading
      reader.onprogress = function() {
        console.log(`READING ...`);
      };

      // no errors, reading complete
      reader.onload = function() {
          let data = reader.result;

          //Read the Excel File data.
            // XLSX Options
            // type : Input data encoding
            // password : If file is encrypted
            // sheets : only parse specified sheets | default is parsing all Sheets in workbook
          let workbook = XLSX.read(data, {type: 'binary', password: "", sheets: [0,1]});

          //Fetch name of Sheet number as of actual physical workbook on disk, NOT as parsed
          let firstSheet = workbook.SheetNames[0];
          let worksheet = workbook.Sheets[firstSheet];

          //Read all rows from First Sheet into an JSON array.
          let excelRows = XLSX.utils.sheet_to_json(worksheet);

          console.log(`${JSON.stringify(excelRows)}`);
          console.log(`${JSON.stringify(excelRows.length)}`);
      };

      // abort() called
      reader.onabort = function() {
        console.log(`READER ABORTED`);
      }

      // error has occurred
      reader.onerror = function() {
        console.error(`READER ERROR ==> ${reader.error.message}`);
      };

      // reading finished with either success or failure
      reader.onloadend = function() {
        console.log(`READER LOADING ENDED`);
      }

    } else {
      alert(`Your browser does not support this feature.`);
    }
  }
  
3. WRITE
------------------
HTML
   <button mat-raised-button (click)="writeFileFn()">Download</button>
TS
   writeFileFn() {
    let dataArr = [
      {username: "kapoor", pass: "rakshit", date: "12-09-5678"},
      {username: "adhish", pass: "kapoor", date: "10-02-9812"},
      {username: "kapoor", pass: "palak", date: "02-09-1584"},
      {username: "kaveri", pass: "kapoor", date: "11-01-8341"},
      {username: "kapoor", pass: "Saab", date: "29-01-8341"}
    ];

    /* generate worksheet */
      // Options
      // header : Use specified column order
      // skipHeader : If true, do not include header (keys of JSON Object) row in output
    let worksheet = XLSX.utils.json_to_sheet(dataArr, {header: ["username", "date", "pass"], skipHeader: false});

    /* add another json to sheet */
      // Options
      // origin	: Use specified cell as starting point
          // NOTE : If not specified (default), it will overwrite starting from header (Row 0)
          // { r: 1, c: 4 }  :  Row 1, Column 4 (includes header considering it as Row 0)
          // -1	 : Append to bottom of worksheet starting on first column
      // header : Use same order as used when creating sheet
      // skipHeader : true (preferred) to prevent duplicacy of header (keys of JSON Object)
    let anotherDataArr = [
      {username: "kapoor", pass: "Palak Gupta", date: "17-09-5678"},
      {username: "kapoor", pass: "Kaveri Khanna", date: "19-09-5678"},
    ];
    XLSX.utils.sheet_add_json(worksheet, anotherDataArr, {origin: -1, header: ["username", "date", "pass"], skipHeader: true});

    /* generate workbook and add the worksheet */
    let workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "Data Sheet 1");

    /* save to file and download */
    XLSX.writeFile(workbook, 'DataSheetPrac.xlsx');
  }


Drag / Drop file
===================
1. Create a directive and provide it in declarations array of corresponding .module.TS
---------------------------------------------------------------------------------------
import { Directive, Output, Input, EventEmitter, HostBinding, HostListener } from '@angular/core';

@Directive({
  selector: '[appDragDrop]';
})
export class DragDropDirective {
	
  @Output() onFileDropped = new EventEmitter<any>();
	
  @HostBinding('style.background-color') private background = '#f5fcff'
  @HostBinding('style.opacity') private opacity = '1'
	
  //Dragover listener
  @HostListener('dragover', ['$event']) onDragOver(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    this.background = '#9ecbec';
    this.opacity = '0.8'
  }
	
  //Dragleave listener
  @HostListener('dragleave', ['$event']) public onDragLeave(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    this.background = '#f5fcff'
    this.opacity = '1'
  }
	
  //Drop listener
  @HostListener('drop', ['$event']) public ondrop(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    this.background = '#f5fcff'
    this.opacity = '1'
    let files = evt.dataTransfer.files;
    if (files.length > 0) {
      this.onFileDropped.emit(files)
    }
  }
}

2. Attach this directive to HTML DOM
--------------------------------------
<div class="uploadfilecontainer" (click)="fileInput.click()" appDragDrop (onFileDropped)="uploadFile($event)">
  <input hidden type="file" #fileInput (change)="uploadFile($event.target.files)">
</div>

3. Define event handler in corresponding TS
---------------------------------------------
files: any = [];
uploadFile(event) {                       // drop event passes  '$event.target.files'  as arg to event handler
  let fileSize = event[0].size;
  console.log(`FILE SIZE ==> ${fileSize}`);
}

4. Add some CSS
--------------------
.uploadfilecontainer {
    background-image: url("/assets/cloud-2044823_960_720.png");
    background-repeat: no-repeat;
    background-size: 100px;
    background-position: center;
    height: 200px;
    width: 80%;
    margin: 20px auto;
    border: 2px dashed #1C8ADB;
    border-radius: 10px;
}



Make Angular application compatible with Internet Explorer (IE)
=================================================================
REFERENCE : https://indepth.dev/angular-internet-explorer/
FOR PRODUCTION BUILD   (ng build --prod)
------------------------------------------
1. Install a couple of npm packages
>  npm install --save classlist.js
>  npm install --save web-animations-js

2. Edit `polyfills.ts`
-  uncomment two commented out lines in   `APP_NAME\\src\\polyfills.ts`
   import 'classlist.js';
   import 'web-animations-js';
   
3. Edit `browserslist`
-  remove not from   not IE 9-11   line in   `APP_NAME\\browserslist`
   IE 9-11
   
FOR DEVELOPMENT   (ng serve)
------------------------------
1. Edit tsconfig.json
-  change "target": "es2015"  to  "target": "es5"  in  `APP_NAME\\tsconfig.json`
   "compilerOptions": {
   	"target": "es5"
   }



jQuery / Bootstrap in Angular
================================
> npm install jquery                                    // Install jQuery plugin
> npm install bootstrap                                 // Install Bootstrap plugin

NOTE : After installing jQuery or bootstrap we need to make it global. 
       In the module (inside node_modules), .min.js under ‘dist’ folder is not public.
       To make them global, add .min.js 
        - inside "angular-cli.json" or "angular.json"  add the path "node_modules/jquery/dist/jquery.min.js" in scripts: [] property
        - i.e.   "scripts" :[
                   "node_modules/jquery/dist/jquery.min.js",
                   "node_modules/bootstrap/dist/js/bootstrap.min.js"
                 ]
       Similarly we can add .min.css
        - inside "angular-cli.json" or "angular.json"  add the path "node_modules/jquery/dist/jquery.min.css" in styles: [] property
        - i.e.   "styles" :[
                   "node_modules/@angular/material/prebuilt-themes/indigo-pink.css",
                   "node_modules/bootstrap/dist/css/bootstrap.min.css",
                   "src/styles.css"
                 ]
        
To use jQuery inside a component
        - import * as $ from 'jquery'
        
Also now we can use Bootstrap as usual with class names in our CSS files.



INTERNATIONALIZATION (i18n) | LOCALIZATION (l10n)
=====================================================
REFER : https://angular.io/guide/i18n



JIT / AOT
===================
- In the beginning, a compiler was responsible for turning a high-level language into object code (machine instructions), 
  which would then be linked into an executable.
  
- just-in-time (JIT) compilation (also dynamic translation or run-time compilations) is a way of executing computer code 
  that involves  compilation during execution of a program — at run time — rather than prior to execution.
  Or stated more simply, it is that the code gets compiled when it is needed, not before runtime.
  
  A just-in-time (JIT) compiler is a feature of the run-time interpreter, that instead of interpreting bytecode every time a method is invoked, 
  will compile the bytecode into the machine code instructions of the running machine, and then invoke this object code instead.
  
  In JIT, not all the code is converted into machine code initially. Only code that is necessary (used immediately) will be converted into machine code. 
  Then if a method or functionality called and is not in machine code, then that will also be turned into machine code. 
  This reduces the burden on the CPU and makes the app render faster because it only uses what is needed.
  
- ahead-of-time compilation (AOT compilation) is the act of compiling a higher-level programming language such as C or C++, or an 
  intermediate representation such as Java bytecode or .NET Framework Common Intermediate Language (CIL) code, 
  into a native (system-dependent) machine code so that the resulting binary file can execute natively.
  
  An ahead-of-time (AOT) compiler converts your code during the build time before the browser downloads and runs that code. 
  Compiling your application during the build process provides a faster rendering in the browser.
  
  Benefits
  Faster rendering, Fewer asynchronous requests, Smaller Angular framework download size, Detect template errors earlier, Better security
  
- JIT compilation is the default when you run the `ng build` or `ng serve` CLI commands. This is for development.
  For AOT compilation, include the `--prod` or `--aot` option with the `ng build` or `ng serve` command, 
  NOTE : this parameter is configured in 'angular.json' with `AOT`.



Structure of Angular Application
==========================================
e2e               : end to end tests
node_modules      : contains node nodules used by angular application (MULTI-REPO) or provides packages to your workspace (MONO-REPO).
src/app           : contains components (.html, .ts, .css, -spec.ts)
src/polyfills     : compatibility for different browsers.
src/styles.css    : define styling classes which can be used by all components in app, like defining global styles.
src/index.html    : the starting point, the page which browser reads and loads when running angular app. (contains <selector></selector> for bootstrap component)
src/main.ts       :	the entry point from a code perpective for your angular app. (contains  platformBrowserDynamic().bootstrapModule(AppModule))
angular.json      : CLI configuration defaults
tsconfig.json     : typescript configuration
package.json      : configures the npm package dependencies ie which libraries will be installed into node_modules plus script rules.
                    ~version : “Approximately equivalent to version”
                    ^version : “Compatible with version”
package-lock.json : a derivative of package.json which has exact library version(s) you are using for this app.
                    `npm install` uses 'package-lock.json' (if available) else 'package.json' to install required dependencies.
                    


commands will look for  "package.json"  file  which contain dependencies  and then load   "index.html"   file
index.html     loads   main.ts   loads   app.module.ts   .... so on as below

index.html                --   defines the tag to be filled by BOOTSTRAPED ANGULAR component as defined in main.ts
                               eg:- <app-root> DEFAULT text to be diplayed if ANGULAR component not found </app-root>

main.ts                   --   defines AppModule (app.module file) in the bootstrapModule() 

app.module.ts             --   defines @NgModule
                               --   defines AppComponent (app.component file) ie register all components/modules here
                               --   new components are declared in "declarations" and "imported" , 
                                    provided they are EXPORTED in their respective ".component.ts" file
NOTE : For a NEW COMPONENT
mkdir component_dir under app dir (default) component  OR  give path to COMPONENT_NAME
      mk    comp.component.ts     file
      mk    comp.component.html   file
      manually declare new component in app.module.ts "declarations"
      ------OR------
      > ng generate component DIR/COMPONENT_NAME/            // this will create a COMPONENT_NAME dir under DIR dir with required files .html, .ts, .css
      > ng g c DIR/COMPONENT_NAME/
      automatically updates app.module.ts declare new component in "declarations"

app.component.ts          --   defines @Component
                               --   defines the name of selector tag to insert ANGULAR component in any .html
                                    NOTE : This <selector_name></> tag must be written in .html file of that COMPONENT in whose MODULE.ts it is REGISTERED
                               --   defines TEMPLATE file to be displayed to BROWSER
                               --   defines css file
                          --   This class must be EXPORTED for ".module.ts" file to be able to IMPORT and REGISTER it
                          --   defines variables of class AppComponent to be supplied to its respective TEMPLATE file (.html)

                                -- Done using INTERPOLATION ie using  {{ var }} in .HTML values are supplied dynamically
                                                                      {{'Title : '  + var}}          // hardcoded_str + var
                                                                      {{'Title : '  + funccall()}}   //               + function_call()
                                                                      {{mathematical_expressions}}   // eg:- 2*5+6
                                                                      src={{ var }}                  // attribute values

                                --   NOTE : INTERPOLATION is only for STRINGs , for integer , boolean..use 
                                     PROPERTY BINDING                 [disabled] = 'var'                       // NOTE : use of [] for attrib and ' ' for vals
                                     CSS_CLASS BINDING                [class.CLASS_NAME_CSS] = "BooleanVAR_EXPRESSION"
                                                                      [ngClass] = "'firstCSSClass secondCSSClass'"                 // NOTE : use of '' over class names
                                                                      [ngClass] = "['firstCSSClass' , 'secondCSSClass']"
                                                                      [ngClass] = "{'firstCSSClass' : i%2==0 , 'secondCSSClass' : i%2==1}"

                                --   EVENT BINDING                    (click)    = 'funccall()'                // NOTE : use of () for event  and ' ' for func
                                                                      (input)    = 'func($event.target.value)' //        send data from DOM to component
                                --   TWO-WAY DATA BINDING
                                     NOTE : Import { FormsModule } in "app.module.ts"    and   include  in  "imports" for two-way
                                     -- No processing..               [(ngModel)]     = "var"                 // set value attribute's val of tag as var from DOM to COMPONENT and vice versa
                                     -- Processing..                  (ngModelChange) = "func($event)"        // pass value to component , later used by [ngModel]
                                                                      [ngModel]       = "var"                 // pass to DOM after processing

app.component.html        --   displayed to BROWSER



Misc. Event binding example (similar to `this` in JS)
=============================
In '.comp.html'
- <input matInput type="text" (keyup)="applyFilter($event)" placeholder="search">

In '.comp.ts'
-  applyFilter(event: Event) {
    const filterValue = (event.target as HTMLInputElement).value;
    this.products.filter = filterValue.trim().toLowerCase();
   }

     
     
PIPES
==================
                          --   BUILTIN PIPES    
                              ----------------  eg:- {{ var | uppercase }}
                                                     {{ var | lowercase }}
                                                     {{ var | titlecase }}
                                                     {{ var | date : "dd/mm/yyyy" }}               // var = new Date();
                                                     {{ var | date : "shortTime" }}
                                                     {{ var | currency : 'EUR' : true }}           // show euro symbol
                                                     {{ var | currency : 'EUR' : false }}          // donot show euro symbol , shows EUR
                                                     {{ var | json }}                              // converts JS object to JSON {"" : ""}
                                                     {{ var | percent }}                           // var = 00.54534 , output = 55%
                                                     {{ var | slice : <start> : <end> }}           // var = ARRAY , [start_index,end_index)
                                                     {{ var | number : '<minDigitsBeforeDecimal>.<minDigitsAfterDecimal>-<maxDigitsAfterDecimal>' }}
                                                     
                          --   CUSTOM PIPES
                              ----------------
NOTE : For creating NEW PIPE
      manually
      ----- OR -----
    > ng generate pipe PIPENAME
                               -- CREATE a "PIPENAME.pipe.ts" under it's component dir , use @Pipe and implement PipeTransform with pipeClass , export this class
                               -- pipeClass implements PipeTransform interface's transform method that accepts input value followed by parameters and returns transformed value.
                               -- multiple args can be passed to transform function using (colon) '' : '' : ''
                               -- Import and include it in  "declarations"  of  "app.module.ts"
                               -- Use    [(ngModel)] = "filtervar"    in   <input>  tag.
                               -- Use in TEMPLATE .html with directives using pipe_symbol (|) PIPENAME : filtervar
                               -- Example : {{ var | CUSTOM_PIPE : <arg1> : <arg2> | uppercase }}
                               
                           --  PURE / IMPURE PIPES
                              -----------------------
                               -- Pure
                                  - This is DEFAULT pipe , if 'pure' metadata is not specified in @Pipe decorator({})
                                  - BUILTIN pipes are PURE.
                                  - input parameters value determine the output , if input parameters don’t change , output doesn’t change
                                  - can be shared across many usages without affecting the output result
                                  - there’s no internal state , Even though there are two usages in the example template , 
                                    Angular can create only one pipe instance which can be shared between the usages.
                                    
                               -- Impure
                                  - cannot use the input value to determine if the output will change
                                  - cannot be shared because the internal state can be affected from outside
                                  - the same parameters do not guarantee that same output , 
                                    It means that Angular is forced to trigger transform function on a pipe instance on every digest (change detection cycle)
                                    <span>{{v1 | customPipe}}</span>
                                    <span>{{v2 | customPipe}}</span>
                                  - example
                                    @Pipe({
                                      name: 'customPipe', 
                                      pure: true
                                    })
                                    
                                  - example
                                    @Pipe({
                                      name: 'customPipe',
                                      pure: false
                                    })
                                    
                                  -- Async pipe
                                  - It is an example of impure pipe , 
                                    This pipe has internal state that holds an underlying subscription created by subscribing to the observable passed to the pipe as a parameter
                                  - Because of that Angular has to create a new instance for each pipe usage to prevent different observables affecting each other. 
                                    And also has to call transform method on each digest 
                                    because even thought the observable parameter may not change the new value may arrive through this observable that needs to be processed by change detection.
                                  - However async pipe unsubscribes itself from observables on 'ngOnDestroy()'
                                    


ngDIRECTIVES
=====================
Written in html files
Three types of directives:
 1. Custom Attribute Directives
 --------------------------------
 > ng generate directive <directive_name>
 - using a @Directive decorator we can make custom attribute directive which can change appearances such as 
   text color, background color and font size of the body of an HTML element that can be called host element. 
   To change appearance angular provides ElementRef class that can directly access DOM.
 - Benefits of using custom directive
   - When we directly use ElementRef in our application, it is vulnerable to XSS (cross site scripting) attacks.
   - It is better to create a custom directive and use ElementRef inside directive to change appearance or behavior of the host element.
 - Steps
   - Create a class decorated with @Directive.
   - Assign the attribute directive name to the selector metadata of @Directive decorator, enclosed within bracket [], ex: [colorChange]
   - Create constructor of class to get instance of ElementRef by dependency injection, which can access DOM to change host element appearance and behavior
     - we can also use @HostBinding, which allows to set properties of the host element from the directive class.
     - example :  @HostBinding('style.background-color') private background = '#f5fcff';
                  @HostBinding('style.opacity') private opacity = '1';
                  @HostBinding('class.card-outline-primary') private ishovering: boolean = false;
                  /* these can be used in @HostListener() */
                  this.background = "#f00";
                  this.opacity = "0.5";
                  this.ishovering = true;
   - Use @Input() / @Output() decorator to accept or attach event to user input in our custom directive.
   - Use @HostListener() decorator to listen to events in custom attribute directive.
     - It accepts DOM event to listen for and an array which is set of arguments to pass to handler method when the event occurs.
     - example :  @HostListener('click', ['$event.target']) onClickFn(btn) { }
               :  @HostListener('dragover', ['$event']) onDragOverFn(evt) { }
   - Configure custom attribute directive class (ex: MyDirective) in respective .module.ts in the 'declarations' array metadata of @NgModule.
   // example
      @Directive({
         selector: '[colorChangeDirective]'
      })  
      export class MyDirective {
         @Input('colorChangeVAR') dynamicColor: string;
         @Input() defaultValueVAR: string; 
         
         constructor(private elRef: ElementRef) { this.defaultValueVAR = "white"; }
         
         @HostListener('mouseenter') onMouseEnterEventFunctionName() {
            this.changeBackgroundColor(this.dynamicColor || this.defaultValueVAR);
         }
         @HostListener('mouseleave') onMouseLeaveEventFunctionName() {
            this.changeBackgroundColor('white');
         }
         private changeBackgroundColor(color: string) {
            this.elRef.nativeElement.style.backgroundColor = color;
         }    
      }
      <p colorChangeDirective colorChangeVAR="yellow" defaultValueVAR="red">....Test text....</p>
 
 2. Component Directive
 -----------------------------
 Each component is itself a directive too with selector metadata provided with @Component decorator
 @Component({
    templateUrl: "",
    styleUrls: [],
    selector: "comp-selector"
 })
                                USAGE : <comp-selector> Component not available </comp-selector>
 
 3. Structural Directives
 -----------------------------
*ngIf is used for if logic while rendering HTML and *ngFor is used for loops in HTML rendering
These are Structural directives and should be prefixed with *
Reference : https://angular.io/guide/structural-directives

1. *ngIf                         // *ngIf="isValid; else other_content;"      <ng-template #other_content>isValid is false</ng-template>
                                 // *ngIf="num>10;then greater else smaller;" <ng-template #greater>num Greater 10</ng-template>
                                 //                                           <ng-template #smaller>num Smaller 10</ng-template>
                                 
2. *ngFor                        // *ngFor="let item of items; let i = index"        // index of <item> in <items> array

3. [ngSwitch]    ,    *ngSwitchCase



@VIEWCHILD / @VIEWCHILDREN
================================
It provides reference to HTML DOM, similar to "document.getElementById()" in core JS.
This concept can be used in following 3 ways
1. Native HTML Element Reference              (Component .TS ==> <== Component .HTML)
// used ngAfterViewInit and not ngOnInit() in example as this is called when DOM/template is constructed.
// example
// component.html
   <input type='text' #nameElementReference [(ngModel)]='nameFilter' />
   <input type='text' #locationElementReference [(ngModel)]='locationFilter' />
// component.ts
   @ViewChild("nameElementReference", {static: false}) nameElementRefVAR: ElementRef;
   @ViewChildren("nameElementReference, locationElementReference") filterElementRefsVARLIST: QueryList<ElementRef>;
   ngAfterViewInit() {
      console.log(this.nameElementRefVAR);
      console.log(this.filterElementRefsVARLIST);
      this.nameElementRefVAR.nativeElement.focus();
    }

2. Angular Form/Model Reference               (Component .TS ==> <== Component .HTML)
// used for reference to form having ngForm/ngModel reference
// example
// component.ts
   @ViewChild(NgForm, {static: false}) addUserFormReferenceVAR: NgForm;              // 1. Only the first ngForm is returned.
   @ViewChild("formRef", {static: false}) addUserFormReferenceVAR: NgForm;           // specific ngForm i.e.    <form #formRef="ngForm">
                                                                                     // usage eg:- addUserFormReferenceVAR.submitted | addUserFormReferenceVAR.dirty
   @ViewChild(NgModel, {static: false}) ngmodelRefVAR: NgModel;                      // 1. Only the first ng-model is returned.
   @ViewChildren(NgModel) ngmodelsRefVARLIST: QueryList<NgModel>;                    // 2. Returns all the ng-models.
   onSubmit(formValue: any) {
      this.addUserFormReferenceVAR.reset({<NAME_ATTR_VALUE_WIDGET> : "GNDC"});       // reset is angular method , fields not specified will be set to empty
    }
    ngAfterViewInit() {
       if(this.ngmodelRefVAR.invalid) {
          if(this.ngmodelRefVAR.errors.required)  console.log("Name is required...");
          else if (this.ngmodelRefVAR.errors.minlength)  console.log(`Name must be at least 3 characters long...`);
        }
        else {
          console.log(`Current name value: ${this.ngmodelRefVAR.value} ...`);
        }
     }

3. Variable/Method Reference                  (Child Component ==> Parent Component)
// this concept is similar to @Output
// example
A) parent.html
   <p>{{employeesRefTEMPLATE.METHOD()_OR_VAR}}</p>
   <employees #employeesRefTEMPLATE></employees>
 
B) parent.ts
   @ViewChild('employeesRefTEMPLATE', {static: false}) employeesComponentRefVAR: EmployeesComponent;
C) @ViewChild(EmployeesComponent, {static: false}) employeesComponentRefVAR: EmployeesComponent;
    ngAfterViewInit(): void {
       console.log(`Logging through template reference => ${this.employeesComponentRefVAR.METHOD()_OR_VAR}`);
       console.log(`Logging through Child Component => ${this.employeesComponentRefVAR.METHOD()_OR_VAR}`);
    }
   


Angular Animations
=========================
From Angular 4 , animations are part of separate animations library and not part of angular core library as it was earlier.
inside app.module.ts             import BrowserAnimationsModule and write it in imports[] array
inside component's .ts file      animations: [] ,this contains animationName and it's properties, just like template and css properties given.
                                 stateVar: string = "small";                            // this variable change will trigger animation
                                 animateFunc(){
                                    this.stateVar=(this.stateVar=="small"?"large":"small");
                                 }
inside component's .html file    <p [@animationName]="stateVar" (click)="animateFunc()">some random text</p>



Angular FORMS
===================
- These forms should support Two way data binding.
- Keep track of form state, current state is valid or not, display validation errors, enable/disable form based on validation criteria.
1. Template driven forms
   - These are used if we have fixed template to render , we already know fields that are going to be part of form.
   - import 'FormsModules' from "@angular/forms" to app.module.ts imports[] array
   - create .ts class and .html template for it.
   - use of directives ngModel, ngForm, ngModelGroup, ngSubmit.
   - validations are part of template (.html)
   
   - states of form input  ,  example : 1. <input #INPUT_REF="ngModel" /> 
                                        2. <form #FORM_REF="ngForm" (ngSubmit)="submitFunction(FORM_REF.value)"></form>
     INPUT_REF.pristine | INPUT_REF.dirty             // value modified    or not
     INPUT_REF.touched  | INPUT_REF.untouched         // widget is focused or not
     INPUT_REF.valid    | INPUT_REF.invalid           // value is invlaid  or not as per constraints like (required, minlength, pattern)
   
2. Model driven forms (Reactive forms)
   - These are dynamic in nature , JS/TS intensive and less HTML.
   - import 'ReactiveFormsModule' from "@angular/forms" to app.module.ts imports[] array
   - // 1. component.TS  ,   two ways of creating a formgroup
     // 1. Using FormGroup
     customerForm: FormGroup;                                      // create new FormGroup , similar to #formRef
     ngOnInit() {
        this.customerForm = new FormGroup({                        // create new FormControl for each widget in FormGroup , supports builtin validators
            <formControlName_ATTR>: new FormControl('<INITIAL_VALUE_WIDGET>', [Validators.required, Validators.minLength(3)]),
            <formControlName_ATTR>: new FormControl('<INITIAL_VALUE_WIDGET>', [Validators.required])
        });
        // dynamic setting/clearing of validators
        this.customerForm.get('<formControlName_ATTR>').setValidators(Validators.required);     // setValidators
        this.customerForm.get('<formControlName_ATTR>').clearValidators();                      // clearValidators
        this.customerForm.get('<formControlName_ATTR>').updateValueAndValidity();               // for set/clear to take effect
        this.customerForm.updateValueAndValidity();
     }
     // ---- OR ----
     // 2. Using FormBuilder service
     customerForm: FormGroup;                                       // create new FormGroup , similar to #formRef
     constructor(private _fb: FormBuilder) { }                      // inject FormBuilder service in class
     ngOnInit() {
        this.customerForm = this._fb.group({                        // .group method of FormBuilder service
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>', [Validators.required, Validators.minLength(3)]],
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>', [Validators.required]],
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>', [CUSTOM_VALIDATOR_FUNCTION]]
        });                                                               // Custom Validator function for individual formControl defined outside @Component
                                                                             function CUSTOM_VALIDATOR_FUNCTION(ctrl: AbstractControl): { [key: string]: boolean } | null {
                                                                                if(ctrl.value.trim() == "") {
                                                                                    return {'required': true};
                                                                                }
                                                                                else if(ctrl.value.trim().length < 3) {
                                                                                    return {'minlength': true};
                                                                                }
                                                                                return null;
                                                                             }
          this.customerForm = this._fb.group({
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>'],
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>'],
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>']
        }, {validator: CUSTOM_VALIDATOR_FUNCTION});
                                                                          // Custom Validator function for entire formGroup defined outside @Component
                                                                             const CUSTOM_VALIDATOR_FUNCTION: ValidatorFn = (fg: FormGroup): ValidationErrors => {
                                                                               const password = fg.controls['formControlName_ATTR'];
                                                                               const cnfpassword = fg.controls['formControlName_ATTR'];
                                                                                if(password.value.trim() == "") {
                                                                                    password.setErrors({'required': true});
                                                                                }
                                                                                if(password.value.trim() != cnfpassword.value.trim()) {
                                                                                    cnfpassword.setErrors({'CUSTOM_ERROR_NAME': true});
                                                                                }
                                                                                return null;
                                                                              }
        
        // dynamic setting/clearing of validators
        this.customerForm.get('<formControlName_ATTR>').setValidators(Validators.required);     // setValidators
        this.customerForm.get('<formControlName_ATTR>').clearValidators();                      // clearValidators
        this.customerForm.get('<formControlName_ATTR>').updateValueAndValidity();               // for set/clear to take effect
        this.customerForm.updateValueAndValidity();
     }
     
     // set/patch value to form widgets
     this.customerForm.setValue({<formControlName_ATTR>: "Google", <formControlName_ATTR>: "Australia"});
                                                                            // all widgets <> must be supplied , else error , similar to HTTP POST
     this.customerForm.patchValue({<formControlName_ATTR>: "Google"});      // only desired <> can be supplied ,              similar to HTTP PATCH
     
     // function to retrieve HTML context
     get naamValidAlertFunc() {
         return this.customerForm.get('<formControlName_ATTR>'); 
     }
     
     // submit method
     onSubmit(){                                                        // onSubmit has no arg, as Reactive forms make use of formgroup
        let newCustomer: Customer = {
            name: this.customerForm.get('<formControlName_ATTR>').value,
            location: this.customerForm.get('<formControlName_ATTR>').value,
        };
        this.customerForm.reset();                                                              // reset form
        // dynamic setting/clearing of validators
           this.customerForm.get('<formControlName_ATTR>').setValidators(Validators.required);     // setValidators
           this.customerForm.get('<formControlName_ATTR>').clearValidators();                      // clearValidators
           this.customerForm.get('<formControlName_ATTR>').updateValueAndValidity();               // for set/clear to take effect
           this.customerForm.updateValueAndValidity();
        
        this._customersService.addCustomer(newCustomer); 
     }
     
     // 2. component.HTML                                            // onSubmit() has no arg, as Reactive forms make use of formgroup
     <form [formGroup]="customerForm" (ngSubmit)="onSubmit()">       // [formGroup] , property binding for connecting TS form to HTML
         <input type="text" formControlName="naam" />                // formControlName , similar to HTML 'name' attr
         <div *ngIf="naamValidAlertFunc.invalid && (naamValidAlertFunc.dirty || naamValidAlertFunc.touched) && naamValidAlertFunc.errors?.required" class="alert alert-danger">Naam Required</div>
         <div *ngIf="naamValidAlertFunc.invalid && (naamValidAlertFunc.dirty || naamValidAlertFunc.touched) && naamValidAlertFunc.errors?.CUSTOM_ERROR_NAME" class="alert alert-danger">CUSTOM ERROR</div>
                                                                     // usage of angular material
         <mat-error *ngIf="(customerNameInputRef.touched || customerNameInputRef.dirty) && customerNameInputRef.errors?.required">Customer name is <b>required</b></mat-error>
         
         <select [formControlName]="['formControlName_ATTR']">
            <option *ngFor="let location of locations" [value]="location">{{location}}</option>
        </select>
     </form>
     


STYLE
=================
-- A global file "styles.css" exists for entire application.
   eg:-  write   @import "https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css"

-- To force the app component's "app.component.css" effects to its child components also use
  /deep/   h1{  color:red;  }      OR
  >>>      h1{  color:red;  }

-- For component specific style use  ".component.ts"  file
   @Component({
           styleUrls:['firstcss', 'secondcss', 'thirdcss']
   })

-- CLASS BINDING
   Binding a CSS class to elements    eg:- [class.CLASS_NAME_CSS] = "Boolean_VAR_EXPRESSION"
                                           [ngClass] = "'firstCSSClass secondCSSClass'"                          // NOTE : use of '' over class names
                                           [ngClass] = "['firstCSSClass' , 'secondCSSClass']"
                                           [ngClass] = "{'firstCSSClass' : i%2==0 , 'secondCSSClass' : i%2==1}"
					   [style.left]="'15px'"
					   [style.background-color]="'blue'"
					   [style.font-size]="Boolean_VAR_EXPRESSION ? '20px' : '12px'"



PASSING VARIABLES/VALUES TO and FROM COMPONENTS
=================================================
This concept is used when we have a common class for data that can be used by multiple components (child components)
-- OUTER COMPONENT (parent) to INNER COMPONENT (child)
   In child-comp.ts
   --------------------
   @Input('EXTERNAL_VAR_NAME') INTERNAL_VAR_NAME: string = "DefaultValue";
   
   In child-comp.html
   ---------------------
   {{INTERNAL_VAR_NAME}}
   
   In parent-comp.html
   ---------------------
   <child-selector-tag  [EXTERNAL_VAR_NAME] = "varFromParent.ts" > default text if child component not available </child-selector-tag>


-- INNER COMPONENT (child) to OUTER COMPONENT (parent)
   this is used to receive a message in parent based on an event triggered in child
   in INNER COMPONENT                    import {EventEmitter} from '@angular/core'
   In child-comp.ts
   ----------------------
   @Output() outputVarName: EventEmitter<string> = new EventEmitter<string>();
   
   functionOnEvent() {
       this.outputVarName.emit(dataToEmit);
   }
   
   In parent-comp.html
   ----------------------
   <child-selector-tag  (outputVarName)='functionReceiveMessage($event)' > default text if child component not available </child-selector-tag>
   
   In parent-comp.ts
   ----------------------
   functionReceiveMessage($event): void {
       this.DATA = $event;
   }



LIFECYCLE methods
==========================
After creating a component/directive by calling its constructor,
Angular calls the lifecycle hook methods in the following sequence at specific moments

constructor() {  }
The constructor method is not actually an Angular 2 method. 
It is a predefined method in a TypeScript class which is called when the class is instantiated. 
The constructor’s purpose is to help prepare the creation of a new instance of the class.
In the context of Angular 2 it can be used to properly initialize fields.
Angular 2’s DI (dependency injection) also tries to find providers that match the types of the constructor’s parameters, resolves them, and passes them to the constructor as arguments.

ngOnChanges()	 {  }
Respond when Angular (re)sets data-bound @Input properties.
Called before ngOnInit() and whenever one or more data-bound @Input properties change.
The method receives a SimpleChanges object of current and previous property values.
example:
        TS  (child.comp.ts)
        @Input() varOfChild: string;
        
        ngOnChanges(changes: SimpleChanges) {
          for (let propName in changes) {
            let chng = changes[propName];               // propName = varOfChild
            let cur  = chng.currentValue;               // any
            let prev = chng.previousValue;              // any
            let firstChange = chng.isFirstChange();     // boolean
          }
        }
        HTML  (parent.comp.html)
        <childComp [varOfChild]="varFromParentTS"></childComp>

ngOnInit()    {  }
Called once, after the first ngOnChanges().
meaning that all of the injected dependencies will be resolved and all of the class members will be defined.
This makes it the perfect place to do any of the initialization work/logic for the component.

ngDoCheck()	
Detect and act upon changes that Angular can't or won't detect on its own.
Called during every change detection run, immediately after ngOnChanges() and after ngOnInit() on the first run.

ngAfterContentInit()
Content is what is passed as children usually to be projected at some <ng-content> element of a component.
View is the template of the current component.
Respond after Angular projects external content into the component's view / the view that a directive is in.
Called once after the first ngDoCheck().

ngAfterContentChecked()	
Respond after Angular checks the content projected into the directive/component.
Called after the ngAfterContentInit() and every subsequent ngDoCheck().

ngAfterViewInit()
Content is what is passed as children usually to be projected at some <ng-content> element of a component.
View is the template of the current component.
Respond after Angular initializes the component's views and child views / the view that a directive is in.
Called once after the first ngAfterContentChecked().

ngAfterViewChecked()	
Respond after Angular checks the component's views and child views / the view that a directive is in.
Called after the ngAfterViewInit() and every subsequent ngAfterContentChecked().

ngOnDestroy()	
Cleanup just before Angular destroys the directive/component.
Unsubscribe Observables and detach event handlers to avoid memory leaks.
Called just before Angular destroys the directive/component.

Example:
Written in  ".component.ts"  of  respective COMPONENT
        export class COMPONENTNAME implements OnInit , OnChanges , OnDestroy{  }
        
        
        
Feature MODULES
=====================
> ng generate module <module_name>
- Having all (say 100s) components in one module (root module, app.module.ts) might make it difficult to debug
  plus it might make initial loading slower as all modules are to be loaded, if not used lazy loading, which is possible via submodules
- // example
  // 1. app-module.ts (ROOT module imports submodules)
  @NgModule({
     declarations: [AppComponent, AboutComponent, PageNotFoundComponent],
     imports: [ BrowserModule, EmployeesModule, CustomersModule, AppRoutingModule ],       // NOTE : root routing module must be after feature module ie at last, else it will load page not found component
                                                                                           // 'FormsModule' is not written as 'EmployeesModule' already imported it via 'SharedModule'
     bootstrap: [ AppComponent ]
  })
  export class AppModule { }
  
  // 2. app-routing-module.ts
  @NgModule({
     imports: [
       RouterModule.forRoot(appRoutes)                                                     // NOTE : use of 'RouterModule.forRoot()'
     ],
     exports: [ RouterModule ]
   })
   export class AppRoutingModule { }

  // 3. customer-module.ts
  @NgModule({
     declarations: [CustomersComponent, CustomerComponent],
     imports: [SharedModule, CustomersRoutingModule]
   })
   export class CustomersModule { }
   
   // 4. customer-routing-module.ts
   {path:'', component: CustomersComponent, canActivate: [CustomersLoadGuardService], resolve: {customers: CustomersResolverService}},
   {path:'customers/<COMPONENT_NAME>/edit/:id', component: CustomerDetailComponent }
   @NgModule({
      imports: [
        RouterModule.forChild(custRoutes)                                       // NOTE : use of 'RouterModule.forChild()' in submodules
      ],
      exports: [ RouterModule ]
   })
   export class CustomersRoutingModule { }
   
   // 5. employee-module.ts
   @NgModule({
      declarations: [EmployeesComponent, EmployeeComponent],
      imports: [SharedModule, EmployeesRoutingModule]
   })
   export class EmployeesModule { }
   
   // 6. employee-routing-module.ts
   {path:'', component: EmployeeComponent, canActivate: [EmployeeLoadGuardService], resolve: {employees: EmployeeResolverService}},
   {path:'employees/<COMPONENT_NAME>/edit/:id', component: EmployeeDetailComponent }
   @NgModule({
      imports: [
        RouterModule.forChild(empRoutes)                                        // NOTE : use of 'RouterModule.forChild()' in submodules
      ],
      exports: [ RouterModule ]
   })
   export class EmployeesRoutingModule { }
   
   // 7. shared-module.ts
   @NgModule({
      declarations: [],
      imports: [],
      exports: [                                                // Being a shared module , it has common functionality required for all modules and export them
                                                                // NOTE : shared module cannot have 'providers' ie we cannot include @Injectable class (service class)
                                                                          because services which act as singletons, could end up being provided multiple times, especially for lazy-loaded modules.
        CommonModule,                                           // since 'CommonModule', 'FormsModule', 'SearchFilterPipe' is exported here and
        FormsModule,                                               we imported 'shared-module' in 'customer-module' which is in turn is imported in app-module (root)                   
        SearchFilterPipe
      ]
    })
    export class SharedModule { }
    
    // 8. searchfilterpipe.ts
    @Pipe({name: 'searchFilter'})
    export class SearchFilterPipe implements PipeTransform{
       transform(items: any[], args: string): any[] {
          let searchFilter: string = args ? args.toLocaleLowerCase() : null;
          return searchFilter ? items.filter((item) => {item.name.toLocaleLowerCase().startsWith(searchFilter) != false}) : items;
    }}


LAZY LOADING
===================
- NOTE :  Creating submodules / feature modules do not ensure lazy loading. We need to configure routing module for same.
- There are three types of module loading
  - Eager loading                        (default)                                   (all modules loaded initially)
  - Lazy Loading without Pre-Loading     (default, when configured for lazy loading) (modules loaded only when required)
  - Lazy Loading with Pre-Loading                                                    (modules loaded by browser in background when it is not involved in any other activity)
  // example
  // 1. app-routing-module.ts     (ROOT routing module)
  // this will make modules to be lazy loaded
  { path: 'employees', loadChildren: () => import('./employees/employees.module').then(m => m.EmployeesModule) },
  { path: 'customers', loadChildren: () => import('./customers/customers.module').then(m => m.CustomersModule) },
  
  // this will enable/disable preloading
  @NgModule({
    imports: [
     RouterModule.forRoot(appRoutes)                                                   // default,       no preloading
  // RouterModule.forRoot(appRoutes, {preloadingStrategy: NoPreloading})               // same as above, no preloading
  // RouterModule.forRoot(appRoutes, {preloadingStrategy: PreloadAllModules})          // preload modules when browser is idle
    ],
    exports: [ RouterModule ]
  })
  export class AppRoutingModule { }
  
  // 2. customers/employees-routing-module.ts
  // NOTE : do not specify name of modules in url i.e. {path: 'customers/<COMPONENT_NAME>/:id'} because it is already specified in root i.e. {path:'customers'}
  {path:'', component: CustomersComponent, canActivate: [CustomersLoadGuardService], resolve: {customers: CustomersResolverService}},
  {path:'<COMPONENT_NAME>/edit/:id', component: CustomerDetailComponent }
  
  // 3. app-module.ts
  @NgModule({
     declarations: [AppComponent, AboutComponent, PageNotFoundComponent],
     imports: [ BrowserModule, AppRoutingModule ],                          // NOTE : Do not include feature modules i.e. 'CustomersModule', 'EmployeesModule' here as they are to be lazy loaded
     bootstrap: [ AppComponent ]
  })
  export class AppModule { }




SERVICE
====================
Write a     ".service.ts"   file for COMPONENT   and  use   @Injectable()  decorator over   export class ServiceClass{  }
            > ng generate service <SERVICE_NAME>

declare in  "providers" array  of  "app.module.ts"  this  service class
            OR
if metadata providedIn: 'root' is given in @Injectable({}) decorator , it prevents need to write in "providers" array of app.module.ts

Write URL for ".servive.ts" in a global class (Global) i.e.   src > app > config > `www.service.ts` file.
Inject in component/module  ".service.ts"  using  constructor()
	example: constructor(private global: Global) { global.baseURL; }
This will prevent need to change URL for each component/module ".service.ts" since it is available in a globally accessible file.

Inject in     ".component.ts"  file  of COMPONENT using   constructor()

COMMUNICATION with SERVICE
---------------------------
NOTE      : MAKE sure to install JSON SERVER   "npm install -g json-server"
Reference :                                    "https://github.com/typicode/json-server"

NOTE : JSON-Server uses default KEYWORD  "id"
Create a .JSON file under dir        "PROJ\src\"

CHANGE DIR to your .JSON file's dir  "PROJ\src\"
Start JSON SERVER                              "json-server -–watch filename.json"       // --watch keeps check over any changes made

OPEN new TERMINAL window
CHANGE DIR to "PROJ"  as it is where "package.json" is present
Start ng      "ng serve"

declare  "HttpClientModule" in  "imports"  of  "app.module.ts"

configure ".service.ts"

CREATE    "interface.ts"  file and export interface
           > ng generate interface <INTERFACE_NAME>

configure ".component.ts" file



Use of HttpClientModule
------------------------
HTTP request is made in browser using either XMLHttpRequest or fetch().
import {HttpClientModule} from "@angular/common/http" and included in imports[] array.
HttpClientModule provides testability features, typed request and response objects, request and response interception, Observable APIs, Streamlined error handling.
-- PROMISE         (SUCCESS data , ERROR data)
-- OBSERVABLES     (SUCCESS data , ERROR data , DONE)  these are required to be SUBSCRIBED , .subscribe() triggers execution of  OBSERVABLES and causes HttpClient to compose and send request to server.
-- JSON SERVER     (a .json file is to be added in src of PROJECT)

import {HttpHeaders} from "@angular/common/http"
const httpOptions = {
  headers: new HttpHeaders({
    'content-type' : 'application/json',
    'authorization' : 'tokenValue'
  })
}
import 'rxjs' in app.module.ts     // RxJS is a library for reactive programming using Observables, to make it easier to compose asynchronous or callback-based code.


Difference between "ActivatedRoute" and "ActivatedRouteSnapshot"
===================================================================
NOTE : Generally speaking, subscribing is the safest i.e. use ActivatedRoute

Use the Snapshot if you only need the initial value of the parameter once during the component's initialization, 
and don't expect the URL to change while the user is still on that same component.
Using snapshot will have two versions of ActivatedRouteSnapshot for the same ActivatedRoute with different params.
Example : if on a `product/2` route, and the only way to get to `product/3` is by going back and then clicking a product detail 
i.e. (leaving the detail component, then re-opening it with a new route param)

Use the Observable if it's possible for the route to change while the user is still on the same component, 
and hence Component's initialization would not be called again, but observable would call your subscribed logic when the URL changed.
Example : if on a `product/2` route, and you have a "next" button to go to the next id record `product/3`.
i.e. (did not leave/re-open the component but the URL did receive a new param)


CLIENT SIDE ROUTING
=============================
Multiple routes... eg: localhost:4200/home/signup/

Import and write in "imports"   of     "app.module.ts"   the routing object which was exported from "app.routing-module.ts"

NOTE : wherever define    <router-outlet></router-outlet>    routing module urls output shown there

NOTE : <a href=""> ... </a>  sends request to BROWSER directly , so use routerLink="" to send control to routerModule  
If the link is static, we can use                                <a routerLink="/product/iPhone"></a>
If the link is dynamic, , NOTE : use of '' inside string         <a [routerLink]="['staticURLArg', dynamicArg_VAR, 'staticURLArg']"></a>
Set single CSS class to active link using                        routerLinkActive="CSS_Class"
Set multiple CSS classes , NOTE : use of '' inside string        [routerLinkActive]="['CSS_CLASS_1', 'CSS_CLASS_2']"
For exact match of urls use                                      [routerLinkActiveOptions]="{exact:true}"
For partial match  ,  eg:- employees/:DYNAMIC_ROUTING , DO NOT use {exact:true}

Create file         "app.routing-module.ts"   in project's app component root dir , which contains urls/routes
                     NOTE : Do not put '/' in path , ANGULAR will put it automatically
                     - examples
                     {path: 'URL', component: 'NameOfComponentClass', data: {dataVAR_IN_ROUTE: 'dataPassedToComponent'}
                     }                                                                 // data accessed via ActivatedRoute in component
                     {path: 'employees', children: [
                                  { path: '', component: EmployeesComponent },
                                  { path: 'add', component: AddEmployeeFormComponent, canDeactivate: [AddEmployeeGuardService]},
                                  { path: ':id', component: EmployeeDetailComponent, canActivate: [EmployeeDetailGuardService]}]
                     }                                                                       // specify children path to avoid writing parent-'employees/' again and again
                     {path: '**', component: 'NoneOfAboveURLMatchRequest'}                   // when none of URLs match request it comes here
                     {path: '', component: 'BaseComponent'}                                  // empty path means BASE_URL ie '/'
                     {path: '', component: 'BaseComponent', pathMatch: 'full' }              // whole URL path needs to match
                     {path: '', component: 'BaseComponent', pathMatch: 'prefix' }            // first route where the path matches the start of the URL is chosen
                     {path: 'URL', component: '', canActivate: [RouteAuthServiceName], canDeactivate: [RouteAuthServiceName], canLoad: [RouteAuthServiceName], resolve: { dataVAR_IN_ROUTE: RouteAuthServiceName }}
                           // To restrict access to a URL/Component , there are 5 types of route guards :-
                           // CanActivate     : Controls if route can be activated.
                              CanActivateChild: Controls if children of a route can be activated.
                              CanLoad         : Controls if route can even be loaded. 
                                                This becomes useful for feature modules that are lazy loaded. 
                                                They won’t even load if the guard returns false, thus cannot even see the source code of the module.
                                                It must be used with canActivate, because once loaded and user logged out, it will still be present in browser cache, guard will return true.
                              CanDeactivate   : Controls if the user can leave a route. 
                                                NOTE : This guard doesn’t prevent the user from closing the browser tab or navigating to a different address. 
                                                       It only prevents actions from within the application itself.
                              Resolve         : To complete data retrieval before navigating to a route
                                                Refer: loading.io/css    for loader's HTML (app.component.html) + CSS (app.component.css)
                                                NOTE : it uses NAVIGATION instance as written in app.component.ts (ROOT component)
                                                       plus get snapshot of data in component where the data is shown after retrieval
                                                // 1. app.component.ts
                                                export class AppComponent {
                                                   isLoading: boolean = true;        // variable for loader <div> i.e.   *ngIf="isLoading"
                                                   
                                                   constructor(private _authService: AuthService, private _router: Router) {
                                                      this._router.events.subscribe((event: Event) => {
                                                          if (event instanceof NavigationStart) {
                                                             this.isLoading = true;
                                                          }
                                                          else if (event instanceof NavigationEnd || event instanceof NavigationError || event instanceof NavigationCancel) {
                                                             this.isLoading = false;
                                                          }
                                                       }) 
                                                    }
                                                 }
                                                 // 2. component.ts
                                                 constructor(private _route: ActivatedRoute) {
                                                    // a. Not Preferred , using "ActivatedRouteSnapshot"
                                                    this.dataVAR_IN_COMPONENT = this._route.snapshot.data['dataVAR_IN_ROUTE'];
                                                    
                                                    // b. Preferred , to use "ActivatedRoute" and SUBSCRIBE
                                                    this._route.data.subscribe((data: Data) => {
                                                        console.log(`${data['dataVAR_IN_ROUTE']}`);
                                                    },
                                                    (err: Error) => {
                                                        console.error(`ERROR in DATA ==> ${err.message}`);
                                                    });
                                                 }
                           // we could specify multiple guards service for a route guard in a route, and they’ll be evaluated in the order in array for that route guard.
                           // NOTE : Declare route authentication service(s) name(s) in 'providers' array of respective '.module.ts'
                           // example - RouteAuthServiceName.ts
                           @Injectable()
                           export class RouteAuthServiceName implements CanActivate, CanDeactivate<ComponentNameToDeactivate>, CanLoad, Resolve<TYPE_OF_DATA_RETURN> {
                              constructor(private _productService: ProductService, private _router: Router) {}
                              
                              canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
                                 if(this.METHOD_VAR_IN_SERVICE) {                   // returns true/false , can be from other service as well  eg: this.authService.METHOD_VAR_IN_SERVICE
                                    return true;
                                 }
                                 else {
                                    this._router.navigate(['login']);
                                    return false;
                                 }
                              }
                              
                              canDeactivate(component: ComponentNameToDeactivate, route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
                                 if (component.METHOD_VAR_IN_COMPONENT) {                   // returns true/false from a method/variable in component to be deactivated, 
                                                                                               we can make use of @ViewChild variables in component.ts
                                    return confirm('Are you sure?');
                                 }
                                 if(component.editProductForm.dirty && !component.formSubmitted) {
                                    return confirm(`You have unsaved changes. Are you sure to leave ?`);
                                 }
                                 else {
                                    return true;
                                 }
                              }
                              
                              canLoad(route: Route): boolean { }
                              
                              resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Promise<TYPE_OF_DATA_RETURN> | Observable<TYPE_OF_DATA_RETURN> | any {
                                  if(state.url.indexOf("detail") != -1 || state.url.indexOf("edit") != -1) {
                                      return this._productService.getProduct(route.params['id']);
                                  }
                                  else if(state.url.indexOf("topproducts") != -1) {
                                      return this._productService.getTopProducts();
                                  }
                                  else {
                                      return this._productService.getAllProducts();
                                  }
                              }
                            }

DYNAMIC ROUTING
===================
REST APIs have four types of parameters:
 - Header parameters: Parameters included in the request header, usually related to authorization.
 - Path parameters: Parameters within the path of the endpoint, before the query string (?).
 - Query string parameters: Parameters in the query string of the endpoint, after the ?.
 - Request body parameters: Parameters included in the request body. Usually submitted as JSON.
 
 1. Header parameters
 --------------------
 Example : ".service.ts"           , private httpOptions = {
                                        headers: new HttpHeaders({
                                          'Content-Type':  'application/json'
                                        }),
                                        params: {                                 // appended as query string parameters in request URL
                                          "chkP" : "namo ji",
                                          "chkP1" : "PM"
                                        }
                                     };
                                     constructor(private _http: HttpClient) { }
                                     addProduct(HTTP_BODY) {
                                         return this._http.post(this._productsUrl, HTTP_BODY, this.httpOptions)
                                                          .pipe(catchError((err: Error) => { return throwError(err.message) })); }
 NOTE - To read HTTP RESPONSE HEADERS, use INTERCEPTORS.

 2. Path Parameters
 --------------------
  using colon (:) in path to attach path params with route.
  Example : "app.routing-module.ts" , {path : "PARENT-URL/:varname_1/:varname_2"}
            "component.html"        , <a routerLink="/dashboard/78990/kapoor">URL</a>
            
            "component.ts"          , constructor(private route: ActivatedRoute) {
                                          // a. Not Preferred , using "ActivatedRouteSnapshot"
                                          console.log(`${route.snapshot.params['varname_1']}`);           // 78990 i.e. value of varname_1 param
                                          console.log(`${route.snapshot.paramMap.get('varname_2')}`);     // kapoor i.e. same as above , using ParamMap
                                          console.log(`${route.snapshot.paramMap.keys}`);                 // ['varname_1', 'varname_2']
                                          
                                          // b. Preferred , using ActivatedRoute and SUBSCRIBE
                                          route.params.subscribe((param: Params) => {
                                              console.log(`${param['varname_1']}`);                      // 78990 i.e. value of varname_1 param
                                          });
                                          route.paramMap.subscribe((parammap: ParamMap) => {
                                              console.log(`${parammap.get('varname_2')}`);               // kapoor i.e. same as above , using ParamMap
                                              console.log(`${parammap.keys}`);                           // ['varname_1', 'varname_2']
                                          });
                                      }
                                      
 3. Query string parameters
 ----------------------------
  using [queryParams] in <a></a> OR in router.navigate([]) OR in HTTP options in a ".service.ts" to attach Query string params with route.
  Example : "component.html"        , <a routerLink="/targetComp/78990/kapoor" [queryParams]="{q1: 'mapcolumns', q2: [163, 592, 586]}"></a>
                                    OR
            "component.ts"          , this.router.navigate(['targetComp'], { queryParams: { q1: 'mapcolumns', q2: [163, 592, 586]}});
                                    OR
            ".service.ts"           , REFER passing header or body parameter example
            "app.routing-module.ts" , {path : "targetComp/:varname_1/:varname_2", component: TargetComponent}
            
            "targetComponent.ts"    , constructor(private route: ActivatedRoute) {
                                         // a. Not Preferred , using "ActivatedRouteSnapshot"
                                         console.log(`${route.snapshot.queryParams['q1']}`);             // 'mapcolumns'
                                         console.log(`${route.snapshot.queryParamMap.get('q2')}`);       // 163
                                         console.log(`${route.snapshot.queryParamMap.getAll('q2')}`);    // [163, 592, 586]
                                         console.log(`${route.snapshot.queryParamMap.keys}`);            // ['q1', 'q2']
                                         
                                         // b. Preferred , using ActivatedRoute and SUBSCRIBE
                                         route.queryParams.subscribe((qparam: Params) => {
                                             console.log(`${qparam['q1']}`);                            // 'mapcolumns'
                                         });
                                         route.queryParamMap.subscribe((qparammap: ParamMap) => {
                                             console.log(`${qparammap.get('q2')}`);                     // 163
                                             console.log(`${qparammap.getAll('q2')}`);                  // [163, 592, 586]
                                             console.log(`${qparammap.keys}`);                          // ['q1', 'q2']
                                         });
                                      }
 4. Request body parameters
 ---------------------------
 Example : ".service.ts"           , private httpOptions = {
                                        headers: new HttpHeaders({
                                          'Content-Type':  'application/json'
                                        }),
                                        params: {                                 // appended as query string parameters in request URL
                                          "chkP" : "namo ji",
                                          "chkP1" : "PM"
                                        }
                                     };
                                     constructor(private _http: HttpClient) { }
                                     addProduct(HTTP_BODY) {
                                         return this._http.post(this._productsUrl, HTTP_BODY, this.httpOptions)
                                                          .pipe(catchError((err: Error) => { return throwError(err.message) })); }
 NOTE - To read HTTP RESPONSE BODY, use INTERCEPTORS.



CONTEXT PATH
=================
Add a suffix to server hostname (IP/PORT) that is common and specific to our whole angular application.
One way can be to write the common suffix part before each route path in routing.module.ts and also with navigate() functions, if any.
A better approach is to use APP_BASE_HREF as follows:
- app.module.TS
  import {APP_BASE_HREF} from '@angular/common';

  // inside providers array
  providers: [{provide: APP_BASE_HREF, useValue: '/esp/kapoor/rakshit'}]



LOCATION STRATEGIES
=====================
REFERENCE   :   https://codecraft.tv/courses/angular/routing/routing-strategies/

we have two strategies we can use to implement client side routing,
one is called the HashLocationStrategy and the other is called the PathLocationStrategy.

The default in Angular is the PathLocationStrategy, if we do nothing that is the strategy Angular will employ.


HashLocationStrategy
---------------------
To enable HashLocationStrategy in an Angular application we pass {useHash: true} when we are providing our routes with RouterModule
eg:-  RouterModule.forRoot(routes, {useHash: true})

URL can contain some data prepended with a # character.

The # part of the url is called the hash fragment.

It’s normally used so that people can link to a particular section in a HTML page, specifically anchor tags,
for example if there is an anchor tag with an name attribute of routing-strategies like so:

<a name="routing-strategies"></a>

Then if you created a bookmark of   http://somedomain.com/page#routing-strategies
Then the browser would open somedomain.com/page and then scroll down so that the <a name="routing-strategies"></a> tag is at the top of the page.

Also anything past the # in a URL never gets sent to the server.
So if your URL was   https://codecraft.tv/contact/#/foo/moo/loo   then the browser makes a GET request to https://codecraft.tv/contact/ only.
The #/foo/moo/loo part of the URL is never sent.

It preserves a state of page and so on RELOADING a page , the UI state is maintained.



HTTP INTERCEPTORS
========================
- Interceptors allow to inspect & transform Http requests before it goes to the server ie act as gate between outgoing requests or incoming responses.
  Multiple interceptors can be chained, NOTE : The interceptors will be called in the order in which they were provided.
  It is useful for logging, authentication etc.
  If interceptor was not there, the code has to be duplicated in each HttpClient method call.
  
- Steps
  1) Create an Injectable class for each type of interceptor implementing interface HttpInterceptor
  2) In the interface method, intercept, handle the request appropriately and call next so that the next interceptor in the chain can handle until the last interceptor
     The intercept method takes two arguments, req and next, and returns an observable of type HttpEvent.
          req is the request object itself and is of type HttpRequest.
          next is the http handler, of type HttpHandler. The handler has a handle method that returns our desired HttpEvent observable.
     HttpRequest objects are immutable, The request object’s clone method is used to first make a copy, then modify the copy and call handle on the modified copy.
  3) The class implementing HttpInterceptor should be mentioned in 'providers' array in AppModule.ts.
     multi: true option tells Angular that HTTP_INTERCEPTORS is a token for a multiprovider that injects an array of values, rather than a single value.
  // example
  // 1. log-interceptor.ts
  @Injectable()
  export class LogRequestInterceptor implements HttpInterceptor {
    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
       console.log(`**** LogRequestInterceptor => url = ${req.url}, method = ${req.method}`);
       req.headers.keys().map((key) => {console.log(`${key}=${req.headers.get(key)}`)});
       return next.handle(req);
     }
   }
   
   // 2A. auth-interceptor.ts
   //     Intercepting HTTP Request
   @Injectable()
   export class AuthInterceptor implements HttpInterceptor {
     intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
     
       console.log(`**** REQUEST URL **** ==> ${req.url}`);
       console.log(`**** REQUEST PARAMETERS URL **** ==> ${req.urlWithParams}`);       // URL with all query string parameters (including those passed in HTTP options)
       console.log(`**** REQUEST BODY **** ==> ${JSON.stringify(req.body)}`);
       console.log(`**** REQUEST HEADERS **** ==> ${req.headers.keys()}`);
       console.log(`**** REQUEST PARAMS **** ==> ${req.params.keys()}`);              // query string parameters passed in HTTP options only
       
       if(req.body && req.headers && req.params){
          duplicate = req.clone({
            headers: req.headers.set('Authorization', "mytoken"),
            params: req.params.set('filter', 'completed'),
            body: req.body.replace(/pizza/gi, 'desi_bread')
          });
          return next.handle(duplicate);
       }
       return next.handle(req);
     }
    }
    
   // 2B. auth-interceptor.ts
   //     Intercepting HTTP Response
   @Injectable()
   export class AuthInterceptor implements HttpInterceptor {
     intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {

       console.log(`**** REQUEST URL **** ==> ${req.url}`);
       console.log(`**** REQUEST PARAMETERS URL **** ==> ${req.urlWithParams}`);       // URL with all query string parameters (including those passed in HTTP options)
       console.log(`**** REQUEST BODY **** ==> ${JSON.stringify(req.body)}`);
       console.log(`**** REQUEST HEADERS **** ==> ${req.headers.keys()}`);
       console.log(`**** REQUEST PARAMS **** ==> ${req.params.keys()}`);              // query string parameters passed in HTTP options only

       // specify url for whose RESPONSE headers required
       if(req.url.toLowerCase().includes("filedata")) {
        return next.handle(req).pipe(
            // There may be other events besides the response
            filter(event => event instanceof HttpResponse),
            tap((event: HttpResponse<any>) => {
                console.log(`RESPONSE URL ==> ${event.url}`);                        // same as HTTPRequest.urlWithParams
                console.log(`RESPONSE BODY ==> ${JSON.stringify(event.body)}`);
                console.log(`RESPONSE HEADERS ==> ${event.headers.keys()}`);
            })
        );
       } else {
           return next.handle(req);
       }
     }
    }
    
    // 3. httpInterceptorsProvider.ts
    import { HTTP_INTERCEPTORS } from '@angular/common/http';
    import { LogRequestInterceptor } from './log-request-interceptor';
    import { AuthInterceptor } from './auth-interceptor';
    export const httpInterceptorProviders = [
      { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },                // order matters of providing interceptors
      { provide: HTTP_INTERCEPTORS, useClass: LogRequestInterceptor, multi: true }
    ];
    
    // 4. app.module.ts
   providers : [httpInterceptorProviders]
   
   
PROXYING TO A BACKEND SERVER
================================
- Providing relative (`/products`) URL instead of absolute URL (`http://localhost:3000/products`) in service file.
  eg:- divert all calls for `http://localhost:4200/products` to a server running on `http://localhost:3000/products`
- Create a file 'proxy.conf.json' in your project's src/ folder
  NOTE : if you edit the 'proxy configuration file', you must relaunch the `ng serve` process to make your changes effective.
  {
    "/products": {
      "target": "http://localhost:3000",
      "secure": false
    }
  }
- In 'angular.json', add the "proxyConfig" option to the "serve" target
  "architect": {
    "serve": {
      "builder": "@angular-devkit/build-angular:dev-server",
      "options": {
        "browserTarget": "your-application-name:build",
        "proxyConfig": "src/proxy.conf.json"
      },



Redux
============
A state management library.
REFER : env_setup_REDUX.txt  --->  R (react) repo of kapoor-rakshit.


ngrx   (angular + Redux + RxJs)
=================================
                           -----> ACTION
                           |        |                         <----> REDUCER 1
                           |      STORE <------> ROOT REDUCER <----> REDUCER 2
                           |        |                         <----> REDUCER 3
                           |     SELECTOR
                           |        |
                           <----- VIEW
                           
It uses an additional SELECTOR block in it's architetcure as compared to REDUX. It is somehow similar to `store.subscribe()` in REDUX.
Here STORE sends all data to SELECTOR which then act as a pipe/filter for sending data to respective components ie Angular way.
STEPS
--------
- For debugging purpose, install chrome extension - 'Redux Dev Tools' , used from tab that appears in developer mode.
- Install ngrx store
> npm install --save @ngrx/store
> npm install --save @ngrx/store-devtools        // 'Redux Dev Tools' web extension work in sync from code using this library

- IMPORTANT NOTE : Create new module other than root module 'app.module.TS'    i.e.    `ng generate module <FEATURE_MODULE>`
                   To have different STATE for each module , say eg: PRODUCTS_MODULE, ORDERS_MODULE, CUSTOMERS_MODULE, EMPLOYEES_MODULE
                   LAZY LOADING with NGRX can also be achieved , it requires a different approach than this. REFER : official documentation :)

- In 'app.module.TS' , CREATE and INITIALIZE STORE
  import { StoreModule } from '@ngrx/store';
  import { StoreDevtoolsModule } from '@ngrx/store-devtools';   // plus declare these in imports[] array 
         imports: [ StoreModule.forRoot({}),                    // create STORE, forRoot({}) required in root module ie 'app.module.ts'
                    StoreDevtoolsModule.instrument({
                       name: '<APPNAME_FOR_DEV_DEBUGGING_BROWSER>',
                       maxAge: <MAX_NUMBER_OF_STATES_RECORDED_DEV_TOOL_FOR_UNDOING_REDOING>
                     })
                  ]
                  
- In '<FEATURE_MODULE>.module.TS' , CREATE and INITIALIZE STORE
  import { StoreModule } from '@ngrx/store';                     
  import { <NAME_OF_REDUCER> } from '<path>'                     // plus declare these in imports[] array
         imports: [
                    StoreModule.forFeature('<NAME_OF_STATE_VAR>', <NAME_OF_REDUCER_VAR>)
                  ]
                  
- Create a DIR named as state (a good convention) which will have following REDUCER and ACTION files:
  // 1. <FEATURE>.reducer.ts
  import { createFeatureSelector, createSelector } from '@ngrx/store';
  export interface <FEATURE_STATE_INTERFACE> {
                                                 INTERFACEdata1: string;
                                                 INTERFACEdata2: <INTERFACE>[];
                                             }
  const <initialStateVAR>: <FEATURE_STATE_INTERFACE> = { 
                                                          INTERFACEdata1: '', 
                                                          INTERFACEdata2: [{id:1, name: ''}, {id:2, name: ''}] 
                                                       };
                                                       
  const <getFeatureState> = createFeatureSelector< <FEATURE_STATE_INTERFACE> >('<NAME_OF_STATE_VAR>');   // entire STATE , <NAME_OF_STATE_VAR> same as defined in 'module.ts'
  export const <TOGGLE_SELECTOR> = createSelector(
      <getFeatureState>,                                             // create a sub selector from entire STATE
      state => state.INTERFACEdata1
  );
  export const <GET_EMPLOYEES_SELECTOR> = createSelector(            // create a sub selector from entire STATE
      <getFeatureState>,
      state => state.INTERFACEdata2
  );
  
  export const <NAME_OF_REDUCER_VAR> = (stateDATA:<FEATURE_STATE_INTERFACE>=<initialStateVAR>, actionDATA: <NAME_OF_ACTIONS_VAR>): <FEATURE_STATE_INTERFACE> => {
   switch (actionDATA.type) {
    case <ENUM_FROM_ACTIONS>.<KEY>:            // TOGGLE ACTION
      return {
        ...stateDATA,                           // IMPORTANT NOTE : (...) spread operator for {} will create a copy of it
        INTERFACEdata1: actionDATA.<payload>    // after a copy , the key(s) (<INTERFACEdata1>) written will be overwritten with new data (<actionDATA.<key>) specified
    };
    case <ENUM_FROM_ACTIONS>.<KEY>:            // ADD ACTION
      return {
        ...stateDATA,
        INTERFACEdata2: [
          ...stateDATA.INTERFACEdata2,         // However (...) spread operator for [] , spreads array values
          actionDATA.<payload>,
        ]
     };
     case <ENUM_FROM_ACTIONS>.<KEY>:           // DELETE ACTION
       return {
         ...stateDATA,
         INTERFACEdata2: stateDATA.INTERFACEdata2.filter((tpVAR) => tpVAR.<key> !== actionDATA.<payload>)
     };
     default:
       return stateDATA;
    }
  }
  
  // 2. <FEATURE>.action.ts
  import { Action } from '@ngrx/store';
  export enum <ENUM_FROM_ACTIONS> {
    <KEY> = '<VALUE_TOGGLE>',
    <KEY> = '<VALUE_ADD>',
    <KEY> = '<VALUE_DELETE>'
  }
  export class <TOGGLE_FUNC> implements Action {              // implement ACTION
    readonly type = <ENUM_FROM_ACTIONS>.<KEY>;                // readonly type of ACTION
    constructor(public <payload>: boolean) { 
        console.log("ACTION => ShowCompanyName");
    }
  }
  export class <ADD_FUNC> implements Action {
    readonly type = <ENUM_FROM_ACTIONS>.<KEY>;
    constructor(public <payload>: Employee) { 
        console.log("ACTION => Add");
    }
  }
  export class <DELETE_FUNC> implements Action {
    readonly type = <ENUM_FROM_ACTIONS>.<KEY>;
    constructor(public <payload>: string) { 
        console.log("ACTION => Delete");
    }
  }
  export type <NAME_OF_ACTIONS_VAR> = <TOGGLE_FUNC> | <ADD_FUNC> | <DELETE_FUNC>;        // export action types to be used for dispatch
  
- In 'ADD-component.ts' , DISPATCH ACTION
  import { Store } from '@ngrx/store';
  import * as <featureMethods> from '<FEATURE>.reducer.ts';
  import * as <featureActions> from '<FEATURE>.action.ts';
  constructor(private store: Store< <featureMethods>.<FEATURE_STATE_INTERFACE> >) { }
  onSubmit(formValue: any){
    let newEmployee = {
      id: 2
      name: formValue.name,
      location: formValue.location,
    };
    this.store.dispatch(new <featureActions>.<ADD_FUNC>(newEmployee));
  }
  
- In 'DISPLAY-component.ts' , SUBSCRIBE TO ACTION in ngOnInit() from corresponding MODULE only using SELECTOR
  import { Store, select } from '@ngrx/store';
  import * as <featureMethods> from '<FEATURE>.reducer.ts';
  constructor(private store: Store< <featureMethods>.<FEATURE_STATE_INTERFACE> >) { }
  ngOnInit() {
    this.store.pipe(select(<featureMethods>.<TOGGLE_SELECTOR>)).subscribe(
      (toggleVAR: boolean) => { this.VAR = toggleVAR; },
      (err: any) => { console.log(`${err}`); }
    );
    this.store.pipe(select(<featureMethods>.<GET_EMPLOYEES_SELECTOR>)).subscribe(
      (ARRVAR: Employee[]) => { this.VARARR = ARRVAR; },
      (err: any) => { console.log(`${err}`); }
    );
  }
  


ngrx-effects
=================================
This is used with ngRx for connecting to asynchronous backend services ie http GET, POST, PUT, DELETE, PATCH  ... etc

                              -----> ACTION <-----> EFFECTS <----> SERVICE <----> SERVER
                              |        |
                              |      STORE  <-----> ROOT REDUCER <----> REDUCER 1
                              |        |                         <----> REDUCER 2
                              |     SELECTOR
                              |         |
                              <----- VIEW
              
IMPORTANT NOTE : ALL ACTIONS WILL GO TO ALL EFFECTS and ALL REDUCERS also.
                 Effects accept action , perform activity (contact service/server to get data) , dispatch a new action (SUCCESS/ERROR)
STEPS
-----------
- INSTALL ngrx-effects
> npm install --save @ngrx/effects

- In 'DISPLAY-component.ts' , DISPATCH ACTION to EFFECTS in ngOnInit() , although this will go to all REDUCERS as well
  import { Store, select } from '@ngrx/store';
  import * as <featureMethods> from '<FEATURE>.reducer';
  import * as <featureActions> from '<FEATURE>.action';
  import { Observable } from 'rxjs';
  import { takeWhile } from 'rxjs/operators';
                          // any subscribe must be unsubsribed (manually or automatic) on component's destroy , to prevent memory leaks
                          // Angular automatically subscribes and unsubscribes if `async` pipe used in 'DISPLAY-component.html'
                          // avoiding .subscribe() to be written in .ts , `$` is a convention to make it an Observable variable 
  errMsgVAR$: Observable<string>;
  displayCompanyNameVAR$: Observable<boolean>;
  employeesVAR$: Observable<Employee[]>;
  constructor(private store: Store< <featureMethods>.<FEATURE_STATE_INTERFACE> >) { }
  ngOnInit() {
     this.errMsgVAR$ = this.store.pipe(select(<featureMethods>.<METHOD>));
     this.store.dispatch(new <featureActions>.<ACTION>());                              // NOTE : ACTION() to get data from service
     this.displayCompanyNameVAR$ = this.store.pipe(select(<featureMethods>.<METHOD>));
     this.employeesVAR$ = this.store.pipe(select(<featureMethods>.<METHOD>));
  }
  
- In 'DISPLAY-component.html'
  // 1
  <tr *ngFor='let employee of employees$ | async'></tr>                     // `async` pipe will extract value from Observable variable
  <div *ngIf="displayCompanyName$ | async"></div>
  // 2
  <div *ngIf="errMsg$ | async as errorMessageVAR" class="alert alert-danger">     // use of `as` with `async`, check not null, extract in VAR
    Error: {{ errorMessageVAR }}
  </div>
  
IMPORTANT NOTE : ACTIONS are declared in <FEATURE>.actions.ts
                 ANY ACTION will go to all EFFECTS and all REDUCERS also.
                 ACTIONS like ADD , LOAD , DELETE  etc... will be defined in <FEATURE>.effects.ts
                 ACTIONS like ADD_SUCCESS|ADD_ERROR , LOAD_SUCCESS|LOAD_ERROR , DELETE_SUCCESS|DELETE_ERROR etc... will be defined in <FEATURE>.reducer.ts
                 
- In '<FEATURE>.effects.ts'
  import { Actions, Effect, ofType } from '@ngrx/effects';
  import { mergeMap, map, catchError, tap } from 'rxjs/operators';
  import { of } from 'rxjs';
  import * as <featureActions> from '<FEATURE>.action';
  @Injectable()                                                                                // use of @Injectable()
  export class <FEATURE_EFFECTS> {
    constructor(private actions$: Actions, private employesService: <NAME_OF_SERVICE>) { }     // use actions$: Actions
    @Effect()                                                                                  // use of @Effect()
    loadEmployees$ = this.actions$.pipe(
        ofType(<featureActions>.<ENUM_FROM_ACTIONS>.<KEY>),                                // ofType pipe - similar to switch/case
        tap(val => console.log(`*** LOAD EFFECT ***`)),                                    // tap()  pipe - to log value from prev pipe
        mergeMap((action: <featureActions>.<ACTION>) => this.employesService.getEmployees().pipe(    // mergeMap - used for merging multiple action requests
            map((employees: Employee[]) => (new <featureActions>.<ACTION_SUCCESS>(employees))),      // dispatch new action
            catchError(err => of(new <featureActions>.<ACTION_ERROR>(err)))                          // of() - converts to observable sequence
        ))
    )
    @Effect()
    addEmployees$ = this.actions$.pipe(
        ofType(<featureActions>.<ENUM_FROM_ACTIONS>.<KEY>),
        tap(val => console.log(`*** ADD EFFECT ***`)),
        map((action: <featureActions>.<ACTION>) => { return action.payload }),
        mergeMap((employee:Employee) => this.employesService.addEmployee(employee).pipe(
            map((employee: Employee) => (new <featureActions>.<ACTION_SUCCESS>(employee))),
            catchError(err => of(new <featureActions>.<ACTION_ERROR>(err)))
        ))
    )
    @Effect()
    deleteEmployees$ = this.actions$.pipe(
        ofType(<featureActions>.<ENUM_FROM_ACTIONS>.<KEY>),
        tap(val => console.log(`*** DELETE EFFECT ***`)),
        map((action: <featureActions>.<ACTION>) => { return action.payload }),
        mergeMap((id:string) => this.employesService.deleteEmployee(id).pipe(
            map(() => (new <featureActions>.<ACTION_SUCCESS>(id))),
            catchError(err => of(new <featureActions>.<ACTION_ERROR>(err)))
        ))
    )
  }
  
- In '<FEATURE>.module.ts'
  import { StoreModule } from '@ngrx/store';
  import { EffectsModule } from '@ngrx/effects';
  import { <FEATURE_EFFECTS> } from '<FEATURE>.effects';
  import { <FEATURE_REDUCER> } from '<FEATURE>.reducer';
  @NgModule({
     imports: [
                 StoreModule.forFeature('<NAME_OF_STATE_VAR>', <FEATURE_REDUCER>),
                 EffectsModule.forFeature([FEATURE_EFFECTS])
              ]
  })
  
- In 'app.module.ts'
  import { StoreModule } from '@ngrx/store';
  import { StoreDevtoolsModule } from '@ngrx/store-devtools';
  import { EffectsModule } from '@ngrx/effects';
  @NgModule({
      imports: [
                  StoreModule.forRoot({}),
                  StoreDevtoolsModule.instrument({
                      name: 'Employees App Devtools',
                      maxAge: 20
                  }),
                  EffectsModule.forRoot([])
               ]
  })


TESTING (TDD / BDD)
========================
TDD (TEST DRIVEN DEVELOPMENT)
 - Test cases are to be written first , then code underlying those test cases.
 - TDD focuses on HOW the functionality is implemented / tested.
 - Test cases are written in a programming language.
 - Collaboration is required only between the developers.
 - Might be a better approach for projects which involve API and third-party tools.
 - Tools which support TDD are JUnit, TestNG, NUnit, Karma/Jasmine etc.
 
BDD (BEHAVIOR DRIVEN DEVELOPMENT)
 - BDD is an extension to TDD where instead of writing the test cases, we start by writing a behavior (scenario).
   Later, we develop the code which is required for our application to perform the behavior of evolving app.
 - BDD focuses on the behavior of an application for the end user / WHAT to test.
 - Scenarios are more readable when compared to TDD as they are written in simple English format.
 - Collaboration is required between all the stakeholders.
 - Might be a better approach for projects which are driven by user actions. For eg: e-commerce website, application system, etc.
 - Tools which support BDD are SpecFlow, Cucumber, MSpec, Selenium etc.
 - BDD tools use GHERKIN language to write files that contain FEATURES --> SCENARIOS --> STEPS (pre-condition | action | post-condition)
   eg: Feature: "register new user"
       Scenario: "sign-up form"
        Given:
        When:
        Then:
       Scenario: "credit card info"
        Given:
        When:
        Then:
 - Selenium comes with variants of:
                          REFER : https://www.selenium.dev/
   - SELENIUM IDE       : has a GUI | browser support : FIREFOX, CHROME | language support : JS
   - SELENIUM RC        : (REMOTE CONTROL) requires RC server between AUT and Tool | browser support : any | language support : any
   - SELENIUM WebDriver : no RC server required | browser support : any | language support : any
   - SELENIUM GRID      : used for parallel testing (testing app on multiple browsers simultaneouly)
   
   
Angular TDD
================
- Jasmine (Test Framework) , similar to javac which converts .java to .class
- Karma   (Test Runner)    , similar to java  which runs .class files

- comp.spec.ts file (SPECIFICATION file) is used for writing TEST SUITE which contains TEST CASES.
- test cases can involve:
  - COMPONENT CLASS testing    (variable/function of component)
  - COMPONENT DOM testing      (html of component)
  - COMPONENT SERVICE testing  (services used in component)
- To run angular tests
  > ng test --code-coverage            (MULTI-REPO)    // test: runs all .spec.ts in app | --code-coverage: generates report ( root/coverage dir)
  > ng test <appName> --code-coverage  (MONO-REPO)
- commonly used methods:
  - TestBed()              : similar to app.module which will import the component
  - describe()             : define a test suite
  - it()                   : define a test case
  - expect()               : call to variable/function/queryselector to be tested
  - toBeTruthy()           : check for exist/present
  - toBeFalsy()            : check for not exist/present
  - toContain()            : check for contains substring
  - toEqual(arg1, arg2)    : check for equals exact match
  - toBe(arg1, arg2)       : arg1 is expected result, arg2 is a description of test if pass
  - beforeAll()            : called once at start of TEST SUITE (`describe`)
  - beforeEach()           : called before every TEST CASE (`it`)
  - afterEach()            : called after every TEST CASE (`it`)
  - afterAll()             : called once at end of TEST SUITE (`describe`)
  - xit()                  : prevents test case (`it`) from running , prepended with `x`
- In .component.spec.ts
  import { TestBed, async } from '@angular/core/testing';
  import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
  import { HttpClient, HttpResponse } from '@angular/common/http';
  import { By } from '@angular/platform-browser';
  import { DebugElement } from '@angular/core';
  import { BehaviorSubject } from 'rxjs';
  class MockEmployeesService {
    employees: BehaviorSubject<Employee[]> = new BehaviorSubject<Employee[]>([      // BehaviorSubject : create a subscribable object
      {
        "name": "Emp1",
        "location": "Loc1"
      },
      {
        "name": "Emp2",
        "location": "Loc2"
      }
    ]);
    getEmployees(): BehaviorSubject<Employee[]> {                            // name of methods must be same as in actual service class
      return this.employees;
    }
    addEmployee(employee: Employee) {
      let tempEmployees = this.employees.getValue();
      tempEmployees.push(employee);
      this.employees.next(tempEmployees);                                   // .next() : subscribers will get new value <tempEmployees>
    }
  }
  
  describe('AppComponent', () => {                                         // TEST SUITE
    beforeEach(async(() => {
      TestBed.configureTestingModule({
        declarations: [
          AppComponent
        ],
      }).compileComponents();
    }));
    
    it('should create the app', () => {
      const fixture = TestBed.createComponent(AppComponent);
      const app = fixture.componentInstance;
      expect(app).toBeTruthy();
    });
    
    // Component CLASS testing
    describe('Component Class', () => {                                    // TEST SUITE inside another test suite
      let component: AddemployeeFormComponent;
      let fixture: ComponentFixture<AddemployeeFormComponent>;
      let employeesService: EmployeesService;
    
      beforeEach(async(() => {
        TestBed.configureTestingModule({
          imports:      [ FormsModule, RouterTestingModule ],
          declarations: [ AddemployeeFormComponent ],
          providers:    [ {provide: EmployeesService, useClass: MockEmployeesService } ]
        }).compileComponents();
        employeesService = TestBed.inject(EmployeesService);
      }));

      beforeEach(() => {
        fixture = TestBed.createComponent(AddemployeeFormComponent);
        comp = fixture.componentInstance;
        fixture.detectChanges();
        const deElem: DebugElement = fixture.debugElement;
      });

      it('should not have employees list after construction', () => {
        expect(comp.<employeesARR_VAR>).toBeFalsy();
      });

      it('should have employees list after Angular calls ngOnInit', () => {
        comp.ngOnInit();
        expect(comp.<employeesARR_VAR>.length).toEqual(2);
      });

      it('should toggle company name display on checkbox event', () => {
        expect(comp.<displayCompanyNameVAR>).toBe(true, 'display company name at first');
        comp.<handleCheckEventFUNC>(false);
        expect(comp.<displayCompanyNameVAR>).toBe(false, 'do not display company name');
        comp.<handleCheckEventFUNC>(true);
        expect(comp.<displayCompanyNameVAR>).toBe(true, 'display company name again');
      })
    });
  
      // Component DOM testing
      describe('Component DOM', () => {                                             // TEST SUITE inside another test suite
        let component: EmployeesComponent;
        let fixture: ComponentFixture<EmployeesComponent>;
        let employeesService: EmployeesService;

        beforeEach(async(() => {
          TestBed.configureTestingModule({
            imports: [ FormsModule, RouterTestingModule ],
            declarations: [ EmployeesComponent ],
            providers: [ { provide: EmployeesService, useClass: MockEmployeesService } ]
          }).compileComponents();
          employeesService = TestBed.inject(EmployeesService);
        }));

        beforeEach(() => {
          fixture = TestBed.createComponent(EmployeesComponent);
          component = fixture.componentInstance;
          fixture.detectChanges();
          const deElem: DebugElement = fixture.debugElement;
        });

        it(`check for contents of h1 tag`, () => {
          const debugElem = deElem.query(By.css('h1'));                           // .query() : returns DebugElement , first occurrence of selector
          const htmlElem: HTMLElement = debugElem.nativeElement;                  // .nativeElement : property of DebugElement
          expect(htmlElem.textContent).toEqual('Angular TDD Demonstration');
        });

        it(`should render a table heading Location`, () => {
          const debugElem = deElem.queryAll(By.css('th'))[0];                        // .queryAll() : returns DebugElement[] , all occurrence of selector
          const htmlElem: HTMLElement = debugElem.nativeElement;
          expect(htmlElem.textContent).toEqual('Location');
        });

        it(`should render 2 rows of data`, () => {
          const debugElem = deElem.query(By.css('tbody')).queryAll(By.css('tr'));    // .query() plus .queryAll()
          expect(debugElem.length).toEqual(2);
        });

        it(`should render first name as Emp1`, () => {
          const debugElem = deElem.query(By.css('tbody')).queryAll(By.css('tr'))[0].nativeElement.queryAll(By.css('td'))[0].nativeElement;
          expect(debugElem.textContent).toEqual('Emp1');
        })
      });
      
      // Component SERVICE testing                                         // TEST SUITE inside another test suite
      describe('EmployeesService', () => {
        let httpClient: HttpClient;
        let httpTestingController: HttpTestingController;
        let empService: EmployeesService;

        beforeEach(() => {
          TestBed.configureTestingModule({
            imports: [ HttpClientTestingModule ],
            providers: [EmployeesService]
          });
          httpClient = TestBed.get(HttpClient);
          httpTestingController = TestBed.get(HttpTestingController);
          empService = TestBed.get(EmployeesService);
        });

        afterEach(() => {
          // After every test, assert that there are no more pending requests.
          httpTestingController.verify();
        })
        
        describe('getEmployees', () => {                                                     // TEST SUITE for GET req
          let expectedEmployees: Employee[];

          beforeEach(() => {
            expectedEmployees = [
              { id: 1, name: 'Emp-1', location: 'Loc-1' },
              { id: 2, name: 'Emp-2', location: 'Loc-2' }
            ] as Employee[];
          });

          it('should return expected employees (called once)', () => {
            empService.getEmployees().subscribe(
              (employees) => { expect(employees).toEqual(expectedEmployees, 'should return expected employees') }, fail);

            // EmployeesService should have made one request to GET employees from expected URL
            // .expectOne() : Expect that a single request has been made which matches the given URL, and return its mock.
            const req = httpTestingController.expectOne(empService.employeesUrl);
            expect(req.request.method).toEqual('GET');

            // Respond with the mock employees
            req.flush(expectedEmployees);
          });
        });

        describe('addEmployee', () => {                                                      // TEST SUITE for POST
          let expectedAddEmployee: Employee;
          expectedAddEmployee = { id: 1, name: 'Emp-1', location: 'Loc-1' };

          it('should add an employee and return with id inserted ', () => {
            const employeeToAdd: Employee = { name: 'Emp-1', location: 'Loc-1' };
            empService.addEmployee(employeeToAdd).subscribe(
              data => expect(data).toEqual(expectedAddEmployee, 'should return the employee with id inserted'), fail);

            // EmployeesService should have made one request to POST employee
            // .expectOne() : Expect that a single request has been made which matches the given URL, and return its mock.
            const req = httpTestingController.expectOne(empService.employeesUrl);
            expect(req.request.method).toEqual('POST');
            expect(req.request.body).toEqual(employeeToAdd);

            // Expect server to return the employee after POST
            const expectedResponse = new HttpResponse({ status: 200, statusText: 'OK', body: employeeToAdd });
            req.event(expectedResponse);
          });
        });
      });
    });
  

