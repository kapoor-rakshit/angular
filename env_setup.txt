
MEAN stack
MongoDB , Express , Angular , Node

MERN stack
MongoDB , Express , React , Node



FRONTEND CLIENT side FRAMEWORK(s) which use HTML, JS, TS, Dart for building application(s)
Angular , React

BACKEND SERVER(s)
NodeJs , ExpressJs , ASP.NET , J2EE



Traditional Web Application  |  Single Page Application
                             -  Initial load (JS, CSS, HTML) on index.html (Single Page)
                             -  Initally slow on index.html but subsequent requests are faster
                             -  Client - Browser loads/remove/modify DOM coz they have ANGULAR/REACT libs
Check reference screenshots too.



Angular Versioning
AngularJs   --->   Angular 1.x
Angular     --->   Angular 2 onwards
Angular uses SEMVER (SEMANTIC VERSIONING) ie adding meaning to VERSION.
eg: 2.5.8
    2 --> Major Version   (Breaking Change , ie there is need to modify existing code , eg: AngularJS to Angular)
    5 --> New Feature     (not breaking)
    8 --> Patch, bugfixes (not breaking)

Angular 3 does not exist
Reason : angular/router module in core library of Angular v3.x.x was already present and ahead of v2.x.x. 
So to avoid cofusion it was dropped and moved to v4.

Every six months , one major release is made to Angular Version.



METADATA
Consists of decorators which will make normal functions act as ANGULAR.
It tells Angular how that method should be processed. Eg: @Component, @Injectable, @NgModule



Transpiler is used to convert TS to JS.
This is done either by browser or before providng production build to browser for faster response.



NPM is a NODE PACKAGE MANAGER which gets installed with nodeJS   just  as  MAVEN, ANT, GRADLE  etc...



SETUP
------
Refer  SetupInstructions.docx  document



node.js terminal is a CMD terminal with NODEJs and NPM path variables set for user automatically.



ng serve [options]
Reference : https://github.com/angular/angular-cli/wiki/serve

--port portval     :  Port to listen on
--host hostval     :  Host to listen on
--open (alias: -o) : Opens the url in default browser
--progress         : Log progress to the console while building.
--optimization     : Enables optimization of the build output.   ..... etc.. more on above link

"npm start"   command will work same as   "ng serve"    command.
because the "start" key of package.json is having value "ng serve -o".



These commands will look for  "package.json"  file  which contain dependencies  and then load   "index.html"   file
index.html     loads   main.ts   loads   app.module.ts   .... so on as below

index.html                --   defines the tag to be filled by BOOTSTRAPED ANGULAR component as defined in main.ts
                               eg:- <app-root> DEFAULT text to be diplayed if ANGULAR component not found </app-root>

main.ts                   --   defines AppModule (app.module file) in the bootstrapModule() 

app.module.ts             --   defines @NgModule
                               --   defines AppComponent (app.component file) ie register all components/modules here
                               --   new components are declared in "declarations" and "imported" , 
                                    provided they are EXPORTED in their respective ".component.ts" file
NOTE : For a NEW COMPONENT
mkdir component_dir under app dir (default) component  OR  give path to COMPONENT_NAME
      mk    comp.component.ts     file
      mk    comp.component.html   file
      manually declare new component in app.module.ts "declarations"
      ------OR------
      > ng generate component DIR/COMPONENT_NAME/            // this will create a COMPONENT_NAME dir under DIR dir with required files .html, .ts, .css
      > ng g c DIR/COMPONENT_NAME/
      automatically updates app.module.ts declare new component in "declarations"

app.component.ts          --   defines @Component
                               --   defines the name of selector tag to insert ANGULAR component in any .html
                                    NOTE : This <selector_name></> tag must be written in .html file of that COMPONENT in whose MODULE.ts it is REGISTERED
                               --   defines TEMPLATE file to be displayed to BROWSER
                               --   defines css file
                          --   This class must be EXPORTED for ".module.ts" file to be able to IMPORT and REGISTER it
                          --   defines variables of class AppComponent to be supplied to its respective TEMPLATE file (.html)

                                -- Done using INTERPOLATION ie using  {{ var }} in .HTML values are supplied dynamically
                                                                      {{'Title : '  + var}}          // hardcoded_str + var
                                                                      {{'Title : '  + funccall()}}   //               + function_call()
                                                                      {{mathematical_expressions}}   // eg:- 2*5+6
                                                                      src={{ var }}                  // attribute values

                                --   NOTE : INTERPOLATION is only for STRINGs , for integer , boolean..use 
                                     PROPERTY BINDING                 [disabled] = 'var'                       // NOTE : use of [] for attrib and ' ' for vals

                                --   EVENT BINDING                    (click)    = 'funccall()'                // NOTE : use of () for event  and ' ' for func
                                                                      (input)    = 'func($event.target.value)' //        send data from DOM to component
                                --   TWO-WAY DATA BINDING
                                     NOTE : Import FormsModule in "app.module.ts"    and   include  in  "imports" for two-way
                                     -- No processing..               [(ngModel)]     = "var"                 // set value attribute's val of tag as var from DOM to COMPONENT and vice versa
                                     -- Processing..                  (ngModelChange) = "func($event)"        // pass value to component , later used by [ngModel]
                                                                      [ngModel]       = "var"                 // pass to DOM after processing

app.component.html        --   displayed to BROWSER
                      
                          --   BUILTin PIPES    
                              ----------------  eg:- {{ var | uppercase }} , {{ var | lowercase }} 
                                                     {{ var | titleCase }}
                                                     {{ var | date : "MM/dd/yy" }}
                                                     {{ var | currency : 'EUR' : true }}
                          --   CUSTOM PIPES
                              ----------------
NOTE : For creating NEW PIPE
      manually
      ----- OR -----
    > ng generate pipe PIPENAME
                               -- CREATE a "PIPENAME.pipe.ts" under it's component dir , use @Pipe and implement PipeTransform with pipeClass , export this class
                               -- pipeClass implements PipeTransform interface's transform method that accepts input value followed by optional parameters and returns transformed value.
                               -- multiple args can be passed to transform function using (colon) '' : '' : ''
                               -- Import and include it in  "declarations"  of  "app.module.ts"
                               -- Use    [(ngModel)] = "filtervar"    in   <input>  tag.
                               -- Use in TEMPLATE .html with directives using pipe_symbol (|) PIPENAME : filtervar



ngDIRECTIVES
Written in html files
*ngIf is used for if logic while rendering HTML and *ngFor is used for loops in HTML rendering
These are Structural directives and should be prefixed with *
Reference : https://angular.io/guide/structural-directives

1. *ngIf                         // *ngIf="isValid; else other_content;"      <ng-template #other_content>isValid is false</ng-template>
                                 // *ngIf="num>10;then greater else smaller;" <ng-template #greater>num Greater 10</ng-template>
                                 //                                           <ng-template #smaller>num Smaller 10</ng-template>
                                 // *ngIf="time$ | async as current_time; else loadingIdNgTemplate;" 
2. *ngFor
3. [ngSwitch]    ,    *ngSwitchCase



Angular Animations
From Angular 4 , animations are part of separate animations library and not part of angular core library as it was earlier.
inside app.module.ts             import BrowserAnimationsModule and write it in imports[] array
inside component's .ts file      animations: [] ,this contains animationName and it's properties, just like template and css properties given.
                                 stateVar: string = "small";                            // this variable change will trigger animation
                                 animateFunc(){
                                    this.stateVar=(this.stateVar=="small"?"large":"small");
                                 }
inside component's .html file    <p [@animationName]="stateVar" (click)="animateFunc()">some random text</p>



Angular Forms
- These forms should support Two way data binding.
- Keep track of form state, current state is valid or not, display validation errors, enable/disable form based on validation criteria.
1. Template driven forms
   - import FormsModules from "@angular/forms" to app.module.ts imports[] array
   - create .ts class and .html template for it.
   - use of directives ngModel, ngForm, ngModelGroup, ngSubmit.
   - validations are part of template (.html)
2. Model driven forms (Reactive forms)
   - import ReactiveFormsModule from "@angular/forms" to app.module.ts imports[] array
   - create and initialize Form Control Objects in .ts class which are intermediate objects that hold state of form using FormGroup, FormControl, Validators, FormBuilder (formbuilder prevents use of formcontrol)
   - bind these objects to form control elements in .html template using [formGroup]="" property, formGroupName="" directive, formControlName="" directive
   - validations logic are part of class (.ts) however rules (.invalid && .touched) are defined inside template (.html)



STYLE
-- A global file "styles.css" exists for entire application.
   eg:-  write   @import "https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css"

-- To force the app component's "app.component.css" effects to its child components also use
  /deep/   h1{  color:red;  }      OR
  >>>      h1{  color:red;  }

-- For component specific style use  ".component.ts"  file
   @Component
           styleUrls:['firstcss', 'secondcss', 'thirdcss']

-- CLASS BINDING
   Binding a CSS class to events    eg:- [class.CLASS_NAME_CSS] = ' TRUE/FALSE '



PASSING VARIABLES/VALUES
-- OUTER COMPONENT to INNER COMPONENT
   <new-component-selector-tag  [varName] = "valuevar" > ... </new-component-selector-tag>

   [varName] defined in "new-component-component.ts" file   with   @Input() varName;
           NOTE : varName defined with @Input must be same spell as of in <new-component-selector-tag  [varName]=''> ... </new-component-selector-tag>

   'valuevar' comes from  ".component.ts"  file of component where <new-component-selector-tag> ... </new-component-selector-tag> is defined

-- INNER COMPONENT to OUTER COMPONENT
   in INNER "new-component-component.ts"  import {Output , Eventemitter}
   @Output() outputvarName: EventEmitter<string> = new EventEmitter<string>();

               in event_function
                    clickfunc(valclicked)
                 {
                    this.outputvarName.emit(valclicked.name);
                 }

   in OUTER COMPONENT  (.html)
   <new-component-selector-tag  (outputvarName) = "funcalledName($event)"></>
   {{VARNAME}}

                       (.component.ts)
   funccalledName(varval){
      this.VARNAME = varval;
   }



LIFECYCLE methods
------------------
After creating a component/directive by calling its constructor,
Angular calls the lifecycle hook methods in the following sequence at specific moments

constructor() {  }
The constructor method is not actually an Angular 2 method. 
It is a predefined method in a TypeScript class which is called when the class is instantiated. 
The constructor’s purpose is to help prepare the creation of a new instance of the class.
In the context of Angular 2 it can be used to properly initialize fields.
Angular 2’s DI (dependency injection) also tries to find providers that match the types of the constructor’s parameters, resolves them, and passes them to the constructor as arguments.

ngOnChanges()	 {  }
Respond when Angular (re)sets data-bound input properties.
The method receives a SimpleChanges object of current and previous property values.
Called before ngOnInit() and whenever one or more data-bound input properties change.

ngOnInit()    {  }
Called once, after the first ngOnChanges().
meaning that all of the injected dependencies will be resolved and all of the class members will be defined.
This makes it the perfect place to do any of the initialization work/logic for the component.

ngDoCheck()	
Detect and act upon changes that Angular can't or won't detect on its own.
Called during every change detection run, immediately after ngOnChanges() and ngOnInit().

ngAfterContentInit()	
Respond after Angular projects external content into the component's view / the view that a directive is in.
Called once after the first ngDoCheck().

ngAfterContentChecked()	
Respond after Angular checks the content projected into the directive/component.
Called after the ngAfterContentInit() and every subsequent ngDoCheck().

ngAfterViewInit()	
Respond after Angular initializes the component's views and child views / the view that a directive is in.
Called once after the first ngAfterContentChecked().

ngAfterViewChecked()	
Respond after Angular checks the component's views and child views / the view that a directive is in.
Called after the ngAfterViewInit() and every subsequent ngAfterContentChecked().

ngOnDestroy()	
Cleanup just before Angular destroys the directive/component.
Unsubscribe Observables and detach event handlers to avoid memory leaks.
Called just before Angular destroys the directive/component.

Example:
Written in  ".component.ts"  of  respective COMPONENT
        export class COMPONENTNAME implements OnInit , OnChanges , OnDestroy{  }



SERVICE
--------
Write a     ".service.ts"   file for COMPONENT   and  use   @Injectable()  decorator over   export class ServiceClass{  }

declare in  "providers"  of  "app.module.js"  this  service class

inject in   ".component.ts"  file  of COMPONENT using   constructor()
                       pass values to .html var using   ngOnInit()

COMMUNICATION with SERVICE
---------------------------
NOTE      : MAKE sure to install JSON SERVER   "npm install -g json-server"
Reference :                                    "https://github.com/typicode/json-server"

NOTE : JSON-Server uses default KEYWORD  "id"
Create a .JSON file under dir        "PROJ\src\"

CHANGE DIR to your .JSON file's dir  "PROJ\src\"
Start JSON SERVER                              "json-server -–watch filename.json"

OPEN new TERMINAL window
CHANGE DIR to "PROJ"  as it is where "package.json" is present
Start ng      "ng serve"

declare  "HttpClientModule" in  "imports"  of  "app.module.ts"

configure ".service.ts"

CREATE    "interface.ts"  file and export interface

configure ".component.ts" file



Use of HttpClientModule
------------------------
HTTP request is made in browser using either XMLHttpRequest or fetch().
import {HttpClientModule} from "@angular/common/http" and included in imports[] array.
HttpClientModule provides testability features, typed request and response objects, request and response interception, Observable APIs, Streamlined error handling.
-- PROMISE         (SUCCESS data , ERROR data)
-- OBSERVABLES     (SUCCESS data , ERROR data , DONE)  these are required to be SUBSCRIBED , .subscribe() triggers execution of  OBSERVABLES and causes HttpClient to compose and send request to server.
-- JSON SERVER     (a .json file is to be added in src of PROJECT)

import {HttpHeaders} from "@angular/common/http"
const httpOptions = {
  headers: new HttpHeaders({
    'content-type' : 'application/json',
    'authorization' : 'tokenValue'
  })
}
import 'rxjs' in app.module.ts     // RxJS is a library for reactive programming using Observables, to make it easier to compose asynchronous or callback-based code.



CLIENT SIDE ROUTING
----------------------
Multiple routes... eg: localhost:4200/home/signup/

Create file         "app.routing.ts"   in project's app component root dir , which contains urls/routes
                     NOTE : Do not put '/' in path , ANGULAR will put it automatically

Import and write in "imports"   of     "app.module.ts"   the routing object which was exported from "app.routing.ts"

wherever define    <router-outlet></router-outlet>    routing module urls output shown there

<a href=""> ... </a>  sends request to BROWSER directly , so use routerLink="" to send control to routerModule
Set CSS class to active link using                               routerLinkActive="CSS_Class"
For exact match of urls use                                      [routerLinkActiveoptions]="{exact:true}"
For partial match  ,  eg:- employees/:DYNAMIC_ROUTING , DO NOT use {exact:true}


. DYNAMIC ROUTING
  using   path : "PARENT-URL/:varname" in  "app.routing.ts"  define a new component (DetailsComponent)
  
  config "DetailsComponent.component.ts"
       -- constructor(ActivatedRoute , Location)    // ActivatedRoute : PARENT-URL  ,  Location : From where coming
       -- ngOnInit()                                // Traverse the params of path  ie  /:varname1/:varname2

  In .HTML define " routerLink='{{emp.id}}' " for the link. this value is the just the next value of PARENT-URL
          
  In     "app.module.ts"  declare  "DetailsComponent" in "declarations"
                          import   'rxjs'           // RxJS is a library for reactive programming using Observables, to make it easier to compose asynchronous or callback-based code.



LOCATION STRATEGIES
=====================
REFERENCE   :   https://codecraft.tv/courses/angular/routing/routing-strategies/

we have two strategies we can use to implement client side routing,
one is called the HashLocationStrategy and the other is called the PathLocationStrategy.

The default in Angular is the PathLocationStrategy, if we do nothing that is the strategy Angular will employ.


HashLocationStrategy
---------------------
To enable HashLocationStrategy in an Angular application we pass {useHash: true} when we are providing our routes with RouterModule
eg:-  RouterModule.forRoot(routes, {useHash: true})

URL can contain some data prepended with a # character.

The # part of the url is called the hash fragment.

It’s normally used so that people can link to a particular section in a HTML page, specifically anchor tags,
for example if there is an anchor tag with an name attribute of routing-strategies like so:

<a name="routing-strategies"></a>

Then if you created a bookmark of   http://somedomain.com/page#routing-strategies
Then the browser would open somedomain.com/page and then scroll down so that the <a name="routing-strategies"></a> tag is at the top of the page.

Also anything past the # in a URL never gets sent to the server.
So if your URL was   https://codecraft.tv/contact/#/foo/moo/loo   then the browser makes a GET request to https://codecraft.tv/contact/ only.
The #/foo/moo/loo part of the URL is never sent.

It preserves a state of page and so on RELOADING a page , the UI state is maintained.



