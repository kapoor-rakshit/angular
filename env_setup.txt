
MEAN stack
MongoDB , Express , Angular , Node

MERN stack
MongoDB , Express , React , Node



FRONTEND CLIENT side FRAMEWORK(s) which use HTML, JS, TS, Dart for building application(s)
Angular , React
Angular works on REAL DOM.
React works on VIRTUAL DOM , better performance as compared to Angular.

BACKEND SERVER(s)
NodeJs , ExpressJs , ASP.NET , J2EE



Traditional Web Application  |  Single Page Application
                             -  Initial load (JS, CSS, HTML) on index.html (Single Page)
                             -  Initally slow on index.html but subsequent requests are faster
                             -  Client - Browser loads/remove/modify DOM coz they have ANGULAR/REACT libs
Check reference screenshots too.



Angular Versioning
================================
AngularJs   --->   Angular 1.x
Angular     --->   Angular 2 onwards
Angular uses SEMVER (SEMANTIC VERSIONING) ie adding meaning to VERSION.
eg: 2.5.8
    2 --> Major Version   (Breaking Change , ie there is need to modify existing code , eg: AngularJS to Angular)
    5 --> New Feature     (not breaking)
    8 --> Patch, bugfixes (not breaking)

Angular 3 does not exist
Reason : angular/router module in core library of Angular was at v3.x.x plus ahead of v2.x.x for other modules.
         Now if Angular v3 is released , angular/router module will be at v4.x.x while others will be at v3.x.x
         So to avoid cofusion it was dropped and moved to v4 directly.

Every six months , one major release is made to Angular Version.



METADATA
===============
Tells angular how to process a class ie qualifying a class with the attributes which angular framework can understand.
Consists of decorators. Eg: @Component, @Injectable, @NgModule, @Pipe.
NOTE : a class immediately succeeded by METADATA decorator will only act as ANGULAR specific.


Transpiler is used to convert TS to JS.
This is done either by browser or before providng production build to browser for faster response.


NPM
================
NPM is a NODE PACKAGE MANAGER which gets installed with nodeJS   just  as  MAVEN, ANT, GRADLE  etc...
NPM is used to install a package, and any packages that it depends on.
> npm install
If the package has a 'package-lock' or 'shrinkwrap file', installation of dependencies will be driven by that else from 'package.json'

> npm install --save <PACKAGE_NAME>
Install the dependencies in the local node_modules folder.

> npm install -g --save <PACKAGE_NAME>
(--global), installs the current package context (ie, the current working directory) as a global package in NodeJS's 'node_modules' dir

> npm update --save
npm checks if there exist newer versions in repository that satisfy specified semantic versioning ranges as in package.json and installs them.
but leaves package.json untouched (you can change this by passing --save option).

> npm outdated
> npm install <PACKAGE_NAME>@latest --save
Updating a version that is beyond semantic versioning range requires two parts. 
First, you ask npm to list which packages have newer versions available using `npm outdated`.
Then you ask npm to install the latest (@latest) version or specific version (@4.1.6) of a package.



SETUP
================
Refer  SetupInstructions.docx  document


node.js terminal is a CMD terminal with NODEJs and NPM path variables set for user automatically.


(MULTI-REPO)  :  every new angular project created will have its own node_modules, files (angular.json, package.json), folders.
> ng new <APP_NAME> 
> ng serve
> ng build --prod

(MONO-REPO)   :  only one node_modules and common files which can be shared by all angular applications inside working directory <my-workspace>
> ng new <my-workspace> --create-application=false --defaults
> ng generate application <my-app>
> ng serve <my-app>
> ng build <my-app> --prod  
--create-application : tells the Angular CLI not to generate an initial application.
--defaults           : tells the Angular CLI not to prompt you about routing and CSS preprocessor.
NOTE : application <my-app> and its corresponding <my-app>-e2e application are in the 'projects' folder.
     : ng s <my-app> [options]    or    ng serve <my-app> [options]           will start the application

> ng update
Perform a basic update to the current stable release of the core framework and CLI.
--all=true | flase   ,  Whether to update all packages in package.json. (default=false)

> ng serve [options]
Reference : https://github.com/angular/angular-cli/wiki/serve
--port portval     :  Port to listen on
--host hostval     :  Host to listen on
--open (alias: -o) : Opens the url in default browser
--progress         : Log progress to the console while building.
--optimization     : Enables optimization of the build output.   ..... etc.. more on above link

> ng add <package>                                (MULTI-REPO)
> ng add <package> --project <my-app>             (MONO-REPO)
ng add makes adding new capabilities to your project easy. ng add will use your package manager to download new dependencies and 
invoke an installation script (implemented as a schematic) which can update your project with configuration changes, 
add additional dependencies (e.g. polyfills), or scaffold package-specific initialization code

"npm start"   command will work same as   "ng serve"    command.
because the "start" key of package.json is having value "ng serve -o".



PWA experience to Angular
===============================
Following package will add all necessary code for making an app a PWA, which otherwise had to be done manually.
It will update angular.json, package.json, app.module.ts, index.html plus create assets/ dir for relevant icons.
> ng add @angular/pwa                             (MULTI-REPO)
> ng add @angular/pwa --project <my-app>          (MONO-REPO)




JIT / AOT
===================
- In the beginning, a compiler was responsible for turning a high-level language into object code (machine instructions), 
  which would then be linked into an executable.
  
- just-in-time (JIT) compilation (also dynamic translation or run-time compilations) is a way of executing computer code 
  that involves  compilation during execution of a program — at run time — rather than prior to execution.
  Or stated more simply, it is that the code gets compiled when it is needed, not before runtime.
  
  A just-in-time (JIT) compiler is a feature of the run-time interpreter, that instead of interpreting bytecode every time a method is invoked, 
  will compile the bytecode into the machine code instructions of the running machine, and then invoke this object code instead.
  
  In JIT, not all the code is converted into machine code initially. Only code that is necessary (used immediately) will be converted into machine code. 
  Then if a method or functionality called and is not in machine code, then that will also be turned into machine code. 
  This reduces the burden on the CPU and makes the app render faster because it only uses what is needed.
  
- ahead-of-time compilation (AOT compilation) is the act of compiling a higher-level programming language such as C or C++, or an 
  intermediate representation such as Java bytecode or .NET Framework Common Intermediate Language (CIL) code, 
  into a native (system-dependent) machine code so that the resulting binary file can execute natively.
  
  An ahead-of-time (AOT) compiler converts your code during the build time before the browser downloads and runs that code. 
  Compiling your application during the build process provides a faster rendering in the browser.
  
  Benefits
  Faster rendering, Fewer asynchronous requests, Smaller Angular framework download size, Detect template errors earlier, Better security
  
- JIT compilation is the default when you run the `ng build` or `ng serve` CLI commands. This is for development.
  For AOT compilation, include the `--prod` or `--aot` option with the `ng build` or `ng serve` command, 
  NOTE : this parameter is configured in 'angular.json' with `AOT`.



Structure of Angular Application
==========================================
e2e               : end to end tests
node_modules      : contains node nodules used by angular application (MULTI-REPO) or provides packages to your workspace (MONO-REPO).
src/app           : contains components (.html, .ts, .css, -spec.ts)
src/polyfills     : compatibility for different browsers.
src/styles.css    : define styling classes which can be used by all components in app, like defining global styles.
src/index.html    : the starting point, the page which browser reads and loads when running angular app. (contains <selector></selector> for bootstrap component)
src/main.ts       :	the entry point from a code perpective for your angular app. (contains  platformBrowserDynamic().bootstrapModule(AppModule))
angular.json      : CLI configuration defaults
tsconfig.json     : typescript configuration
package.json      : configures the npm package dependencies ie which libraries will be installed into node_modules plus script rules.
                    ~version : “Approximately equivalent to version”
                    ^version : “Compatible with version”
package-lock.json : a derivative of package.json which has exact library version(s) you are using for this app.
                    `npm install` uses 'package-lock.json' (if available) else 'package.json' to install required dependencies.
                    


commands will look for  "package.json"  file  which contain dependencies  and then load   "index.html"   file
index.html     loads   main.ts   loads   app.module.ts   .... so on as below

index.html                --   defines the tag to be filled by BOOTSTRAPED ANGULAR component as defined in main.ts
                               eg:- <app-root> DEFAULT text to be diplayed if ANGULAR component not found </app-root>

main.ts                   --   defines AppModule (app.module file) in the bootstrapModule() 

app.module.ts             --   defines @NgModule
                               --   defines AppComponent (app.component file) ie register all components/modules here
                               --   new components are declared in "declarations" and "imported" , 
                                    provided they are EXPORTED in their respective ".component.ts" file
NOTE : For a NEW COMPONENT
mkdir component_dir under app dir (default) component  OR  give path to COMPONENT_NAME
      mk    comp.component.ts     file
      mk    comp.component.html   file
      manually declare new component in app.module.ts "declarations"
      ------OR------
      > ng generate component DIR/COMPONENT_NAME/            // this will create a COMPONENT_NAME dir under DIR dir with required files .html, .ts, .css
      > ng g c DIR/COMPONENT_NAME/
      automatically updates app.module.ts declare new component in "declarations"

app.component.ts          --   defines @Component
                               --   defines the name of selector tag to insert ANGULAR component in any .html
                                    NOTE : This <selector_name></> tag must be written in .html file of that COMPONENT in whose MODULE.ts it is REGISTERED
                               --   defines TEMPLATE file to be displayed to BROWSER
                               --   defines css file
                          --   This class must be EXPORTED for ".module.ts" file to be able to IMPORT and REGISTER it
                          --   defines variables of class AppComponent to be supplied to its respective TEMPLATE file (.html)

                                -- Done using INTERPOLATION ie using  {{ var }} in .HTML values are supplied dynamically
                                                                      {{'Title : '  + var}}          // hardcoded_str + var
                                                                      {{'Title : '  + funccall()}}   //               + function_call()
                                                                      {{mathematical_expressions}}   // eg:- 2*5+6
                                                                      src={{ var }}                  // attribute values

                                --   NOTE : INTERPOLATION is only for STRINGs , for integer , boolean..use 
                                     PROPERTY BINDING                 [disabled] = 'var'                       // NOTE : use of [] for attrib and ' ' for vals
                                     CSS_CLASS BINDING                [class.CLASS_NAME_CSS] = "BooleanVAR_EXPRESSION"
                                                                      [ngClass] = "'firstCSSClass secondCSSClass'"                 // NOTE : use of '' over class names
                                                                      [ngClass] = "['firstCSSClass' , 'secondCSSClass']"
                                                                      [ngClass] = "{'firstCSSClass' : i%2==0 , 'secondCSSClass' : i%2==1}"

                                --   EVENT BINDING                    (click)    = 'funccall()'                // NOTE : use of () for event  and ' ' for func
                                                                      (input)    = 'func($event.target.value)' //        send data from DOM to component
                                --   TWO-WAY DATA BINDING
                                     NOTE : Import { FormsModule } in "app.module.ts"    and   include  in  "imports" for two-way
                                     -- No processing..               [(ngModel)]     = "var"                 // set value attribute's val of tag as var from DOM to COMPONENT and vice versa
                                     -- Processing..                  (ngModelChange) = "func($event)"        // pass value to component , later used by [ngModel]
                                                                      [ngModel]       = "var"                 // pass to DOM after processing

app.component.html        --   displayed to BROWSER
     
     
PIPES
==================
                          --   BUILTIN PIPES    
                              ----------------  eg:- {{ var | uppercase }}
                                                     {{ var | lowercase }}
                                                     {{ var | titleCase }}
                                                     {{ var | date : "dd/mm/yyyy" }}               // var = new Date();
                                                     {{ var | date : "shortTime" }}
                                                     {{ var | currency : 'EUR' : true }}           // show euro symbol
                                                     {{ var | currency : 'EUR' : false }}          // donot show euro symbol , shows EUR
                                                     {{ var | json }}                              // converts JS object to JSON {"" : ""}
                                                     {{ var | percent }}                           // var = 00.54534 , output = 55%
                                                     {{ var | slice : <start> : <end> }}           // var = ARRAY , [start_index,end_index)
                                                     {{ var | number : '<minDigitsBeforeDecimal>.<minDigitsAfterDecimal>-<maxDigitsAfterDecimal>' }}
                                                     
                          --   CUSTOM PIPES
                              ----------------
NOTE : For creating NEW PIPE
      manually
      ----- OR -----
    > ng generate pipe PIPENAME
                               -- CREATE a "PIPENAME.pipe.ts" under it's component dir , use @Pipe and implement PipeTransform with pipeClass , export this class
                               -- pipeClass implements PipeTransform interface's transform method that accepts input value followed by parameters and returns transformed value.
                               -- multiple args can be passed to transform function using (colon) '' : '' : ''
                               -- Import and include it in  "declarations"  of  "app.module.ts"
                               -- Use    [(ngModel)] = "filtervar"    in   <input>  tag.
                               -- Use in TEMPLATE .html with directives using pipe_symbol (|) PIPENAME : filtervar
                               -- Example : {{ var | CUSTOM_PIPE : <arg1> : <arg2> | uppercase }}
                               
                           --  PURE / IMPURE PIPES
                              -----------------------
                               -- Pure
                                  - This is DEFAULT pipe , if 'pure' metadata is not specified in @Pipe decorator({})
                                  - BUILTIN pipes are PURE.
                                  - input parameters value determine the output , if input parameters don’t change , output doesn’t change
                                  - can be shared across many usages without affecting the output result
                                  - there’s no internal state , Even though there are two usages in the example template , 
                                    Angular can create only one pipe instance which can be shared between the usages.
                                    
                               -- Impure
                                  - cannot use the input value to determine if the output will change
                                  - cannot be shared because the internal state can be affected from outside
                                  - the same parameters do not guarantee that same output , 
                                    It means that Angular is forced to trigger transform function on a pipe instance on every digest (change detection cycle)
                                    <span>{{v1 | customPipe}}</span>
                                    <span>{{v2 | customPipe}}</span>
                                  - example
                                    @Pipe({
                                      name: 'customPipe', 
                                      pure: true
                                    })
                                    
                                  - example
                                    @Pipe({
                                      name: 'customPipe',
                                      pure: false
                                    })
                                    
                                  -- Async pipe
                                  - It is an example of impure pipe , 
                                    This pipe has internal state that holds an underlying subscription created by subscribing to the observable passed to the pipe as a parameter
                                  - Because of that Angular has to create a new instance for each pipe usage to prevent different observables affecting each other. 
                                    And also has to call transform method on each digest 
                                    because even thought the observable parameter may not change the new value may arrive through this observable that needs to be processed by change detection.
                                  - However async pipe unsubscribes itself from observables on 'ngOnDestroy()'
                                    


ngDIRECTIVES
=====================
Written in html files
Three types of directives:
 1. Custom Attribute Directives
 --------------------------------
 > ng generate directive <directive_name>
 - using a @Directive decorator we can make custom attribute directive which can change appearances such as 
   text color, background color and font size of the body of an HTML element that can be called host element. 
   To change appearance angular provides ElementRef class that can directly access DOM.
 - Benefits of using custom directive
   - When we directly use ElementRef in our application, it is vulnerable to XSS (cross site scripting) attacks.
   - It is better to create a custom directive and use ElementRef inside directive to change appearance or behavior of the host element.
 - Steps
   - Create a class decorated with @Directive.
   - Assign the attribute directive name to the selector metadata of @Directive decorator, enclosed within bracket [], ex: [colorChange]
   - Create constructor of class to get instance of ElementRef by dependency injection, which can access DOM to change host element appearance and behavior
   - Use @Input() decorator to accept user input in our custom directive.
   - Use @HostListener() decorator to listen to events in custom attribute directive.
   - Configure custom attribute directive class (ex: MyDirective) in app.module.ts in the 'declarations' array metadata of @NgModule.
   // example
      @Directive({
         selector: '[colorChangeDirective]'
      })  
      export class MyDirective {
         @Input('colorChangeVAR') dynamicColor: string;
         @Input() defaultValueVAR: string; 
         
         constructor(private elRef: ElementRef) { this.defaultValueVAR = "white"; }
         
         @HostListener('mouseenter') onMouseEnterEventFunctionName() {
            this.changeBackgroundColor(this.dynamicColor || this.defaultValueVAR);
         }
         @HostListener('mouseleave') onMouseLeaveEventFunctionName() {
            this.changeBackgroundColor('white');
         }
         private changeBackgroundColor(color: string) {
            this.elRef.nativeElement.style.backgroundColor = color;
         }    
      }
      <p colorChangeDirective colorChangeVAR="yellow" defaultValueVAR="red">....Test text....</p>
 
 2. Component Directive
 -----------------------------
 Each component is itself a directive too with selector metadata provided with @Component decorator
 @Component({
    templateUrl: "",
    styleUrls: [],
    selector: "comp-selector"
 })
                                USAGE : <comp-selector> Component not available </comp-selector>
 
 3. Structural Directives
 -----------------------------
*ngIf is used for if logic while rendering HTML and *ngFor is used for loops in HTML rendering
These are Structural directives and should be prefixed with *
Reference : https://angular.io/guide/structural-directives

1. *ngIf                         // *ngIf="isValid; else other_content;"      <ng-template #other_content>isValid is false</ng-template>
                                 // *ngIf="num>10;then greater else smaller;" <ng-template #greater>num Greater 10</ng-template>
                                 //                                           <ng-template #smaller>num Smaller 10</ng-template>
                                 
2. *ngFor                        // *ngFor="let item of items; let i = index"        // index of <item> in <items> array

3. [ngSwitch]    ,    *ngSwitchCase



@VIEWCHILD / @VIEWCHILDREN
================================
It provides reference to HTML DOM, similar to "document.getElementById()" in core JS.
This concept can be used in following 3 ways
1. Native HTML Element Reference              (Component .TS ==> <== Component .HTML)
// used ngAfterViewInit and not ngOnInit() in example as this is called when DOM/template is constructed.
// example
// component.html
   <input type='text' #nameElementReference [(ngModel)]='nameFilter' />
   <input type='text' #locationElementReference [(ngModel)]='locationFilter' />
// component.ts
   @ViewChild("nameElementReference", {static: false}) nameElementRefVAR: ElementRef;
   @ViewChildren("nameElementReference, locationElementReference") filterElementRefsVARLIST: QueryList<ElementRef>;
   ngAfterViewInit() {
      console.log(this.nameElementRefVAR);
      console.log(this.filterElementRefsVARLIST);
      this.nameElementRefVAR.nativeElement.focus();
    }

2. Angular Form/Model Reference               (Component .TS ==> <== Component .HTML)
// used for reference to form having ngForm/ngModel reference
// example
// component.ts
   @ViewChild(NgForm, {static: false}) addUserFormReferenceVAR: NgForm;              // 1. Only the first ngForm is returned.
   @ViewChild("formRef", {static: false}) addUserFormReferenceVAR: NgForm;           // specific ngForm i.e.    <form #formRef="ngForm">
                                                                                     // usage eg:- addUserFormReferenceVAR.submitted | addUserFormReferenceVAR.dirty
   @ViewChild(NgModel, {static: false}) ngmodelRefVAR: NgModel;                      // 1. Only the first ng-model is returned.
   @ViewChildren(NgModel) ngmodelsRefVARLIST: QueryList<NgModel>;                    // 2. Returns all the ng-models.
   onSubmit(formValue: any) {
      this.addUserFormReferenceVAR.reset({<NAME_ATTR_VALUE_WIDGET> : "GNDC"});       // reset is angular method , fields not specified will be set to empty
    }
    ngAfterViewInit() {
       if(this.ngmodelRefVAR.invalid) {
          if(this.ngmodelRefVAR.errors.required)  console.log("Name is required...");
          else if (this.ngmodelRefVAR.errors.minlength)  console.log(`Name must be at least 3 characters long...`);
        }
        else {
          console.log(`Current name value: ${this.ngmodelRefVAR.value} ...`);
        }
     }

3. Variable/Method Reference                  (Child Component ==> Parent Component)
// this concept is similar to @Output
// example
A) parent.html
   <p>{{employeesRefTEMPLATE.METHOD()_OR_VAR}}</p>
   <employees #employeesRefTEMPLATE></employees>
 
B) parent.ts
   @ViewChild('employeesRefTEMPLATE', {static: false}) employeesComponentRefVAR: EmployeesComponent;
C) @ViewChild(EmployeesComponent, {static: false}) employeesComponentRefVAR: EmployeesComponent;
    ngAfterViewInit(): void {
       console.log(`Logging through template reference => ${this.employeesComponentRefVAR.METHOD()_OR_VAR}`);
       console.log(`Logging through Child Component => ${this.employeesComponentRefVAR.METHOD()_OR_VAR}`);
    }
   


Angular Animations
=========================
From Angular 4 , animations are part of separate animations library and not part of angular core library as it was earlier.
inside app.module.ts             import BrowserAnimationsModule and write it in imports[] array
inside component's .ts file      animations: [] ,this contains animationName and it's properties, just like template and css properties given.
                                 stateVar: string = "small";                            // this variable change will trigger animation
                                 animateFunc(){
                                    this.stateVar=(this.stateVar=="small"?"large":"small");
                                 }
inside component's .html file    <p [@animationName]="stateVar" (click)="animateFunc()">some random text</p>



Angular FORMS
===================
- These forms should support Two way data binding.
- Keep track of form state, current state is valid or not, display validation errors, enable/disable form based on validation criteria.
1. Template driven forms
   - These are used if we have fixed template to render , we already know fields that are going to be part of form.
   - import 'FormsModules' from "@angular/forms" to app.module.ts imports[] array
   - create .ts class and .html template for it.
   - use of directives ngModel, ngForm, ngModelGroup, ngSubmit.
   - validations are part of template (.html)
   
   - states of form input  ,  example : 1. <input #INPUT_REF="ngModel" /> 
                                        2. <form #FORM_REF="ngForm" (ngSubmit)="submitFunction(FORM_REF.value)"></form>
     INPUT_REF.pristine | INPUT_REF.dirty             // value modified    or not
     INPUT_REF.touched  | INPUT_REF.untouched         // widget is focused or not
     INPUT_REF.valid    | INPUT_REF.invalid           // value is invlaid  or not as per constraints like (required, minlength, pattern)
   
2. Model driven forms (Reactive forms)
   - These are dynamic in nature , JS intensive and less HTML.
   - import 'ReactiveFormsModule' from "@angular/forms" to app.module.ts imports[] array
   - create and initialize Form Control Objects in .ts class which are intermediate objects that hold state of form using FormGroup, FormControl, Validators, FormBuilder (formbuilder prevents use of formcontrol)
   - bind these objects to form control elements in .html template using [formGroup]="" property, formGroupName="" directive, formControlName="" directive
   - validations logic are part of class (.ts) however rules (.invalid && .touched) are defined inside template (.html)



STYLE
=================
-- A global file "styles.css" exists for entire application.
   eg:-  write   @import "https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css"

-- To force the app component's "app.component.css" effects to its child components also use
  /deep/   h1{  color:red;  }      OR
  >>>      h1{  color:red;  }

-- For component specific style use  ".component.ts"  file
   @Component({
           styleUrls:['firstcss', 'secondcss', 'thirdcss']
   })

-- CLASS BINDING
   Binding a CSS class to elements    eg:- [class.CLASS_NAME_CSS] = "BooleanVAR_EXPRESSION"
                                           [ngClass] = "'firstCSSClass secondCSSClass'"                          // NOTE : use of '' over class names
                                           [ngClass] = "['firstCSSClass' , 'secondCSSClass']"
                                           [ngClass] = "{'firstCSSClass' : i%2==0 , 'secondCSSClass' : i%2==1}"



PASSING VARIABLES/VALUES TO and FROM COMPONENTS
=================================================
This concept is used when we have a common class for data that can be used by multiple components (child components)
-- OUTER COMPONENT (parent) to INNER COMPONENT (child)
   In child-comp.ts
   --------------------
   @Input('EXTERNAL_VAR_NAME') INTERNAL_VAR_NAME: string = "DefaultValue";
   
   In child-comp.html
   ---------------------
   {{INTERNAL_VAR_NAME}}
   
   In parent-comp.html
   ---------------------
   <child-selector-tag  [EXTERNAL_VAR_NAME] = "varFromParent.ts" > default text if child component not available </child-selector-tag>


-- INNER COMPONENT (child) to OUTER COMPONENT (parent)
   this is used to receive a message in parent based on an event triggered in child
   in INNER COMPONENT                    import {EventEmitter} from '@angular/core'
   In child-comp.ts
   ----------------------
   @Output() outputVarName: EventEmitter<string> = new EventEmitter<string>();
   
   functionOnEvent() {
       this.outputVarName.emit(dataToEmit);
   }
   
   In parent-comp.html
   ----------------------
   <child-selector-tag  (outputVarName)='functionReceiveMessage($event)' > default text if child component not available </child-selector-tag>
   
   In parent-comp.ts
   ----------------------
   functionReceiveMessage($event): void {
       this.DATA = $event;
   }



LIFECYCLE methods
==========================
After creating a component/directive by calling its constructor,
Angular calls the lifecycle hook methods in the following sequence at specific moments

constructor() {  }
The constructor method is not actually an Angular 2 method. 
It is a predefined method in a TypeScript class which is called when the class is instantiated. 
The constructor’s purpose is to help prepare the creation of a new instance of the class.
In the context of Angular 2 it can be used to properly initialize fields.
Angular 2’s DI (dependency injection) also tries to find providers that match the types of the constructor’s parameters, resolves them, and passes them to the constructor as arguments.

ngOnChanges()	 {  }
Respond when Angular (re)sets data-bound input properties.
The method receives a SimpleChanges object of current and previous property values.
Called before ngOnInit() and whenever one or more data-bound input properties change.

ngOnInit()    {  }
Called once, after the first ngOnChanges().
meaning that all of the injected dependencies will be resolved and all of the class members will be defined.
This makes it the perfect place to do any of the initialization work/logic for the component.

ngDoCheck()	
Detect and act upon changes that Angular can't or won't detect on its own.
Called during every change detection run, immediately after ngOnChanges() and ngOnInit().

ngAfterContentInit()	
Respond after Angular projects external content into the component's view / the view that a directive is in.
Called once after the first ngDoCheck().

ngAfterContentChecked()	
Respond after Angular checks the content projected into the directive/component.
Called after the ngAfterContentInit() and every subsequent ngDoCheck().

ngAfterViewInit()	
Respond after Angular initializes the component's views and child views / the view that a directive is in.
Called once after the first ngAfterContentChecked().

ngAfterViewChecked()	
Respond after Angular checks the component's views and child views / the view that a directive is in.
Called after the ngAfterViewInit() and every subsequent ngAfterContentChecked().

ngOnDestroy()	
Cleanup just before Angular destroys the directive/component.
Unsubscribe Observables and detach event handlers to avoid memory leaks.
Called just before Angular destroys the directive/component.

Example:
Written in  ".component.ts"  of  respective COMPONENT
        export class COMPONENTNAME implements OnInit , OnChanges , OnDestroy{  }
        
        
        
Feature MODULES
=====================
> ng generate module <module_name>
- Having all (say 100s) components in one module (root module, app.module.ts) might make it difficult to debug
  plus it might make initial loading slower as all modules are to be loaded, if not used lazy loading, which is possible via submodules
- // example
  // 1. app-module.ts (ROOT module imports submodules)
  @NgModule({
     declarations: [AppComponent, AboutComponent, PageNotFoundComponent],
     imports: [ BrowserModule, EmployeesModule, CustomersModule, AppRoutingModule ],       // NOTE : root routing module must be after feature module ie at last, else it will load page not found component
                                                                                           // 'FormsModule' is not written as 'EmployeesModule' already imported it via 'SharedModule'
     bootstrap: [ AppComponent ]
  })
  export class AppModule { }
  
  // 2. app-routing-module.ts
  @NgModule({
     imports: [
       RouterModule.forRoot(appRoutes)                                                     // NOTE : use of 'RouterModule.forRoot()'
     ],
     exports: [ RouterModule ]
   })
   export class AppRoutingModule { }

  // 3. customer-module.ts
  @NgModule({
     declarations: [CustomersComponent, CustomerComponent],
     imports: [SharedModule, CustomersRoutingModule]
   })
   export class CustomersModule { }
   
   // 4. customer-routing-module.ts
   {path:'', component: CustomersComponent, canActivate: [CustomersLoadGuardService], resolve: {customers: CustomersResolverService}},
   {path:'customers/<COMPONENT_NAME>/edit/:id', component: CustomerDetailComponent }
   @NgModule({
      imports: [
        RouterModule.forChild(custRoutes)                                       // NOTE : use of 'RouterModule.forChild()' in submodules
      ],
      exports: [ RouterModule ]
   })
   export class CustomersRoutingModule { }
   
   // 5. employee-module.ts
   @NgModule({
      declarations: [EmployeesComponent, EmployeeComponent],
      imports: [SharedModule, EmployeesRoutingModule]
   })
   export class EmployeesModule { }
   
   // 6. employee-routing-module.ts
   {path:'', component: EmployeeComponent, canActivate: [EmployeeLoadGuardService], resolve: {employees: EmployeeResolverService}},
   {path:'employees/<COMPONENT_NAME>/edit/:id', component: EmployeeDetailComponent }
   @NgModule({
      imports: [
        RouterModule.forChild(empRoutes)                                        // NOTE : use of 'RouterModule.forChild()' in submodules
      ],
      exports: [ RouterModule ]
   })
   export class EmployeesRoutingModule { }
   
   // 7. shared-module.ts
   @NgModule({
      declarations: [],
      imports: [],
      exports: [                                                // Being a shared module , it has common functionality required for all modules and export them
                                                                // NOTE : shared module cannot have 'providers' ie we cannot include @Injectable class (service class)
                                                                          because services which act as singletons, could end up being provided multiple times, especially for lazy-loaded modules.
        CommonModule,                                           // since 'CommonModule', 'FormsModule', 'SearchFilterPipe' is exported here and
        FormsModule,                                               we imported 'shared-module' in 'customer-module' which is in turn is imported in app-module (root)                   
        SearchFilterPipe
      ]
    })
    export class SharedModule { }
    
    // 8. searchfilterpipe.ts
    @Pipe({name: 'searchFilter'})
    export class SearchFilterPipe implements PipeTransform{
       transform(items: any[], args: string): any[] {
          let searchFilter: string = args ? args.toLocaleLowerCase() : null;
          return searchFilter ? items.filter((item) => {item.name.toLocaleLowerCase().startsWith(searchFilter) != false}) : items;
    }}


LAZY LOADING
===================
- NOTE :  Creating submodules / feature modules do not ensure lazy loading. We need to configure routing module for same.
- There are three types of module loading
  - Eager loading                        (default)                                   (all modules loaded initially)
  - Lazy Loading without Pre-Loading     (default, when configured for lazy loading) (modules loaded only when required)
  - Lazy Loading with Pre-Loading                                                    (modules loaded by browser in background when it is not involved in any other activity)
  // example
  // 1. app-routing-module.ts     (ROOT routing module)
  // this will make modules to be lazy loaded
  { path: 'employees', loadChildren: () => import('./employees/employees.module').then(m => m.EmployeesModule) },
  { path: 'customers', loadChildren: () => import('./customers/customers.module').then(m => m.CustomersModule) },
  
  // this will enable/disable preloading
  @NgModule({
    imports: [
     RouterModule.forRoot(appRoutes)                                                   // default,       no preloading
  // RouterModule.forRoot(appRoutes, {preloadingStrategy: NoPreloading})               // same as above, no preloading
  // RouterModule.forRoot(appRoutes, {preloadingStrategy: PreloadAllModules})          // preload modules when browser is idle
    ],
    exports: [ RouterModule ]
  })
  export class AppRoutingModule { }
  
  // 2. customers/employees-routing-module.ts
  // NOTE : do not specify name of modules in url i.e. {path: 'customers/<COMPONENT_NAME>/:id'} because it is already specified in root i.e. {path:'customers'}
  {path:'', component: CustomersComponent, canActivate: [CustomersLoadGuardService], resolve: {customers: CustomersResolverService}},
  {path:'<COMPONENT_NAME>/edit/:id', component: CustomerDetailComponent }
  
  // 3. app-module.ts
  @NgModule({
     declarations: [AppComponent, AboutComponent, PageNotFoundComponent],
     imports: [ BrowserModule, AppRoutingModule ],                          // NOTE : Do not include feature modules i.e. 'CustomersModule', 'EmployeesModule' here as they are to be lazy loaded
     bootstrap: [ AppComponent ]
  })
  export class AppModule { }




SERVICE
====================
Write a     ".service.ts"   file for COMPONENT   and  use   @Injectable()  decorator over   export class ServiceClass{  }
            > ng generate service <SERVICE_NAME>

declare in  "providers" array  of  "app.module.ts"  this  service class
            OR
if metadata providedIn: 'root' is given in @Injectable({}) decorator , it prevents need to write in "providers" array of app.module.ts

inject in   ".component.ts"  file  of COMPONENT using   constructor()
                          pass values to .html var using   ngOnInit()

COMMUNICATION with SERVICE
---------------------------
NOTE      : MAKE sure to install JSON SERVER   "npm install -g json-server"
Reference :                                    "https://github.com/typicode/json-server"

NOTE : JSON-Server uses default KEYWORD  "id"
Create a .JSON file under dir        "PROJ\src\"

CHANGE DIR to your .JSON file's dir  "PROJ\src\"
Start JSON SERVER                              "json-server -–watch filename.json"       // --watch keeps check over any changes made

OPEN new TERMINAL window
CHANGE DIR to "PROJ"  as it is where "package.json" is present
Start ng      "ng serve"

declare  "HttpClientModule" in  "imports"  of  "app.module.ts"

configure ".service.ts"

CREATE    "interface.ts"  file and export interface
           > ng generate interface <INTERFACE_NAME>

configure ".component.ts" file



Use of HttpClientModule
------------------------
HTTP request is made in browser using either XMLHttpRequest or fetch().
import {HttpClientModule} from "@angular/common/http" and included in imports[] array.
HttpClientModule provides testability features, typed request and response objects, request and response interception, Observable APIs, Streamlined error handling.
-- PROMISE         (SUCCESS data , ERROR data)
-- OBSERVABLES     (SUCCESS data , ERROR data , DONE)  these are required to be SUBSCRIBED , .subscribe() triggers execution of  OBSERVABLES and causes HttpClient to compose and send request to server.
-- JSON SERVER     (a .json file is to be added in src of PROJECT)

import {HttpHeaders} from "@angular/common/http"
const httpOptions = {
  headers: new HttpHeaders({
    'content-type' : 'application/json',
    'authorization' : 'tokenValue'
  })
}
import 'rxjs' in app.module.ts     // RxJS is a library for reactive programming using Observables, to make it easier to compose asynchronous or callback-based code.



CLIENT SIDE ROUTING
=============================
Multiple routes... eg: localhost:4200/home/signup/

Create file         "app.routing.ts"   in project's app component root dir , which contains urls/routes
                     NOTE : Do not put '/' in path , ANGULAR will put it automatically
                     - examples
                     {path: 'URL', component: 'NameOfComponentClass', data: {varInComponentTS: 'dataPassedToComponent'}}
                     {path: 'employees', children: [
                                  { path: '', component: EmployeesComponent },
                                  { path: 'add', component: AddEmployeeFormComponent, canDeactivate: [AddEmployeeGuardService]},
                                  { path: ':id', component: EmployeeDetailComponent, canActivate: [EmployeeDetailGuardService]}]
                     }                                                                       // specify children path to avoid writing parent-'employees/' again and again
                     {path: '**', component: 'NoneOfAboveURLMatchRequest'}                   // when none of URLs match request it comes here
                     {path: '', component: 'BaseComponent'}                                  // empty path means BASE_URL ie '/'
                     {path: '', component: 'BaseComponent', pathMatch: 'full' }              // whole URL path needs to match
                     {path: '', component: 'BaseComponent', pathMatch: 'prefix' }            // first route where the path matches the start of the URL is chosen
                     {path: 'URL', component: '', canActivate: [RouteAuthServiceName], canDeactivate: [RouteAuthServiceName], canLoad: [RouteAuthServiceName], resolve: { dataVAR_IN_ROUTE: RouteAuthServiceName }}
                           // To restrict access to a URL/Component , there are 5 types of route guards :-
                           // CanActivate     : Controls if route can be activated.
                              CanActivateChild: Controls if children of a route can be activated.
                              CanLoad         : Controls if route can even be loaded. 
                                                This becomes useful for feature modules that are lazy loaded. 
                                                They won’t even load if the guard returns false, thus cannot even see the source code of the module.
                                                It must be used with canActivate, because once loaded and user logged out, it will still be present in browser cache, guard will return true.
                              CanDeactivate   : Controls if the user can leave a route. 
                                                NOTE : This guard doesn’t prevent the user from closing the browser tab or navigating to a different address. 
                                                       It only prevents actions from within the application itself.
                              Resolve         : To complete data retrieval before navigating to a route
                                                Refer: loading.io/css    for loader's HTML (app.component.html) + CSS (app.component.css)
                                                NOTE : it uses NAVIGATION instance as written in app.component.ts (ROOT component)
                                                       plus get snapshot of data in component where the data is shown after retrieval
                                                // 1. app.component.ts
                                                export class AppComponent {
                                                   isLoading: boolean = true;        // variable for loader <div> i.e.   *ngIf="isLoading"
                                                   
                                                   constructor(private _authService: AuthService, private _router: Router) {
                                                      this._router.events.subscribe((event: Event) => {
                                                          if (event instanceof NavigationStart) {
                                                             this.isLoading = true;
                                                          }
                                                          else if (event instanceof NavigationEnd || event instanceof NavigationError || event instanceof NavigationCancel) {
                                                             this.isLoading = false;
                                                          }
                                                       }) 
                                                    }
                                                 }
                                                 // 2. component.ts
                                                 constructor(private _route: ActivatedRoute) { 
                                                    this.dataVAR_IN_COMPONENT = this._route.snapshot.data['dataVAR_IN_ROUTE'];
                                                 }
                           // we could specify multiple guards service for a route guard in a route, and they’ll be evaluated in the order in array for that route guard.
                           // NOTE : Declare route authentication service(s) name(s) in 'providers' array of respective '.module.ts'
                           // example - RouteAuthServiceName.ts
                           @Injectable()
                           export class RouteAuthServiceName implements CanActivate, CanDeactivate<ComponentNameToDeactivate>, CanLoad, Resolve<TYPE_OF_DATA_RETURN> {
                              constructor() {}
                              canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): boolean {
                                 if(this.METHOD_VAR_IN_SERVICE) {                   // returns true/false , can be from other service as well  eg: this.authService.METHOD_VAR_IN_SERVICE
                                    return true;
                                 }
                                 else {
                                    this._router.navigate(['login']);
                                    return false;
                                 }
                              }
                              
                              canDeactivate(component: ComponentNameToDeactivate): boolean {
                                 if (component.METHOD_VAR_IN_COMPONENT) {                   // returns true/false from a method/variable in component to be deactivated, 
                                                                                               we can make use of @ViewChild variables in component.ts
                                    return confirm('Are you sure?');
                                 }
                                 return true;
                              }
                              
                              canLoad(route: Route): boolean { }
                              
                              resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Promise<TYPE_OF_DATA_RETURN> | Observable<TYPE_OF_DATA_RETURN> | any {
                                 return this._customersService.getCustomers();
                              }
                            }

Import and write in "imports"   of     "app.module.ts"   the routing object which was exported from "app.routing.ts"

NOTE : wherever define    <router-outlet></router-outlet>    routing module urls output shown there

<a href=""> ... </a>  sends request to BROWSER directly , so use routerLink="" to send control to routerModule
If the link is static, we can use                                <a routerLink="/product/iPhone"></a>
If the link is dynamic, , NOTE : use of '' inside string         <a [routerLink]="['staticURLArg', dynamicArgVar, 'staticURLArg']"></a>
Set single CSS class to active link using                        routerLinkActive="CSS_Class"
Set multiple CSS classes , NOTE : use of '' inside string        [routerLinkActive]="'CSS_CLASS_1 CSS_CLASS_2'"
For exact match of urls use                                      [routerLinkActiveoptions]="{exact:true}"
For partial match  ,  eg:- employees/:DYNAMIC_ROUTING , DO NOT use {exact:true}


. DYNAMIC ROUTING
  using   path : "PARENT-URL/:varname" in  "app.routing.ts"  define a new component (DetailsComponent)
  
  config "DetailsComponent.component.ts"
       -- constructor(ActivatedRoute , Location)    // ActivatedRoute : PARENT-URL  ,  Location : From where coming
       -- ngOnInit()                                // Traverse the params of path  ie  /:varname1/:varname2

  In .HTML define " routerLink='{{emp.id}}' " for the link. this value is the just the next value of PARENT-URL
          
  In     "app.module.ts"  declare  "DetailsComponent" in "declarations"
                          import   'rxjs'           // RxJS is a library for reactive programming using Observables, to make it easier to compose asynchronous or callback-based code.



LOCATION STRATEGIES
=====================
REFERENCE   :   https://codecraft.tv/courses/angular/routing/routing-strategies/

we have two strategies we can use to implement client side routing,
one is called the HashLocationStrategy and the other is called the PathLocationStrategy.

The default in Angular is the PathLocationStrategy, if we do nothing that is the strategy Angular will employ.


HashLocationStrategy
---------------------
To enable HashLocationStrategy in an Angular application we pass {useHash: true} when we are providing our routes with RouterModule
eg:-  RouterModule.forRoot(routes, {useHash: true})

URL can contain some data prepended with a # character.

The # part of the url is called the hash fragment.

It’s normally used so that people can link to a particular section in a HTML page, specifically anchor tags,
for example if there is an anchor tag with an name attribute of routing-strategies like so:

<a name="routing-strategies"></a>

Then if you created a bookmark of   http://somedomain.com/page#routing-strategies
Then the browser would open somedomain.com/page and then scroll down so that the <a name="routing-strategies"></a> tag is at the top of the page.

Also anything past the # in a URL never gets sent to the server.
So if your URL was   https://codecraft.tv/contact/#/foo/moo/loo   then the browser makes a GET request to https://codecraft.tv/contact/ only.
The #/foo/moo/loo part of the URL is never sent.

It preserves a state of page and so on RELOADING a page , the UI state is maintained.



HTTP INTERCEPTORS
========================
- Interceptors allow to inspect & transform Http requests before it goes to the server ie act as gate between outgoing requests or incoming responses.
  Multiple interceptors can be chained, NOTE : The interceptors will be called in the order in which they were provided.
  It is useful for logging, authentication etc.
  If interceptor was not there, the code has to be duplicated in each HttpClient method call.
  
- Steps
  1) Create an Injectable class for each type of interceptor implementing interface HttpInterceptor
  2) In the interface method, intercept, handle the request appropriately and call next so that the next interceptor in the chain can handle until the last interceptor
     The intercept method takes two arguments, req and next, and returns an observable of type HttpEvent.
          req is the request object itself and is of type HttpRequest.
          next is the http handler, of type HttpHandler. The handler has a handle method that returns our desired HttpEvent observable.
     HttpRequest objects are immutable, The request object’s clone method is used to first make a copy, then modify the copy and call handle on the modified copy.
  3) The class implementing HttpInterceptor should be mentioned in 'providers' array in AppModule.ts.
     multi: true option tells Angular that HTTP_INTERCEPTORS is a token for a multiprovider that injects an array of values, rather than a single value.
  // example
  // 1. log-interceptor.ts
  @Injectable()
  export class LogRequestInterceptor implements HttpInterceptor {
    intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
       console.log(`**** LogRequestInterceptor => url = ${req.url}, method = ${req.method}`);
       req.headers.keys().map((key) => {console.log(`${key}=${req.headers.get(key)}`)});
       return next.handle(req);
     }
   }
   
   // 2. auth-interceptor.ts
   @Injectable()
   export class AuthInterceptor implements HttpInterceptor {
     intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
       console.log("**** AuthInterceptor ...");
       if(req.body && req.headers && req.params){
          duplicate = req.clone({
            headers: req.headers.set('Authorization', "mytoken"),
            params: req.params.set('filter', 'completed'),
            body: req.body.replace(/pizza/gi, 'desi_bread')
          });
          return next.handle(duplicate);
       }
       return next.handle(req);
     }
    }
    
    // 3. httpInterceptorsProvider.ts
    import { HTTP_INTERCEPTORS } from '@angular/common/http';
    import { LogRequestInterceptor } from './log-request-interceptor';
    import { AuthInterceptor } from './auth-interceptor';
    export const httpInterceptorProviders = [
      { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },                // order matters of providing interceptors
      { provide: HTTP_INTERCEPTORS, useClass: LogRequestInterceptor, multi: true }
    ];
    
    // 4. app.module.ts
   providers : [httpInterceptorProviders]





