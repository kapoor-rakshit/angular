Spartacus is Angular-based JavaScript storefront for SAP Commerce Cloud.
Spartacus talks to SAP Commerce Cloud exclusively through the Commerce REST API.
Starting with version 5.0, “SAP Commerce Cloud, composable storefront” is name for official release of project “Spartacus” libraries published by SAP.

REFERENCE: https://github.com/SAP/spartacus#requirements
    For which version of    Node, Angular, Yarn, NPM    to use, refer above website for suitable Spartacus(Composable Storefront) version

To install composable storefront, need to set up access to composable storefront libraries in Repository Based Shipment Channel (RBSC)
    RBSC website: https://ui.repositories.cloud.sap/www/webapp/users/
    Create an S-user for RBSC that has the appropriate licenses to download the composable storefront libraries.
    An S-user account can see Composable Storefront License in list of licenses.
    If the Composable Storefront License does not appear in this list, there will be an error when downloading the packages.
    Click on Add User and create a technical user.
    In User Management tab of RBSC website, select the technical user and copy the generated NPM Base64 Credentials, required for .npmrc file in project

SETUP
=============
> ng new <APP_NAME> --style=scss --routing=false
> cd <APP_NAME>
> create an .npmrc file with following content | NOTE: // in second line | NOTE: NPM-CREDENTIALS-FROM-RBSC copied as in above steps
      @spartacus:registry=https://73554900100900004337.npmsrv.base.repositories.cloud.sap/
      //73554900100900004337.npmsrv.base.repositories.cloud.sap/:_auth=NPM-CREDENTIALS-FROM-RBSC
      always-auth=true
> ng add @spartacus/schematics@VERSION --baseUrl <BACKEND_URL> --baseSite=<CONFIG> --ssr --pwa
      --baseUrl: url of backend
      --baseSite: name of storefront
      --ssr: enable SSR features of app
      --pwa: enable PWA features of app
> npm install

1. It creates a directory named `spartacus` and inside it:
    1. creates module `spartacus-configuration.module.TS`
       // This will have all configs for spartacus like baseUrl, baseSite etc.
       @NgModule({
          declarations: [],
          imports: [],
          providers: [
             provideConfig(layoutConfig),               // custom page layout config file
             provideConfig(mediaConfig),                // media config file for images
             provideConfig({                            // image loading strategy
                imageLoadingStrategy: ImageLoadingStrategy.LAZY,
             } as MediaConfig),
             provideConfig(<OccConfig>{                 // base URL config
                backend: {
                  occ: {
                    baseUrl: environment.occBaseUrl,
                  },
                },
             }),
             provideConfig(<OccConfig>storeEndpoints),  // endpoints config file for OccEndpointsService
             provideConfig(<SiteContextConfig>{         // base SITE config
                context: {
                   currency: ['AUD'],
                   language: ['en'],
                   baseSite: ['PROJECT_NAME-spa'],
                },
             }),
             provideConfig(<I18nConfig>{
                i18n: { resources: myTranslations },   // translations config file

                state: {                               // Spartacus runs XHR requests on server, and then again on client-side when application bootstraps.
                  ssrTransfer: {                       // Spartacus includes part of the NgRx state with the server-side rendered HTML
                    keys: {                            // This prevent unnecessary calls to back end for state that was already populated on server,
                      products: StateTransferType.TRANSFER_STATE,
                      cms: StateTransferType.TRANSFER_STATE,
                    },
                  },
                },
             }),
          ]})
       export class SpartacusConfigurationModule {}
    2. create module `spartacus-features.module.TS`
       // All module imports like FooterNavigationModule, BreadcrumbModule etc.
    3. create module `spartacus.module.TS`
       // import above modules along with BaseStorefrontModule
       @NgModule({
          declarations: [],
          imports: [SpartacusFeaturesModule, SpartacusConfigurationModule, BaseStorefrontModule],
          exports: [BaseStorefrontModule]
       })
       export class SpartacusModule {}
    
2. app.module.TS
------------------
- Remove default angular module `AppRoutingModule` from import (if added when creating Angular project), else nothing will be displayed.
- import `spartacus.module.TS` that we created above, which had other SPARTACUS modules imported.

3. app.component.HTML
-----------------------
- Entire content is deleted and replaced by a single HTML tag
  <cx-storefront></cx-storefront>
  
NOTE: if missed some config, while creating app, it can be done later too
> ng g @spartacus/schematics:add-pwa                    // adds spartacus-specific PWA module
> ng g @spartacus/schematics:add-ssr                    // adds SSR configuration


MODULES / COMPONENTS / LAYOUT
=================================
> ng g m custom-pdp
> ng g c custom-pdp/custom-product-intro

// DO NOT import these feature modules to `APP.MODULE.TS` directly, but
// import them to  `spartacus-features.MODULE.TS` which is imported by  `spartacus.MODULE.TS` which is imported by `APP.MODULE.TS`
// This allows for LAZY-LOADING of modules that is handled by spartacus.

// To use feature components that are available via Spartacus Storefront, they are to be imported.
// `withConfig` defines that it is a CMS component.
// flexType or typeCode value that we receive from backend is used for mapping to our SPARTACUS component
custom-pdp.module.TS
----------------------
@NgModule({
    declarations: [CUSTOM-COMP-NAME],
    imports: [
        CommonModule,
        StarRatingModule,                                // module import from spartacus storefront
        ConfigModule.withConfig({
            cmsComponents: {
                TYPE-CODE-NAME: {
                    component: CUSTOM-COMP-NAME
                }
            }
        } as CmsConfig)
    ]
})
export class CustomPdpModule {}

custom-product-intro.comp.HTML
---------------------------------
<ng-container *ngIf = "product$ | async as product">
    <h1>{{product?.name}}</h1>
    <h3>{{product?.price?.formattedValue}}</h3>
    <cx-star-rating                                     // comp used from spartacus storefront, must be imported in that module
      [rating] = "product?.averageRating"
      [disabled] = "true">
    </cx-star-rating>
</ng-container>

layout-config.TS                                       // a custom layout file to be provided to `spartacus-configuration-module.TS`
---------------------                                  // layouts are rendered in <CX-PAGE-LAYOUT> and slots(POSITION keys from backend) in <CX-PAGE-SLOT>
import { LayoutConfig } from '@spartacus/storefront';
export const layoutConfig: LayoutConfig = {
  layoutSlots: {
      header: {                                                    // <cx-page-layout class="header"></cx-page-layout>
        lg: { slots: ['PreHeader', 'SiteLogo', 'SearchBox'] },     // <cx-page-slot  class="PreHeader" position="PreHeader"></cx-page-slot>
        slots: ['PreHeader', 'SearchBox']                             // less than lg breakpoint, these slots will be rendered
      },
      navigation: {                                                // <cx-page-layout class="navigation"></cx-page-layout>
        lg: { slots: ['MegaMenu'] },                               // lg(>=992px), these slots(position vals) will be rendered in <cx-page-slot>
        md: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] },     // md(>=768px)
        sm: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] },     // sm(>=576px)
        xs: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] }      // xs(<576px)
      },
      footer: {                                                    // <cx-page-layout class="footer"></cx-page-layout>
        slots: ['Footer']                                          // <cx-page-slot class="Footer" position="Footer"></cx-page-slot>
      },
      LandingPage2Template: {                                      // <cx-page-layout class="LandingPage2Template"></cx-page-layout>
        lg: {
          pageFold: 'UpSelling',                                   // Above-the-fold loading is an indication to speed up initial creation of slots
                                                                   // pageFold: indicates last page slot that should be rendered above the fold.
                                                                   // and are prioritized ahead of page slots that are “below the fold”/after this slot
          slots: ['Summary', 'UpSelling', 'Section2B']
        },
        pageFold: 'Section2B',
        slots: []
      },
      SearchResultsListPageTemplate: {
        slots: ['SearchDescription', 'SearchResultList']
      }
  }
}

NOTE: Components come from backend side.
An API call , /pages?lang=EN&curr=AUD , gets all components that are used. It returns:
contentSlots: {
  contentSlot: [
    {
      components: {
          component: [
            {
              uid: "CustomTileWithTextResponsiveBannerComponent",
              typeCode: "FFCMSContainerComponent",                        // typecode or flexType: mapping to custom spartacus component in MODULE file
              flexType: "FFCMSContainerComponent"                         // NOTE: It depends on backend config, which one to use from these two
            }
          ]
      }
      name: "Tile With Text Banner Slot",
      position: "TileWithTextBanner",                                     // position: included in <cx-page-slot> and used in layout-config.TS
      slotId: "TileWithTextBannerSlot",
      slotShared: false,
      slotUuid: "eyJpdG"
    }
  ]
}
label: "search"
name: "Search Results Page"
robotTag: "INDEX_FOLLOW"
template: "SearchResultsListPageTemplate"                               // template: used in <cx-page-layout>
typeCode: "ContentPage"
uid: "search"
uuid: "eyJp==="

ADD COMPONENT/DATA FROM SLOT, INSIDE ANGULAR COMPONENT
=========================================================
1. .COMP.HTML
--------------
<ng-container *ngIf="component.data$ | async as data">
 <!-- add component using typecode / uid -->
 <ng-container
   [cxComponentWrapper]="{
     flexType: data?.productBrochure?.typeCode,
     typeCode: data?.productBrochure?.typeCode,
     uid: data?.productBrochure?.uid
    }">
 </ng-container>

 <!-- add data using key from response -->
 <span>{{data?.detailErrorMessage}}</span>
</ng-container>
2. .COMP.TS
------------
constructor(public component: CmsComponentData<CmsTabComponent>)


LAUNCH-DIALOG SERVICE (POPUP)
=================================
1. .MODEL.TS
--------------
import '@spartacus/storefront';
declare module '@spartacus/storefront' {
  const enum LAUNCH_CALLER {
    FABRIC_SELECT = 'FABRIC_SELECT',
    NEAREST_STORES = 'NEAREST_STORES'
  }
}
2. .MODULE.TS
---------------
export const defaultLaunchConfig: LayoutConfig = {
  launch: {
    [LAUNCH_CALLER.FABRIC_SELECT]: {
      inlineRoot: true,
      component: PopupComponent_1,
      dialogType: DIALOG_TYPE.DIALOG,
    },
    [LAUNCH_CALLER.NEAREST_STORES]: {
      inlineRoot: true,
      component: PopupComponent_2,
      dialogType: DIALOG_TYPE.DIALOG,
    }
}};
@NgModule({
  declarations: [],
  imports: [],
  providers: [provideDefaultConfig(defaultLaunchConfig)],
})
3. .COMP.TS
-------------
import { LaunchDialogService, LAUNCH_CALLER } from '@spartacus/storefront';
@ViewChild('NearestStoreModalOpen') private dialogTriggerRef!: ElementRef;
constructor(private launchDialogService: LaunchDialogService) {}
A.
this.launchDialogService.openDialogAndSubscribe(LAUNCH_CALLER.NEAREST_STORES, this.dialogTriggerRef, {
  data_key_1: data_value_1,
  data_key_2: data_value_2
});
B.
this.launchDialogService.dialogClose.pipe(takeUntil(this.destroyed$)).subscribe((data: any) => {
  // TODO: data received from .popup.comp.TS on closing dialog
});
4. .POPUP.COMP.TS
------------------
A.
this.launchDialogService.data$.pipe(takeUntil(this.destroyed$)).subscribe((data: any) => {
  // TODO: data received from .comp.TS on opening dialog
});
B.
this.launchDialogService.closeDialog({
  data_key_1: data_value_1,
  data_key_2: data_value_2
});


GLOBAL MESSAGE SERVICE (BANNER MESSAGE SHOWN AT TOP)
=========================================================
import { GlobalMessageService, GlobalMessageType } from '@spartacus/core';
constructor(private globalMsgService: GlobalMessageService) {}
this.globalMsgService.add(
  'MSG-STRING' || { key: 'KEY-FROM-TRANSLATIONS-FILE' },
  GlobalMessageType.MSG_TYPE_CONFIRMATION                         // MSG_TYPE_CONFIRMATION | MSG_TYPE_ERROR | MSG_TYPE_INFO | MSG_TYPE_WARNING
);


HTTP REQUESTS (services)
===========================
1. SERVICE.TS
----------------
import { OccEndpointsService, OCC_USER_ID_ANONYMOUS } from '@spartacus/core';
readonly defaultUserId = OCC_USER_ID_ANONYMOUS;                                            // OCC_USER_ID_CURRENT | OCC_USER_ID_ANONYMOUS | OCC_USER_ID_GUEST
constructor(public httpClient: HttpClient, public occEndpointsService: OccEndpointsService) { }
A.
serviceMethod() {
  const url = this.occEndpointsService.buildUrl('KEY-FROM-ENDPOINTS-CONFIG-FILE', {       // eg:'KEY_2' , file configured in `spartacus-configuration.MODULE.TS`
    urlParams: {
      PARAM_1: this.defaultUserId,                                                        // variables in URL i.e. ${PARAM_1}
      PARAM_2: VAL_2,
    }
  });
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
OR
B.
serviceMethod() {
  const endpointURL = storeEndpoints.endpointURL_2;
  const url = this.occEndpointsService.buildUrl(endpointURL, {                           // NOTE: no use of '', because it is URL and not KEY
    urlParams: {
      PARAM_1: this.defaultUserId,
      PARAM_2: VAL_2,
    }
  });
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
2. ENDPOINTS.CONST.TS
------------------------
// NOTE: If KEY is NOT found from here, it is referred from configs from SPARTACUS builtin like `defaultOccCartConfig`
export const storeEndpoints = {
  backend: {
    occ: {
      endpoints: {
        KEY_1: 'basesites?fields=FULL',
        KEY_2: 'users/${PARAM_1}/carts/${PARAM_2}?fields=FULL'
      },
    },
  },
  endpointURL_1: 'payment-token',
  endpointURL_2: 'users/${PARAM_1}/orders?cartId=${cartid}&fields=FULL'
};


ROUTING
============
Many routes are built-in with SPARTACUS, and render templates accordingly.
However, we can create CUSTOM routes too.
1. APP.MODULE.TS
-----------------
imports: [
    ConfigModule.withConfig({
      routing: {
        routes: {
          FE_PATH_1: { paths: ['BACKEND_PATH_FOR_PAGE_1'] },
          FE_PATH_2: { paths: ['BACKEND_PATH_FOR_PAGE_2'] },
        }
      }
    })
]
2. SPARTACUS-FEATURES.MODULE.TS
-------------------------------
imports: [
    CUSTOM_MODULE_1,
    CUSTOM_MODULE_2
]
3. .COMP.TS
-------------------
import { RoutingService } from '@spartacus/core';
constructor(private routingService: RoutingService) {}
navigateFabricSamples() {
    this.routingService.go({
      cxRoute: 'FE_PATH_2',
    });
}


CART SERVICES
===================
import { ActiveCartService, UserIdService, MultiCartService } from '@spartacus/core';
constructor(private activeCartService: ActiveCartService,
            private userIdService: UserIdService,
            private multiCartService: MultiCartService) {}
A.
// Subscribe to any cart related changes and get cart data
this.activeCartService.getActive().pipe(takeUntil(this.unsubscribe$)).subscribe((cart: CART-TYPE) => {
  this.cartID = cart?.guid || cart?.code;
  this.cdRef.markForCheck();
});
B.
// Reload/Refresh cart at app level to have changes if any reflected in getActive() cart subscription (REFER: A point)
this.reloadSub = combineLatest([
    this.userIdService.getUserId().pipe(take(1)), this.activeCartService.getActiveCartId().pipe(take(1))
]).subscribe(([userId, cartId]: [string, string]) => {
      if (cartId && userId) {
        this.multiCartService.loadCart({
          userId,
          cartId,
          extraData: {
            active: true,
          },
        });
        if (this.reloadSub) {
          this.reloadSub.unsubscribe();
        }
      }
});
C.
// Create new cart if not exists, else return existing cart (REFER: localstorage of browser for cartID)
this.activeCartService.requireLoadedCart().pipe(
    concatMap((cartState) => {
        return this.SERVICE.HTTP-SERVICE-METHOD(cartState?.value?.code ?? '');
    })
).pipe(takeUntil(this.unsubscribe$)).subscribe((data: any) => {
    // TODO: SUCCESS OF HTTP-SERVICE-METHOD
}, (err: Error) => {
    // TODO: ERROR OF HTTP-SERVICE-METHOD
});


STYLES
============
A.
Spartacus provides default styling library called Sparta in the @spartacus/styles package.
This package should be imported into project through the `styles.scss` file.
src/styles.scss
------------------
$primary: #e502bf                                                          // if any new value to scss variables, has to be re-assigned.
$font-weight-normal: 500;                                                  // this is done before Sparta library import.
@import '@spartacus/styles/scss/cxbase/mixins';

B.
Spartacus provides BreakpointService, which allows same control as media queries, within TS files.
It is better to use as it responds to resize event.
Create a `responsive.SERVICE.TS` file, that can be injected in any COMPONENT.
import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
import { WindowRef } from '@spartacus/core';
import { BREAKPOINT, BreakpointService, LayoutConfig } from '@spartacus/storefront';
import { Observable } from 'rxjs';
@Injectable({
  providedIn: 'root',
})
export class ResponsiveService extends BreakpointService {
  constructor(protected winRef: WindowRef, layoutConfig: LayoutConfig, @Inject(PLATFORM_ID) platform: any) {
    super(winRef, layoutConfig, platform);
  }
  isMobile$: Observable<boolean> = this.isDown(BREAKPOINT.sm);  // when referring DOWN, it picks up limit of next breakpoint, here sm < 768px
  isDesktop$: Observable<boolean> = this.isUp(BREAKPOINT.lg);   // when referring UP, it picks up limit of same breakpoint, here lg >= 992px
}


