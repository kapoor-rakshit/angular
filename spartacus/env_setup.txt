Spartacus is Angular-based JavaScript storefront for SAP Commerce Cloud.
Spartacus talks to SAP Commerce Cloud exclusively through the Commerce REST API.
Starting with version 5.0, “SAP Commerce Cloud, Composable Storefront” is name for official release of project “Spartacus” libraries published by SAP.

Spartacus Code Repo, must be cloned on development machine, to have reference for builtin core features like cart, search etc.
GITHUB REPO: https://github.com/SAP/spartacus
REFERENCE  : https://help.sap.com/docs/SAP_COMMERCE_COMPOSABLE_STOREFRONT/cfcf687ce2544bba9799aa6c8314ecd0/e38d45609de04412920a7fc9c13d41e3.html

Storefront Version
REFERENCE: https://github.com/SAP/spartacus#requirements
For which version of    Node, Angular, Yarn, NPM    to use with Spartacus(Composable Storefront) version, refer above website

SmartEdit
REFERENCE: https://help.sap.com/docs/SAP_COMMERCE_CLOUD_PUBLIC_CLOUD/e1391e5265574bfbb56ca4c0573ba1dc/a4b1ea8d8a7249d28ec4aa0e58ff5518.html
           https://sap.github.io/spartacus-docs/smartEdit-setup-instructions-for-spartacus/
Available via @spartacus/smartedit, it allows for creating new pages on website via an interactive GUI.
`SmartEditFeatureModule` module is imported in `spartacus-features.module.ts`. Inside `SmartEditFeatureModule`, it is provided with config for allowed origins.
1. add browserURL for storefront be allowed inside `whiteListedStorefronts` of Configuration Editor(Settings icon in top right) of SmartEdit with admin login.
2. ensure that WCMS Cockpit Preview URL is set in BackOffice(Website > yoursite > WCMS Properties > WCMS Cockpit Preview URL),same as browserURL for storefront
3. from CCv2 -> Security -> HTTP Response Header Set -> Create
       Code: jsapps
       Name: Header for JSapps
       Description: Additional response header set for service jsapps
       HeaderName: X-Frame-Options
       HeaderValue: ''(leave this blank)
       ApplyAction: UNSET
       ApplyCondition: ALWAYS
   Now move to Environments -> yourenvironemt -> JS-Storefront -> Add this `Header for JSapps` from dropdown to this environment
4. allowOrigin adds SmartEdit to storefront's list of permitted domains, so that it can be used to edit storefront in a cross-origin setup.
   NOTE: Port must be specified with origin (https is 443).
         `*` wildcard can only replace just one subdomain and cannot replace `.`(dot), so any `.`(dot) in origin is to be added explicitly.
   provideConfig(<SmartEditConfig>{
           smartEdit: { allowOrigin: 'localhost:9002, *.*.model-t.cc.commerce.ondemand.com:443, *.HOSTNAME.com:443' }
   })

ASM (Assisted Service Mode)
Available via @spartacus/asm, it allows for a Super-User functionality where an agent can login to any customer account and check their cart etc.
`AsmFeatureModule` module is imported in `spartacus-features.module.ts`.
This can be seen by appending `?asm=true` to website. Eg: https://HOSTNAME?asm=true

HAC (Hybris Administrative Console or BackOffice Admin Console)
It is for administrator to handle entire functions and operations in website like:
ImpEx (Import-Export), Groovy Script, Configuration, Cache, Cron Job
Use-Case-1: CORS issue: Check property 'allowedHeaders' through HAC , delete web application services for CORS , rerun CORS impex

To install composable storefront, need to set up access to composable storefront libraries in Repository Based Shipment Channel (RBSC)
    RBSC website: https://ui.repositories.cloud.sap/www/webapp/users/
    Create an S-user for RBSC that has the appropriate licenses to download the composable storefront libraries.
    An S-user account can see Composable Storefront License in list of licenses.
    If the Composable Storefront License does not appear in this list, there will be an error when downloading the packages.
    Click on Add User and create a technical user.
    In User Management tab of RBSC website, select the technical user and copy the generated NPM Base64 Credentials, required for .npmrc file in project

SETUP
=============
> ng new <APP_NAME> --style=scss --routing=false
> cd <APP_NAME>
> create an .npmrc file with following content | NOTE: // in second line | NOTE: NPM-CREDENTIALS-FROM-RBSC copied as in above steps
      @spartacus:registry=https://73554900100900004337.npmsrv.base.repositories.cloud.sap/
      //73554900100900004337.npmsrv.base.repositories.cloud.sap/:_auth=NPM-CREDENTIALS-FROM-RBSC
      always-auth=true
> ng add @spartacus/schematics@VERSION --baseUrl <BACKEND_URL> --baseSite=<CONFIG> --ssr --pwa
      --baseUrl: url of backend
      --baseSite: name of storefront
      --ssr: enable SSR features of app
      --pwa: enable PWA features of app
  OR
  ng update @spartacus/schematics@VERSION         // After update is done, inspect your code for comments that begin with TODO:Spartacus
> check `package.json` for correct version of @spartacus libs and
  delete node_modules(if already exists) and then run:
  npm install

1. It creates a directory named `spartacus` and inside it:
    1. creates module `spartacus-configuration.module.TS`
       // This will have all configs for spartacus like baseUrl, baseSite etc.
       @NgModule({
          declarations: [],
          imports: [],
          providers: [
             provideConfig(layoutConfig),               // custom page layout config file
             provideConfig(mediaConfig),                // media config file for images
             provideConfig({                            // image loading strategy
                imageLoadingStrategy: ImageLoadingStrategy.LAZY,
             } as MediaConfig),
             provideConfig(<OccConfig>{                 // base URL config
                backend: {
                  occ: {
                    baseUrl: environment.occBaseUrl,    // value is only defined in `environment.ts`, however in `environment.prod.ts` it is `undefined`
                                                           // For prod deployment use meta tag in INDEX.HTML,`content` attr is replaced with URL from CCv2 config
                                                           // i.e.  <meta name="occ-backend-base-url" content="OCC_BACKEND_BASE_URL_VALUE" />
                    prefix: '/app/v2/'                  // if not specified, the default('/occ/v2/') comes from Spartacus `defaultOccConfig`
                  },
                },
             }),
             provideConfig(<OccConfig>storeEndpoints),  // endpoints config file for OccEndpointsService
             provideConfig(<SiteContextConfig>{         // base SITE config
                context: {
                   currency: ['AUD'],
                   language: ['en'],
                   baseSite: ['PROJECT_NAME'],
                },
             }),
             provideConfig(<I18nConfig>{
                i18n: { resources: appTranslations },   // translations config file

                state: {                               // Spartacus runs XHR requests on server, and then again on client-side when application bootstraps.
                  ssrTransfer: {                       // Spartacus includes part of the NgRx state with the server-side rendered HTML
                    keys: {                            // This prevent unnecessary calls to back end for state that was already populated on server,
                      products: StateTransferType.TRANSFER_STATE,
                      cms: StateTransferType.TRANSFER_STATE,
                    },
                  },
                },
             }),
          ]})
       export class SpartacusConfigurationModule {}
    2. create module `spartacus-features.module.TS`
       // All module imports like FooterNavigationModule, BreadcrumbModule etc.
    3. create module `spartacus.module.TS`
       // import above modules along with BaseStorefrontModule
       @NgModule({
          declarations: [],
          imports: [SpartacusFeaturesModule, SpartacusConfigurationModule, BaseStorefrontModule],
          exports: [BaseStorefrontModule]
       })
       export class SpartacusModule {}
    
2. app.module.TS
------------------
- Remove default angular module `AppRoutingModule` from import (if added when creating Angular project), else nothing will be displayed.
- import `spartacus.module.TS` that we created above, which had other SPARTACUS modules imported.

3. app.component.HTML
-----------------------
- Entire content is deleted and replaced by a single HTML tag
  <cx-storefront></cx-storefront>
  
NOTE: if missed some config, while creating app, it can be done later too
> ng g @spartacus/schematics:add-pwa                    // adds spartacus-specific PWA module
> ng g @spartacus/schematics:add-ssr                    // adds SSR configuration

NOTE: If not installed particular integration lib / feature lib (package) during initial set up of storefront like
@spartacus/asm | @spartacus/cart | @spartacus/checkout | @spartacus/product | @spartacus/smartedit | @spartacus/styles | @spartacus/user   install later using:
> ng add <package-name>


MODULES / COMPONENTS / LAYOUT
=================================
> ng g m custom-pdp
> ng g c custom-pdp/custom-product-intro

// DO NOT import these feature modules to `APP.MODULE.TS` directly, but
// import them to  `spartacus-features.MODULE.TS` which is imported by  `spartacus.MODULE.TS` which is imported by `APP.MODULE.TS`
// This allows for LAZY-LOADING of modules that is handled by spartacus.

// To use feature components that are available via Spartacus Storefront, they are to be imported.
// `withConfig` defines that it is a CMS component.
// flexType or typeCode value that we receive from backend is used for mapping to our SPARTACUS component
custom-pdp.module.TS
----------------------
@NgModule({
    declarations: [CUSTOM-COMP-NAME],
    imports: [
        CommonModule,
        StarRatingModule,                                // module import from spartacus storefront
        ConfigModule.withConfig({
            cmsComponents: {
                TYPE-CODE-NAME: {
                    component: CUSTOM-COMP-NAME
                }
            }
        } as CmsConfig)
    ]
})
export class CustomPdpModule {}

custom-product-intro.comp.HTML
---------------------------------
<ng-container *ngIf = "product$ | async as product">
    <h1>{{product?.name}}</h1>
    <h3>{{product?.price?.formattedValue}}</h3>
    <cx-star-rating                                     // comp used from spartacus storefront, must be imported in that module
      [rating] = "product?.averageRating"
      [disabled] = "true">
    </cx-star-rating>
</ng-container>

layout-config.TS                    // a custom layout file to be provided to `spartacus-configuration-module.TS`
---------------------               // layouts(TEMPLATE key from pages API) rendered in <CX-PAGE-LAYOUT> and slots(POSITION keys from pages API) in <CX-PAGE-SLOT>
import { LayoutConfig } from '@spartacus/storefront';
export const layoutConfig: LayoutConfig = {                        // some layouts are pre-defined from SPARTACUS like header, navigation, footer
  layoutSlots: {
      header: {                                                    // <cx-page-layout class="header"></cx-page-layout>
        lg: { slots: ['PreHeader', 'SiteLogo', 'SearchBox'] },     // <cx-page-slot  class="PreHeader" position="PreHeader"></cx-page-slot>
        slots: ['PreHeader', 'SearchBox']                             // less than lg breakpoint, these slots will be rendered
      },
      navigation: {                                                // <cx-page-layout class="navigation"></cx-page-layout>
        lg: { slots: ['MegaMenu'] },                               // lg(>=992px), these slots(position vals) will be rendered in <cx-page-slot>
        md: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] },     // md(>=768px)
        sm: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] },     // sm(>=576px)
        xs: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] }      // xs(<576px)
      },
      footer: {                                                    // <cx-page-layout class="footer"></cx-page-layout>
        slots: ['Footer']                                          // <cx-page-slot class="Footer" position="Footer"></cx-page-slot>
      },
      LandingPage2Template: {                                      // <cx-page-layout class="LandingPage2Template"></cx-page-layout>
        lg: {
          pageFold: 'UpSelling',                                   // Above-the-fold loading is an indication to speed up initial creation of slots
                                                                   // pageFold: indicates last page slot that should be rendered above the fold.
                                                                   // and are prioritized ahead of page slots that are “below the fold”/after this slot
          slots: ['Summary', 'UpSelling', 'Section2B']
        },
        pageFold: 'Section2B',
        slots: []
      },
      SearchResultsListPageTemplate: {
        slots: ['SearchDescription', 'SearchResultList']
      }
  }
}
NOTE: Components come from backend side.
An API call , /pages?lang=EN&curr=AUD , gets all components that are used.
Depending on current browser route URL, this API payload's QUERY-PARAMS change:
A. ContentPage  ( Eg: https://HOSTNAME/ROUTE )
   pageType: ContentPage, pageLabelOrId: /ROUTE
B. CategoryPage ( Eg: https://HOSTNAME/Categories/Kids/c/SUBCATEGORY )
   pageType: CategoryPage, code: SUBCATEGORY
C. ProductPage  ( Eg: https://HOSTNAME/Categories/Kids/Nursery/Dreambaby-Bed-Rail/p/PRODUCT-CODE )
   pageType: ProductPage, code: PRODUCT-CODE
It returns:
contentSlots: {
  contentSlot: [
    {
      components: {
          component: [
            {
              uid: "CustomTileWithTextResponsiveBannerComponent",
              typeCode: "FFCMSContainerComponent",                        // typecode or flexType: mapping to custom spartacus component in MODULE file
              flexType: "FFCMSContainerComponent"                         // NOTE: It depends on backend config, which one to use from these two
            }
          ]
      }
      name: "Tile With Text Banner Slot",
      position: "TileWithTextBanner",                                     // position: included in <cx-page-slot> and used in layout-config.TS
      slotId: "TileWithTextBannerSlot",
      slotShared: false,
      slotUuid: "eyJpdG"
    }
  ]
}
label: "search"
name: "Search Results Page"
robotTag: "INDEX_FOLLOW"
template: "SearchResultsListPageTemplate"                               // template: used in <cx-page-layout>
typeCode: "ContentPage"
uid: "search"
uuid: "eyJp==="


ADD COMPONENT/DATA FROM SLOT, INSIDE ANGULAR COMPONENT
=========================================================
1. MODULE.TS                                    // NOTE: import this module, in COMP's MODULE,
--------------                                  // so that COMP-NAME can render when matches [cxComponentWrapper]
@NgModule({
  providers: [
    provideDefaultConfig(<CmsConfig>{
      cmsComponents: {
        TYPE-CODE: {                            // TYPE-CODE is same value as given to  [cxComponentWrapper]  typeCode in COMP.HTML
          component: COMP-NAME,                 // COMP-NAME is component to render, when this typecode matches with [cxComponentWrapper]
        },
      },
    }),
  ],
  declarations: [COMP-NAME],
  exports: [COMP-NAME],
})
export class COMP-NAME-MODULE {}
2. COMP.MODULE.TS
----------------------
import {PageComponentModule} from '@spartacus/storefront';
@NgModule({
    imports: [PageComponentModule, COMP-NAME-MODULE]
})
3. COMP.HTML
---------------
<ng-container *ngIf="component.data$ | async as compData">
  <!-- A. add component using typecode / uid -->
  <ng-container
   [cxComponentWrapper]="{
     flexType: compData?.productBrochure?.typeCode,
     typeCode: compData?.productBrochure?.typeCode,
     uid: compData?.productBrochure?.uid
   }">
  </ng-container>

  <!-- B. add data using key from response -->
  <span>{{ compData?.detailErrorMessage }}</span>
</ng-container>
4. COMP.TS
-------------
constructor(public component: CmsComponentData<CmsTabComponent>)


LAUNCH-DIALOG SERVICE (POPUP/MODAL/DIALOG)
=============================================
1. MODEL.TS
--------------
import '@spartacus/storefront';
declare module '@spartacus/storefront' {
  const enum LAUNCH_CALLER {
    FABRIC_SELECT = 'FABRIC_SELECT',
    NEAREST_STORES = 'NEAREST_STORES'
  }
}
2. MODULE.TS
---------------
export const defaultLaunchConfig: LayoutConfig = {
  launch: {
    [LAUNCH_CALLER.FABRIC_SELECT]: {
      inlineRoot: true,                          // Renders component directly inside <cx-storefront>, i.e. a global dialog
      component: PopupComponent_1,               // component to render
      dialogType: DIALOG_TYPE.DIALOG,            // POPOVER(no backdrop) | POPOVER_CENTER_BACKDROP(backdrop) | DIALOG(backdrop) | SIDEBAR_START | SIDEBAR_END
    },
    [LAUNCH_CALLER.NEAREST_STORES]: {
      inlineRoot: true,
      component: PopupComponent_2,
      dialogType: DIALOG_TYPE.DIALOG,
    }
}};
@NgModule({
  declarations: [],
  imports: [],
  providers: [provideDefaultConfig(defaultLaunchConfig)],
})
3. COMP.TS
-------------
import { LaunchDialogService, LAUNCH_CALLER } from '@spartacus/storefront';
@ViewChild('NearestStoreModalOpen') private dialogTriggerRef!: ElementRef;
constructor(private launchDialogService: LaunchDialogService) {}
A.
this.launchDialogService.openDialogAndSubscribe(LAUNCH_CALLER.NEAREST_STORES, this.dialogTriggerRef, {
  data_key_1: data_value_1,
  data_key_2: data_value_2
});
B.
this.launchDialogService.dialogClose.pipe(takeUntil(this.destroyed$)).subscribe((data: any) => {
  // TODO: data received from .popup.comp.TS on closing dialog
});
4. POPUP.COMP.TS
------------------
A.
this.launchDialogService.data$.pipe(takeUntil(this.destroyed$)).subscribe((data: any) => {
  // TODO: data received from .comp.TS on opening dialog
});
B.
this.launchDialogService.closeDialog({
  data_key_1: data_value_1,
  data_key_2: data_value_2
});


GLOBAL MESSAGE SERVICE (BANNER MESSAGE SHOWN AT TOP)
=========================================================
1. STYLES.SCSS
--------------------
cx-global-message {
  z-index: 999999;
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
}
2. COMP.TS
---------------------
import { GlobalMessageService, GlobalMessageType } from '@spartacus/core';
constructor(private globalMsgService: GlobalMessageService) {}
A.
this.globalMsgService.add(
  'MSG-STRING' || { key: 'KEY-FROM-TRANSLATIONS-FILE' },
  GlobalMessageType.MSG_TYPE_CONFIRMATION,                         // MSG_TYPE_CONFIRMATION | MSG_TYPE_ERROR | MSG_TYPE_INFO | MSG_TYPE_WARNING
  3000                                                             // Timeout in milliseconds
);
B.
this.globalMsgService.remove(GlobalMessageType.MSG_TYPE_ERROR);    // Remove message


PAGINATION WIDGET
========================
1. MODULE.TS
-----------------
import {ListNavigationModule} from '@spartacus/storefront';
@NgModule({
    imports: [ListNavigationModule]
})
2. COMP.HTML
-----------------
<div *ngIf="(searchResult.pagination?.totalPages ?? 0) > 1">
    <cx-pagination [pagination]="searchResult.pagination" queryParam="currentPage" [defaultPage]="0"></cx-pagination>
</div>
3. COMP.TS
------------------
this.searchResult = data;                // data from API response of /search , it will have
                                         // object "pagination": {"currentPage": 1,"pageSize": 24,"sort": "clear","totalPages": 3,"totalResults": 60}

INFINITE SCROLL
=========================
REFERENCE: https://help.sap.com/docs/SAP_COMMERCE_COMPOSABLE_STOREFRONT/eaef8c61b6d9477daf75bff9ac1b7eb4/d37bd1496c6c42d5b7a17740ba155e94.html
           https://microlearning.opensap.com/media/Infinite+Scroll+-+SAP+Commerce+Cloud/1_crd2801x
When infinite scroll is enabled in composable storefront, it applies to product search page, as well as category pages in both list and grid views.
When infinite scroll is disabled, composable storefront uses pagination instead. By default, infinite scroll is disabled in composable storefront.
1. APP.MODULE.TS
----------------------
imports: [
    ConfigModule.withConfig({
        view: {
            infiniteScroll: {
                active: true,             // enable / disable infinite scroll , auto loads without any limit/button until products are not found
                productLimit: 50,         // number of products user can scroll through before they are prompted to load more items using SHOW MORE button
                showMoreButton: false,    // true: auto sets "productLimit": 10  i.e. value for productLimit key is ignored | false: productLimit key considered
            },
        },
    })
]


SPINNER WIDGET (LOADER)
===========================
1. loader.MODULE.TS                                            // import this module in `APP.MODULE.TS`
----------------------
import { SpinnerModule } from '@spartacus/storefront';
@NgModule({
  declarations: [LoaderOverlayComponent],
  imports: [SpinnerModule],
  exports: [LoaderOverlayComponent],
})
export class LoaderOverlayModule { }
2. loader.COMP.HTML
-----------------------
<div class="spinner-wrapper" (click)="overlayClick($event)">
  <div class="cx-spinner">
    <cx-spinner></cx-spinner>
  </div>
</div>
3. loader.COMP.TS
-----------------------
overlayClick(evt: Event) {
  evt.preventDefault();
  evt.stopPropagation();
}
4. loader.SERVICE.TS                                            // Inject this loaderService in constructor of any component and use   .show() | .hide()
-----------------------
export class LoaderService {
  public loader$: BehaviorSubject<boolean>  = new BehaviorSubject<boolean>(true);
  show(): void {
    this.loader$.next(true);
  }
  hide(): void {
    this.loader$.next(false);
  }
}
5. APP.COMP.HTML
---------------------
<ff-loader-overlay *ngIf="loading"></ff-loader-overlay>
<cx-storefront></cx-storefront>
6. APP.COMP.TS
---------------------
import { RoutingService } from '@spartacus/core';
constructor(private routingService: RoutingService, private loaderService: LoaderService) { }
this.loaderService.loader$.pipe(takeUntil(this.destroyed$)).subscribe((loading: boolean) => {
    this.loading = loading;
    this.cd.markForCheck();
});
this.routingService.isNavigating().pipe(takeUntil(this.destroyed$)).subscribe((nav: boolean) => {
    if(nav) {
        this.loaderService.show();
    } else {
        this.loaderService.hide();
    }
});


TRANSLATION SERVICE
=========================
1. MODULE.TS
--------------
import { I18nModule } from '@spartacus/core';
imports: [I18nModule]
export class COMP-MODULE {}
2. appTranslations.TS                                 // file configured in `spartacus-configuration.MODULE.TS`
------------------------
export const appTranslations = {
    en: {
        HEADER: {                                     // NOTE: same HEADER name inside HEADER
            HEADER: {
                KEY_1: 'VAL_1',
                KEY_2: 'VAL_2 {{VARIABLE}} VAL_2',    // NOTE: use of VARIABLE in {{ }}
            }
        }
    }
}
3.A. COMP.TS
----------------
import { TranslationService } from '@spartacus/core';
constructor(private translationService: TranslationService) { }
this.translationService.translate('HEADER.KEY_1').pipe(first()).subscribe((tData) => { this.val = tData; });
this.translationService.translate('HEADER.KEY_2', {VARIABLE: VAL-OF-VARIABLE}).pipe(first()).subscribe((tData) => { this.val = tData; });
OR
3.B. COMP.HTML
----------------
{{ 'HEADER.KEY_1' | cxTranslate }}
{{ 'HEADER.KEY_2' | cxTranslate: {VARIABLE: VAL-OF-VARIABLE} }}


BASESITE SERVICE
=========================
A.
On website initial load, a GET API call is made to `/basesites` i.e. `https://BASE-URL/PREFIX/basesites?fields=FULL&lang=en&curr=USD`
This is handled by spartacus default url mapping, however, we can specify key `baseSites` inside ENDPOINTS.CONST.TS file(spartacus-configuration.MODULE.TS) i.e.
    backend: { occ: { endpoints: { baseSites: 'basesites?fields=FULL' } } }
It returns all basesite related config and our application can use values depending on UID of basesite data.
B.
import { BaseSiteService } from '@spartacus/core';
constructor(private baseSiteService: BaseSiteService) { }
public showReviewsWidget: boolean = false;
private activeSiteUID: string = '';
this.baseSiteService.get().pipe(takeUntil(this.destroyed$)).subscribe((baseSite) => {
    this.showReviewsWidget = (baseSite as BASESITE-INTERFACE).KEY-FROM-BASESITE;
    this.activeSiteUID = baseSite?.uid ?? '';
});


CMS SERVICE
==========================
import { CmsService, Page } from '@spartacus/core';
constructor(private cmsService: CmsService) { }
public pageData!: Page;
this.cmsService.getCurrentPage().pipe(takeUntil(this.destroyed$)).subscribe((data) => {
    this.pageData = data;
});
this.pageData?.template === PageTemplateENUM.VALUE-FROM-PAGES-API-TEMPLATE;


ROUTING
==============
Many routes are built-in with SPARTACUS, and render templates accordingly.
However, we can create CUSTOM routes too.
1. APP.MODULE.TS
-------------------
imports: [
    ConfigModule.withConfig({
      routing: {
        routes: {
          FE_PATH_1: { paths: ['BACKEND_PATH_FOR_PAGE_1'] },
          FE_PATH_2: { paths: ['BACKEND_PATH_FOR_PAGE_2'] },
        }
      }
    })
]
2. SPARTACUS-FEATURES.MODULE.TS
----------------------------------
imports: [
    CUSTOM_MODULE_1,
    CUSTOM_MODULE_2
]
3. COMP.TS
-------------------
import { RoutingService } from '@spartacus/core';
constructor(private routingService: RoutingService) {}
navigateFabricSamples() {
    this.routingService.go({
      cxRoute: 'FE_PATH_2',
    });
}


ROUTE GUARDS
===========================
It is similar to Angular route guards i.e. guard is a service which has canActivate() etc. methods, only difference is how we include these guards.
In Spartacus, it is added with config for mapping components, plus provide builtin guards like    AuthGuard | CheckoutDetailsLoadedGuard | CartNotEmptyGuard
ConfigModule.withConfig({
    cmsComponents: {
        TYPE-CODE: {
            component: FE-COMPONENT,
            guards: [CUSTOM-CheckoutAuthGuard, CartNotEmptyGuard]
        }
    }
})


HTTP REQUESTS (services)
===========================
1. SERVICE.TS
----------------
import { OccEndpointsService, OCC_USER_ID_ANONYMOUS } from '@spartacus/core';
readonly defaultUserId = OCC_USER_ID_ANONYMOUS;                                            // OCC_USER_ID_CURRENT | OCC_USER_ID_ANONYMOUS | OCC_USER_ID_GUEST
constructor(public httpClient: HttpClient, public occEndpointsService: OccEndpointsService) { }
A.
serviceMethod() {
  const url = this.occEndpointsService.buildUrl('KEY-FROM-ENDPOINTS-CONFIG-FILE', {       // eg:'KEY_2' , file configured in `spartacus-configuration.MODULE.TS`
    urlParams: {
      PARAM_1: this.defaultUserId,                                                        // variables in URL i.e. ${PARAM_1}
      PARAM_2: VAL_2,
    }
  });
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
OR
B.
serviceMethod() {
  const endpointURL = storeEndpoints.endpointURL_2;
  const url = this.occEndpointsService.buildUrl(endpointURL, {                           // NOTE: no use of '', because it is URL and not KEY
    urlParams: {
      PARAM_1: this.defaultUserId,
      PARAM_2: VAL_2,
    }
  });
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
OR
C.
serviceMethod() {
  const baseUrl = this.occEndpointsService.getBaseUrl();                                                    // baseUrl + prefix + baseSite from occ service
  const baseUrl = this.occEndpointsService.getBaseUrl({ baseUrl: true, prefix: false, baseSite: false });   // specified `false` for value that is not required
  const url = `${this.baseUrl}/users/${this.defaultUserId}/carts/${cartID}/findStore`;
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
2. ENDPOINTS.CONST.TS
------------------------
// NOTE: This file is configured in `spartacus-configuration.MODULE.TS`
// NOTE: If KEY is NOT found from here, it is referred from configs from SPARTACUS builtin like `defaultOccCartConfig`
export const storeEndpoints = {
  backend: {
    occ: {
      endpoints: {
        KEY_1: 'basesites?fields=FULL',
        KEY_2: 'users/${PARAM_1}/carts/${PARAM_2}?fields=FULL'
      },
    },
  },
  endpointURL_1: 'payment-token',
  endpointURL_2: 'users/${PARAM_1}/orders?cartId=${cartid}&fields=FULL'
};


CART SERVICES
===================
import { ActiveCartService, UserIdService, MultiCartService } from '@spartacus/core';
constructor(private activeCartService: ActiveCartService,
            private userIdService: UserIdService,
            private multiCartService: MultiCartService) {}
A.
// Create new cart if not exists by calling API, else return existing cart (REFER: localstorage of browser for cartID)
this.activeCartService.requireLoadedCart().pipe(
    concatMap((cartState) => {
        return this.SERVICE.HTTP-SERVICE-METHOD(cartState?.value?.code ?? '');
    })
).pipe(takeUntil(this.unsubscribe$)).subscribe((data: any) => {
    // TODO: SUCCESS OF HTTP-SERVICE-METHOD
}, (err: Error) => {
    // TODO: ERROR OF HTTP-SERVICE-METHOD
});
B.1.
// Subscribe to any cart related changes and get cart data
this.activeCartService.getActive().pipe(takeUntil(this.unsubscribe$)).subscribe((cart: CART-TYPE) => {
  this.cartID = cart?.guid || cart?.code;
  this.cdRef.markForCheck();
});
B.2.
// Reload/Refresh cart at app level by calling API, to have changes if any reflected in getActive() cart subscription (REFER: B.1. point)
// Eg: A product is added to cart, and we need some UI change depending on updated cart data after this product is added to cart.
this.reloadSub = combineLatest([
    this.userIdService.getUserId().pipe(take(1)), this.activeCartService.getActiveCartId().pipe(take(1))
]).subscribe(([userId, cartId]: [string, string]) => {
      if (cartId && userId) {
        this.multiCartService.loadCart({
          userId,
          cartId,
          extraData: {
            active: true,
          },
        });
        if (this.reloadSub) {
          this.reloadSub.unsubscribe();
        }
      }
});
C.
// Cart can be updated using builtin endpoint KEYS like 'addEntries', 'updateEntries', 'removeEntries' from defaultOccCartConfig of spartacus
// i.e. we need NOT to specify URL endpoints in the endpoints file provided in `spartacus-configuration.MODULE.TS`
// Other KEYS and URLs value and what all path params (urlParams) it expects, can be checked from spartacus code repo.
const url = this.occEndpointsService.buildUrl('updateEntries', {
    urlParams: {
        userId: this.defaultUserId,
        cartId: CART_ID,
        entryNumber: ENTRY_NUMBER,
    }
});
D.
// A cart and all it's associated data is deleted from BackOffice/HAC, depending on GUID or CODE


LOGIN / LOGOUT SERVICES
=============================
import {AuthService} from '@spartacus/core';
constructor(protected auth: AuthService) { }
A.
API call: POST | URL: https://BASE-URL-public.model-t.cc.commerce.ondemand.com/authorizationserver/oauth/token
          REQUEST BODY: {username, password} | RESPONSE: {access_token:'', refresh_token:'', expires_in:'', token_type:'', scope:''}
Redirect to: `` on successful login
from(this.auth.loginWithCredentials(email.toLowerCase(), password)).pipe(        // backend accepts lowercase emails only
    withLatestFrom(this.auth.isUserLoggedIn()),
    tap(([_, isLoggedIn]) => {
        if (isLoggedIn) {
            this.globalMsgService.remove(GlobalMessageType.MSG_TYPE_ERROR);      // Remove error message on successful login (bad username/password combination)
        }
        this.cd.markForCheck();
    })
).subscribe((res) => {}, (err) => {});
B.
API call: POST | URL: https://BASE-URL-public.model-t.cc.commerce.ondemand.com/authorizationserver/oauth/revoke
          REQUEST BODY: {baseSite:'', token_type_hint:'', token:''} | RESPONSE: NA
Redirect to: `/login` on successful logout
this.auth.logout();


NORMALIZERS
===============
Normalizers are used for data mapping that suits requirement of project.
Here in this example, seoTitle and description of page is modified, which is useful for SEO.
1. APP.MODULE.TS
--------------------
{ provide: CMS_PAGE_NORMALIZER, useClass: CUSTOM-PageNormalizer, multi: true }
2. CUSTOM-PageNormalizer.TS
-------------------------------
import { Converter } from '@spartacus/core';
@Injectable({ providedIn: 'root' })
export class CUSTOM-PageNormalizer implements Converter<CmsPage, CmsStructureModel> {
  convert(source: CmsPage, target: CmsStructureModel = {}): CmsStructureModel {
    return { ...target, page: {...target.page, description: source.description, seoTitle: source.seoTitle} };
  }
}


PAGE META RESOLVERS
======================
These allow for adding/changing page meta data like title, description, canonical url etc. , which is useful for SEO
1. APP.MODULE.TS
---------------------
{ provide: SeoMetaService, useExisting: CUSTOM-SeoService },
{ provide: PageMetaService, useExisting: CUSTOM-PageMetaService },
{ provide: ProductPageMetaResolver, useExisting: CUSTOM-ProductPageMetaResolver },
{ provide: PageMetaResolver, useExisting: CUSTOM-CategoryPageMetaResolver, multi: true },
{ provide: PageMetaResolver, useExisting: CUSTOM-DepartmentPageMetaResolver, multi: true },
{ provide: SearchPageMetaResolver, useExisting: CUSTOM-SearchPageMetaResolver }
2. CUSTOM-RESOLVERS.TS
-------------------------
NOTE: For CUSTOM-RESOLVERS implementations defined in `useExisting`, refer SPARTACUS DEMO-CODE REPO, cloned from GITHUB
Eg:
A. resolveTitle(): Observable<string> {
    return this.categoryItem$.pipe(
      switchMap((c: CategoryItem) =>
        of(c?.seoTitle ? c?.seoTitle : c?.categoryCode ? c?.categoryCode : '')));
   }
B. resolveDescription(): Observable<string> {
    return this.productData$.pipe(
      switchMap((product) =>
        this.translation.translate('pageMetaResolver.product.description', {
          description: product.metaDescription,
        })));
   }
C. resolveCanonicalUrl(): Observable<string> {
    return combineLatest([this.baseSiteService.get(), this.product$]).pipe(
      map(([baseSite, product]) => {
        const baseUrl = (baseSite as any).configMap.entry.find(
          (obj: any) => obj.key === 'canonicalBaseUrl'
        ).value;
        const url = `${baseUrl}${product.url}`;
        return this.pageLinkService.getCanonicalUrl({}, url);}));
   }


STYLES
===============
A. SPARTA LIB + MIXINS
-------------------------
Spartacus provides default styling library called Sparta in the @spartacus/styles package.
This package should be imported into project through the `styles.scss` file.
src/styles.scss
------------------
$primary: #e502bf                                                          // if any new value to scss variables, has to be re-assigned.
$font-weight-normal: 500;                                                  // this is done before Sparta library import.
@import '@spartacus/styles/scss/cxbase/mixins';

B. BREAKPOINT SERVICE
-------------------------
Spartacus provides BreakpointService, which allows same control as media queries, within TS files.
It is better to use as it responds to resize event.
Create a `responsive.SERVICE.TS` file, that can be injected in any COMPONENT.
import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
import { WindowRef } from '@spartacus/core';
import { BREAKPOINT, BreakpointService, LayoutConfig } from '@spartacus/storefront';
import { Observable } from 'rxjs';
@Injectable({
  providedIn: 'root',
})
export class ResponsiveService extends BreakpointService {
  constructor(protected winRef: WindowRef, layoutConfig: LayoutConfig, @Inject(PLATFORM_ID) platform: any) {
    super(winRef, layoutConfig, platform);
  }
  isMobile$: Observable<boolean> = this.isDown(BREAKPOINT.sm);  // when referring DOWN, it picks up limit of next breakpoint, here sm < 768px
  isDesktop$: Observable<boolean> = this.isUp(BREAKPOINT.lg);   // when referring UP, it picks up limit of same breakpoint, here lg >= 992px
}


