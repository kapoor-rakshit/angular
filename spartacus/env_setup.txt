Spartacus is Angular-based JavaScript storefront for SAP Commerce Cloud.
Spartacus talks to SAP Commerce Cloud exclusively through the Commerce REST API.
Starting with version 5.0, “SAP Commerce Cloud, Composable Storefront” is name for official release of project “Spartacus” libraries published by SAP.

Spartacus Code Repo, must be cloned on development machine, to have reference for builtin core features like cart, search etc.
GITHUB REPO: https://github.com/SAP/spartacus
REFERENCE  : https://help.sap.com/docs/SAP_COMMERCE_COMPOSABLE_STOREFRONT/cfcf687ce2544bba9799aa6c8314ecd0/e38d45609de04412920a7fc9c13d41e3.html

Storefront Version
REFERENCE: https://github.com/SAP/spartacus#requirements
For which version of    Node, Angular, Yarn, NPM    to use with Spartacus(Composable Storefront) version, refer above website

SmartEdit
REFERENCE: https://help.sap.com/docs/SAP_COMMERCE_CLOUD_PUBLIC_CLOUD/e1391e5265574bfbb56ca4c0573ba1dc/dc259a9f232a469ca8da3cf22f34839c.html

HAC (Hybris Administrative Console or BackOffice Admin Console)
It is for administrator to handle entire functions and operations in website like:
ImpEx (Import-Export), Groovy Script, Configuration, Cache, Cron Job
    Use-Case-1: CORS issue: Check property 'allowedHeaders' through HAC , delete web application services for CORS , rerun CORS impex

To install composable storefront, need to set up access to composable storefront libraries in Repository Based Shipment Channel (RBSC)
    RBSC website: https://ui.repositories.cloud.sap/www/webapp/users/
    Create an S-user for RBSC that has the appropriate licenses to download the composable storefront libraries.
    An S-user account can see Composable Storefront License in list of licenses.
    If the Composable Storefront License does not appear in this list, there will be an error when downloading the packages.
    Click on Add User and create a technical user.
    In User Management tab of RBSC website, select the technical user and copy the generated NPM Base64 Credentials, required for .npmrc file in project

SETUP
=============
> ng new <APP_NAME> --style=scss --routing=false
> cd <APP_NAME>
> create an .npmrc file with following content | NOTE: // in second line | NOTE: NPM-CREDENTIALS-FROM-RBSC copied as in above steps
      @spartacus:registry=https://73554900100900004337.npmsrv.base.repositories.cloud.sap/
      //73554900100900004337.npmsrv.base.repositories.cloud.sap/:_auth=NPM-CREDENTIALS-FROM-RBSC
      always-auth=true
> ng add @spartacus/schematics@VERSION --baseUrl <BACKEND_URL> --baseSite=<CONFIG> --ssr --pwa
      --baseUrl: url of backend
      --baseSite: name of storefront
      --ssr: enable SSR features of app
      --pwa: enable PWA features of app
  OR
  ng update @spartacus/schematics@VERSION         // After update is done, inspect your code for comments that begin with TODO:Spartacus
> check `package.json` for correct version of @spartacus libs and
  delete node_modules(if already exists) and then run:
  npm install

1. It creates a directory named `spartacus` and inside it:
    1. creates module `spartacus-configuration.module.TS`
       // This will have all configs for spartacus like baseUrl, baseSite etc.
       @NgModule({
          declarations: [],
          imports: [],
          providers: [
             provideConfig(layoutConfig),               // custom page layout config file
             provideConfig(mediaConfig),                // media config file for images
             provideConfig({                            // image loading strategy
                imageLoadingStrategy: ImageLoadingStrategy.LAZY,
             } as MediaConfig),
             provideConfig(<OccConfig>{                 // base URL config
                backend: {
                  occ: {
                    baseUrl: environment.occBaseUrl,
                  },
                },
             }),
             provideConfig(<OccConfig>storeEndpoints),  // endpoints config file for OccEndpointsService
             provideConfig(<SiteContextConfig>{         // base SITE config
                context: {
                   currency: ['AUD'],
                   language: ['en'],
                   baseSite: ['PROJECT_NAME-spa'],
                },
             }),
             provideConfig(<I18nConfig>{
                i18n: { resources: myTranslations },   // translations config file

                state: {                               // Spartacus runs XHR requests on server, and then again on client-side when application bootstraps.
                  ssrTransfer: {                       // Spartacus includes part of the NgRx state with the server-side rendered HTML
                    keys: {                            // This prevent unnecessary calls to back end for state that was already populated on server,
                      products: StateTransferType.TRANSFER_STATE,
                      cms: StateTransferType.TRANSFER_STATE,
                    },
                  },
                },
             }),
          ]})
       export class SpartacusConfigurationModule {}
    2. create module `spartacus-features.module.TS`
       // All module imports like FooterNavigationModule, BreadcrumbModule etc.
    3. create module `spartacus.module.TS`
       // import above modules along with BaseStorefrontModule
       @NgModule({
          declarations: [],
          imports: [SpartacusFeaturesModule, SpartacusConfigurationModule, BaseStorefrontModule],
          exports: [BaseStorefrontModule]
       })
       export class SpartacusModule {}
    
2. app.module.TS
------------------
- Remove default angular module `AppRoutingModule` from import (if added when creating Angular project), else nothing will be displayed.
- import `spartacus.module.TS` that we created above, which had other SPARTACUS modules imported.

3. app.component.HTML
-----------------------
- Entire content is deleted and replaced by a single HTML tag
  <cx-storefront></cx-storefront>
  
NOTE: if missed some config, while creating app, it can be done later too
> ng g @spartacus/schematics:add-pwa                    // adds spartacus-specific PWA module
> ng g @spartacus/schematics:add-ssr                    // adds SSR configuration

NOTE: If not installed particular integration lib / feature lib (package) during initial set up of storefront like
@spartacus/cart | @spartacus/checkout | @spartacus/product | @spartacus/smartedit | @spartacus/styles | @spartacus/user   install later using:
> ng add <package-name>


MODULES / COMPONENTS / LAYOUT
=================================
> ng g m custom-pdp
> ng g c custom-pdp/custom-product-intro

// DO NOT import these feature modules to `APP.MODULE.TS` directly, but
// import them to  `spartacus-features.MODULE.TS` which is imported by  `spartacus.MODULE.TS` which is imported by `APP.MODULE.TS`
// This allows for LAZY-LOADING of modules that is handled by spartacus.

// To use feature components that are available via Spartacus Storefront, they are to be imported.
// `withConfig` defines that it is a CMS component.
// flexType or typeCode value that we receive from backend is used for mapping to our SPARTACUS component
custom-pdp.module.TS
----------------------
@NgModule({
    declarations: [CUSTOM-COMP-NAME],
    imports: [
        CommonModule,
        StarRatingModule,                                // module import from spartacus storefront
        ConfigModule.withConfig({
            cmsComponents: {
                TYPE-CODE-NAME: {
                    component: CUSTOM-COMP-NAME
                }
            }
        } as CmsConfig)
    ]
})
export class CustomPdpModule {}

custom-product-intro.comp.HTML
---------------------------------
<ng-container *ngIf = "product$ | async as product">
    <h1>{{product?.name}}</h1>
    <h3>{{product?.price?.formattedValue}}</h3>
    <cx-star-rating                                     // comp used from spartacus storefront, must be imported in that module
      [rating] = "product?.averageRating"
      [disabled] = "true">
    </cx-star-rating>
</ng-container>

layout-config.TS                                       // a custom layout file to be provided to `spartacus-configuration-module.TS`
---------------------                                  // layouts are rendered in <CX-PAGE-LAYOUT> and slots(POSITION keys from backend) in <CX-PAGE-SLOT>
import { LayoutConfig } from '@spartacus/storefront';
export const layoutConfig: LayoutConfig = {
  layoutSlots: {
      header: {                                                    // <cx-page-layout class="header"></cx-page-layout>
        lg: { slots: ['PreHeader', 'SiteLogo', 'SearchBox'] },     // <cx-page-slot  class="PreHeader" position="PreHeader"></cx-page-slot>
        slots: ['PreHeader', 'SearchBox']                             // less than lg breakpoint, these slots will be rendered
      },
      navigation: {                                                // <cx-page-layout class="navigation"></cx-page-layout>
        lg: { slots: ['MegaMenu'] },                               // lg(>=992px), these slots(position vals) will be rendered in <cx-page-slot>
        md: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] },     // md(>=768px)
        sm: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] },     // sm(>=576px)
        xs: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] }      // xs(<576px)
      },
      footer: {                                                    // <cx-page-layout class="footer"></cx-page-layout>
        slots: ['Footer']                                          // <cx-page-slot class="Footer" position="Footer"></cx-page-slot>
      },
      LandingPage2Template: {                                      // <cx-page-layout class="LandingPage2Template"></cx-page-layout>
        lg: {
          pageFold: 'UpSelling',                                   // Above-the-fold loading is an indication to speed up initial creation of slots
                                                                   // pageFold: indicates last page slot that should be rendered above the fold.
                                                                   // and are prioritized ahead of page slots that are “below the fold”/after this slot
          slots: ['Summary', 'UpSelling', 'Section2B']
        },
        pageFold: 'Section2B',
        slots: []
      },
      SearchResultsListPageTemplate: {
        slots: ['SearchDescription', 'SearchResultList']
      }
  }
}

NOTE: Components come from backend side.
An API call , /pages?lang=EN&curr=AUD , gets all components that are used. It returns:
contentSlots: {
  contentSlot: [
    {
      components: {
          component: [
            {
              uid: "CustomTileWithTextResponsiveBannerComponent",
              typeCode: "FFCMSContainerComponent",                        // typecode or flexType: mapping to custom spartacus component in MODULE file
              flexType: "FFCMSContainerComponent"                         // NOTE: It depends on backend config, which one to use from these two
            }
          ]
      }
      name: "Tile With Text Banner Slot",
      position: "TileWithTextBanner",                                     // position: included in <cx-page-slot> and used in layout-config.TS
      slotId: "TileWithTextBannerSlot",
      slotShared: false,
      slotUuid: "eyJpdG"
    }
  ]
}
label: "search"
name: "Search Results Page"
robotTag: "INDEX_FOLLOW"
template: "SearchResultsListPageTemplate"                               // template: used in <cx-page-layout>
typeCode: "ContentPage"
uid: "search"
uuid: "eyJp==="


ADD COMPONENT/DATA FROM SLOT, INSIDE ANGULAR COMPONENT
=========================================================
1. MODULE.TS                                    // NOTE: import this module, in COMP's MODULE,
--------------                                  // so that COMP-NAME can render when matches [cxComponentWrapper]
@NgModule({
  providers: [
    provideDefaultConfig(<CmsConfig>{
      cmsComponents: {
        TYPE-CODE: {                            // TYPE-CODE is same value as given to  [cxComponentWrapper]  typeCode in COMP.HTML
          component: COMP-NAME,                 // COMP-NAME is component to render, when this typecode matches with [cxComponentWrapper]
        },
      },
    }),
  ],
  declarations: [COMP-NAME],
  exports: [COMP-NAME],
})
export class COMP-NAME-MODULE {}
2. COMP.HTML
---------------
<ng-container *ngIf="component.data$ | async as compData">
 <!-- A. add component using typecode / uid -->
 <ng-container
   [cxComponentWrapper]="{
     flexType: compData?.productBrochure?.typeCode,
     typeCode: compData?.productBrochure?.typeCode,
     uid: compData?.productBrochure?.uid
    }">
 </ng-container>

 <!-- B. add data using key from response -->
 <span>{{ compData?.detailErrorMessage }}</span>
</ng-container>
3. COMP.TS
-------------
constructor(public component: CmsComponentData<CmsTabComponent>)


LAUNCH-DIALOG SERVICE (POPUP/MODAL/DIALOG)
=============================================
1. .MODEL.TS
--------------
import '@spartacus/storefront';
declare module '@spartacus/storefront' {
  const enum LAUNCH_CALLER {
    FABRIC_SELECT = 'FABRIC_SELECT',
    NEAREST_STORES = 'NEAREST_STORES'
  }
}
2. .MODULE.TS
---------------
export const defaultLaunchConfig: LayoutConfig = {
  launch: {
    [LAUNCH_CALLER.FABRIC_SELECT]: {
      inlineRoot: true,
      component: PopupComponent_1,
      dialogType: DIALOG_TYPE.DIALOG,
    },
    [LAUNCH_CALLER.NEAREST_STORES]: {
      inlineRoot: true,
      component: PopupComponent_2,
      dialogType: DIALOG_TYPE.DIALOG,
    }
}};
@NgModule({
  declarations: [],
  imports: [],
  providers: [provideDefaultConfig(defaultLaunchConfig)],
})
3. .COMP.TS
-------------
import { LaunchDialogService, LAUNCH_CALLER } from '@spartacus/storefront';
@ViewChild('NearestStoreModalOpen') private dialogTriggerRef!: ElementRef;
constructor(private launchDialogService: LaunchDialogService) {}
A.
this.launchDialogService.openDialogAndSubscribe(LAUNCH_CALLER.NEAREST_STORES, this.dialogTriggerRef, {
  data_key_1: data_value_1,
  data_key_2: data_value_2
});
B.
this.launchDialogService.dialogClose.pipe(takeUntil(this.destroyed$)).subscribe((data: any) => {
  // TODO: data received from .popup.comp.TS on closing dialog
});
4. .POPUP.COMP.TS
------------------
A.
this.launchDialogService.data$.pipe(takeUntil(this.destroyed$)).subscribe((data: any) => {
  // TODO: data received from .comp.TS on opening dialog
});
B.
this.launchDialogService.closeDialog({
  data_key_1: data_value_1,
  data_key_2: data_value_2
});


GLOBAL MESSAGE SERVICE (BANNER MESSAGE SHOWN AT TOP)
=========================================================
import { GlobalMessageService, GlobalMessageType } from '@spartacus/core';
constructor(private globalMsgService: GlobalMessageService) {}
this.globalMsgService.add(
  'MSG-STRING' || { key: 'KEY-FROM-TRANSLATIONS-FILE' },
  GlobalMessageType.MSG_TYPE_CONFIRMATION                         // MSG_TYPE_CONFIRMATION | MSG_TYPE_ERROR | MSG_TYPE_INFO | MSG_TYPE_WARNING
);


PAGINATION WIDGET
========================
1. MODULE.TS
-----------------
import { GenericLinkModule, IconModule, ListNavigationModule, PageComponentModule } from '@spartacus/storefront';
@NgModule({
    imports: [
        PageComponentModule
    ]
})
export class MyPLPModule {}
2. COMP.HTML
-----------------
<div *ngIf="(searchResult.pagination?.totalPages ?? 0) > 1">
    <cx-pagination [pagination]="searchResult.pagination" queryParam="currentPage" [defaultPage]="0"></cx-pagination>
</div>
3. COMP.TS
------------------
this.searchResult = data;                // data from API response of /search , it will have
                                         // object "pagination": {"currentPage": 1,"pageSize": 24,"sort": "clear","totalPages": 3,"totalResults": 60}

INFINITE SCROLL
=========================
REFERENCE: https://help.sap.com/docs/SAP_COMMERCE_COMPOSABLE_STOREFRONT/eaef8c61b6d9477daf75bff9ac1b7eb4/d37bd1496c6c42d5b7a17740ba155e94.html
When infinite scroll is enabled in composable storefront, it applies to product search page, as well as category pages in both list and grid views.
When infinite scroll is disabled, composable storefront uses pagination instead. By default, infinite scroll is disabled in composable storefront.
1. APP.MODULE.TS
----------------------
imports: [
    ConfigModule.withConfig({
        view: {
            infiniteScroll: {
                active: true,             // enable / disable infinite scroll
                productLimit: 50,         // number of products user can scroll through before they are prompted to load more items using SHOW MORE button
                showMoreButton: false,    // true: sets "productLimit" : 10  i.e. value for productLimit key is ignored  |  false: productLimit key considered
            },
        },
    })
]


BASESITE SERVICE
=========================
import { BaseSiteService } from '@spartacus/core';
constructor(private baseSiteService: BaseSiteService) { }
public showReviewsWidget: boolean = false;
private activeSiteUID: string = '';
this.baseSiteService.get().pipe(takeUntil(this.destroyed$)).subscribe((baseSite) => {
    this.showReviewsWidget = (baseSite as BASESITE-INTERFACE).KEY-FROM-BASESITE;
    this.activeSiteUID = baseSite?.uid ?? '';
});


CMS SERVICE
==========================
import { CmsService, Page } from '@spartacus/core';
constructor(private cmsService: CmsService) { }
public pageData!: Page;
this.cmsService.getCurrentPage().pipe(takeUntil(this.destroyed$)).subscribe((data) => {
    this.pageData = data;
});
this.pageData?.template === PageTemplateENUM.VALUE-FROM-PAGES-API-TEMPLATE;


ROUTING
==============
Many routes are built-in with SPARTACUS, and render templates accordingly.
However, we can create CUSTOM routes too.
1. APP.MODULE.TS
-------------------
imports: [
    ConfigModule.withConfig({
      routing: {
        routes: {
          FE_PATH_1: { paths: ['BACKEND_PATH_FOR_PAGE_1'] },
          FE_PATH_2: { paths: ['BACKEND_PATH_FOR_PAGE_2'] },
        }
      }
    })
]
2. SPARTACUS-FEATURES.MODULE.TS
----------------------------------
imports: [
    CUSTOM_MODULE_1,
    CUSTOM_MODULE_2
]
3. COMP.TS
-------------------
import { RoutingService } from '@spartacus/core';
constructor(private routingService: RoutingService) {}
navigateFabricSamples() {
    this.routingService.go({
      cxRoute: 'FE_PATH_2',
    });
}


HTTP REQUESTS (services)
===========================
1. SERVICE.TS
----------------
import { OccEndpointsService, OCC_USER_ID_ANONYMOUS } from '@spartacus/core';
readonly defaultUserId = OCC_USER_ID_ANONYMOUS;                                            // OCC_USER_ID_CURRENT | OCC_USER_ID_ANONYMOUS | OCC_USER_ID_GUEST
constructor(public httpClient: HttpClient, public occEndpointsService: OccEndpointsService) { }
A.
serviceMethod() {
  const url = this.occEndpointsService.buildUrl('KEY-FROM-ENDPOINTS-CONFIG-FILE', {       // eg:'KEY_2' , file configured in `spartacus-configuration.MODULE.TS`
    urlParams: {
      PARAM_1: this.defaultUserId,                                                        // variables in URL i.e. ${PARAM_1}
      PARAM_2: VAL_2,
    }
  });
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
OR
B.
serviceMethod() {
  const endpointURL = storeEndpoints.endpointURL_2;
  const url = this.occEndpointsService.buildUrl(endpointURL, {                           // NOTE: no use of '', because it is URL and not KEY
    urlParams: {
      PARAM_1: this.defaultUserId,
      PARAM_2: VAL_2,
    }
  });
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
2. ENDPOINTS.CONST.TS
------------------------
// NOTE: This file is configured in `spartacus-configuration.MODULE.TS`
// NOTE: If KEY is NOT found from here, it is referred from configs from SPARTACUS builtin like `defaultOccCartConfig`
export const storeEndpoints = {
  backend: {
    occ: {
      endpoints: {
        KEY_1: 'basesites?fields=FULL',
        KEY_2: 'users/${PARAM_1}/carts/${PARAM_2}?fields=FULL'
      },
    },
  },
  endpointURL_1: 'payment-token',
  endpointURL_2: 'users/${PARAM_1}/orders?cartId=${cartid}&fields=FULL'
};


CART SERVICES
===================
import { ActiveCartService, UserIdService, MultiCartService } from '@spartacus/core';
constructor(private activeCartService: ActiveCartService,
            private userIdService: UserIdService,
            private multiCartService: MultiCartService) {}
A.
// Create new cart if not exists, else return existing cart (REFER: localstorage of browser for cartID)
this.activeCartService.requireLoadedCart().pipe(
    concatMap((cartState) => {
        return this.SERVICE.HTTP-SERVICE-METHOD(cartState?.value?.code ?? '');
    })
).pipe(takeUntil(this.unsubscribe$)).subscribe((data: any) => {
    // TODO: SUCCESS OF HTTP-SERVICE-METHOD
}, (err: Error) => {
    // TODO: ERROR OF HTTP-SERVICE-METHOD
});
B.1.
// Subscribe to any cart related changes and get cart data
this.activeCartService.getActive().pipe(takeUntil(this.unsubscribe$)).subscribe((cart: CART-TYPE) => {
  this.cartID = cart?.guid || cart?.code;
  this.cdRef.markForCheck();
});
B.2.
// Reload/Refresh cart at app level to have changes if any reflected in getActive() cart subscription (REFER: A point)
// Eg: A product is added to cart, and we need some UI change depending on updated cart data after this product is added to cart.
this.reloadSub = combineLatest([
    this.userIdService.getUserId().pipe(take(1)), this.activeCartService.getActiveCartId().pipe(take(1))
]).subscribe(([userId, cartId]: [string, string]) => {
      if (cartId && userId) {
        this.multiCartService.loadCart({
          userId,
          cartId,
          extraData: {
            active: true,
          },
        });
        if (this.reloadSub) {
          this.reloadSub.unsubscribe();
        }
      }
});
C.
// Cart can be updated using builtin endpoint KEYS like 'addEntries', 'updateEntries', 'removeEntries' from defaultOccCartConfig of spartacus
// i.e. we need NOT to specify URL endpoints in the endpoints file provided in `spartacus-configuration.MODULE.TS`
// Other KEYS and URLs value and what all path params (urlParams) it expects, can be checked from spartacus code repo.
const url = this.occEndpointsService.buildUrl('updateEntries', {
    urlParams: {
        userId: this.defaultUserId,
        cartId: CART_ID,
        entryNumber: ENTRY_NUMBER,
    }
});
D.
// A cart and all it's associated data is deleted from BackOffice/HAC, depending on GUID or CODE


STYLES
============
A. SPARTA LIB + MIXINS
Spartacus provides default styling library called Sparta in the @spartacus/styles package.
This package should be imported into project through the `styles.scss` file.
src/styles.scss
------------------
$primary: #e502bf                                                          // if any new value to scss variables, has to be re-assigned.
$font-weight-normal: 500;                                                  // this is done before Sparta library import.
@import '@spartacus/styles/scss/cxbase/mixins';

B. BREAKPOINT SERVICE
Spartacus provides BreakpointService, which allows same control as media queries, within TS files.
It is better to use as it responds to resize event.
Create a `responsive.SERVICE.TS` file, that can be injected in any COMPONENT.
import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
import { WindowRef } from '@spartacus/core';
import { BREAKPOINT, BreakpointService, LayoutConfig } from '@spartacus/storefront';
import { Observable } from 'rxjs';
@Injectable({
  providedIn: 'root',
})
export class ResponsiveService extends BreakpointService {
  constructor(protected winRef: WindowRef, layoutConfig: LayoutConfig, @Inject(PLATFORM_ID) platform: any) {
    super(winRef, layoutConfig, platform);
  }
  isMobile$: Observable<boolean> = this.isDown(BREAKPOINT.sm);  // when referring DOWN, it picks up limit of next breakpoint, here sm < 768px
  isDesktop$: Observable<boolean> = this.isUp(BREAKPOINT.lg);   // when referring UP, it picks up limit of same breakpoint, here lg >= 992px
}


