Spartacus is Angular-based JavaScript storefront for SAP Commerce Cloud.
Spartacus talks to SAP Commerce Cloud exclusively through the Commerce REST API.
Starting with version 5.0, “SAP Commerce Cloud, Composable Storefront” is name for official release of project “Spartacus” libraries published by SAP.

Spartacus Code Repo, must be cloned on development machine, to have reference for builtin core features like cart, search etc.
GITHUB REPO: https://github.com/SAP/spartacus
REFERENCE  : https://help.sap.com/docs/SAP_COMMERCE_COMPOSABLE_STOREFRONT/cfcf687ce2544bba9799aa6c8314ecd0/e38d45609de04412920a7fc9c13d41e3.html

Storefront Version
REFERENCE: https://github.com/SAP/spartacus#requirements
For which version of    Node, Angular, Yarn, NPM    to use with Spartacus(Composable Storefront) version, refer above website

SmartEdit
REFERENCE: https://help.sap.com/docs/SAP_COMMERCE_CLOUD_PUBLIC_CLOUD/e1391e5265574bfbb56ca4c0573ba1dc/a4b1ea8d8a7249d28ec4aa0e58ff5518.html
           https://sap.github.io/spartacus-docs/smartEdit-setup-instructions-for-spartacus/
Available via @spartacus/smartedit, it allows for creating new pages on website via an interactive GUI.
To access SmartEdit : https://backoffice.HOST-ENV-public.model-t.cc.commerce.ondemand.com/smartedit
`SmartEditFeatureModule` module is imported in `spartacus-features.module.ts`. Inside `SmartEditFeatureModule`, it is provided with config for allowed origins.
1. add browserURL for storefront be allowed inside `whiteListedStorefronts` of Configuration Editor(Settings icon in top right) of SmartEdit with admin login.
2. ensure that WCMS Cockpit Preview URL is set in BackOffice(Website > yoursite > WCMS Properties > WCMS Cockpit Preview URL),same as browserURL for storefront
3. a. from CCv2 -> Security -> HTTP Response Header Set -> Create
        Code: jsapps
        Name: Header for JSapps
        Description: Additional response header set for service jsapps
        HeaderName: X-Frame-Options
        HeaderValue: ''(leave this blank)
        ApplyAction: UNSET
        ApplyCondition: ALWAYS
   b. now move to Environments -> yourenvironemt -> JS-Storefront -> Add this `Header for JSapps` from dropdown to this environment
4. allowOrigin adds SmartEdit to storefront's list of permitted domains, so that it can be used to edit storefront in a cross-origin setup.
   NOTE: a. Port must be specified with origin (https is 443).
         b. Any `.`(dot) in origin should be added explicitly , because `*` wildcard can only replace just one subdomain and cannot replace `.`(dot)
         provideConfig(<SmartEditConfig>{
           smartEdit: {
             storefrontPreviewRoute: 'cx-preview',
             allowOrigin: 'localhost:9002, *.*.model-t.cc.commerce.ondemand.com:443, *.HOSTNAME.com:443' }
         })

ASM (Assisted Service Mode)
Available via @spartacus/asm, it allows for a Super-User functionality where an agent can login to any customer account and check their cart etc.
`AsmFeatureModule` module is imported in `spartacus-features.module.ts`.
To access ASM : append `?asm=true` to website. Eg: https://HOSTNAME.com?asm=true

HAC (Hybris Administrative Console or BackOffice Admin Console)
It is for administrator to handle entire functions and operations in website like:
ImpEx (Import-Export), Groovy Script, Configuration, Cache, Cron Job
Use-Case-1: CORS issue: Check property 'allowedHeaders' through HAC , delete web application services for CORS , rerun CORS impex

RBSC (Repository Based Shipment Channel)
To install composable storefront, need to set up access to composable storefront libraries.
RBSC website: https://ui.repositories.cloud.sap/www/webapp/users/
- Create an S-user for RBSC that has the appropriate licenses to download the composable storefront libraries.
- An S-user account can see Composable Storefront License in list of licenses.
  If the Composable Storefront License does not appear in this list, there will be an error when downloading the packages.
- Click on Add User and create a technical user.
- In User Management tab of RBSC website, select the technical user and copy the generated NPM Base64 Credentials, required for .npmrc file in project

CCv2 (Commerce Cloud Version 2)
https://portal.commerce.ondemand.com
- Here we need to login with S-user ID.
- It allows to make a BUILD from configured repository's branch and then deploy to specific ENVIRONMENT.

SETUP
=============
> ng new <APP_NAME> --style=scss --routing=false
> cd <APP_NAME>
> create an .npmrc file with following content | NOTE: // in second line | NOTE: NPM-CREDENTIALS-FROM-RBSC copied as in above steps
      @spartacus:registry=https://73554900100900004337.npmsrv.base.repositories.cloud.sap/
      //73554900100900004337.npmsrv.base.repositories.cloud.sap/:_auth=NPM-CREDENTIALS-FROM-RBSC
      always-auth=true
> ng add @spartacus/schematics@VERSION --baseUrl <BACKEND_URL> --baseSite=<CONFIG> --ssr --pwa
      --baseUrl: url of backend
      --baseSite: name of storefront
      --ssr: enable SSR features of app
      --pwa: enable PWA features of app
  OR
  ng update @spartacus/schematics@VERSION         // After update is done, inspect your code for comments that begin with TODO:Spartacus
> check `package.json` for correct version of @spartacus libs and
  delete node_modules(if already exists) and then run:
  npm install or yarn install
> update `manifest.json` file , present in 'js-storefront' directory
  (REFER: deployment -> manifest.json   in angular repo)

1. It creates a directory named `spartacus` and inside it:
    1. creates module `spartacus-configuration.module.TS`
       // This will have all configs for spartacus like baseUrl, baseSite etc.
       import { environment } from 'src/environments/environment';
       import { storeEndpoints } from '../core/config/endpoints/store-endpoints.const';
       import { layoutConfig } from '../core/config/layout-config';
       import { appTranslations } from '../core/constants/translations';
       import { mediaConfig } from '../shared/media/media.config';
       @NgModule({
          declarations: [],
          imports: [],
          providers: [
             provideConfig(layoutConfig),               // custom page layout config file
             provideConfig(mediaConfig),                // media config file for images
             provideConfig({                            // image loading strategy
                imageLoadingStrategy: ImageLoadingStrategy.LAZY,
             } as MediaConfig),
             provideConfig(<OccConfig>{                 // base URL config
                backend: {
                  occ: {
                    baseUrl: environment.occBaseUrl,    // value only defined in `environment.ts`, however in `environment.prod.ts`(PRODUCTION) it is `undefined`
                                                           // For prod deployment use meta tag in INDEX.HTML,`content` attr is replaced with URL from CCv2 config
                                                           // i.e.  <meta name="occ-backend-base-url" content="OCC_BACKEND_BASE_URL_VALUE" />
                                                           // i.e.  <meta name="media-backend-base-url" content="MEDIA_BACKEND_BASE_URL_VALUE" />

                    prefix: '/app/v2/'                  // if not specified, the default('/occ/v2/') comes from Spartacus `defaultOccConfig`
                  },
                },
             }),
             provideConfig(<OccConfig>storeEndpoints),  // endpoints config file for OccEndpointsService
             provideConfig(<SiteContextConfig>{         // base SITE config
                context: {
                   currency: ['AUD'],
                   language: ['en'],
                   baseSite: ['PROJECT_NAME'],
                },
             }),
             provideConfig(<I18nConfig>{
                 i18n: {
                   resources: translations,
                   chunks: translationChunksConfig,
                   fallbackLang: 'en',
                 },
             }),
             provideConfig(<I18nConfig>{
                i18n: { resources: appTranslations },   // translations config file

                state: {                               // Spartacus runs XHR requests on server, and then again on client-side when application bootstraps.
                  ssrTransfer: {                       // Spartacus includes part of the NgRx state with the server-side rendered HTML
                    keys: {                            // This prevent unnecessary calls to back end for state that was already populated on server,
                      products: StateTransferType.TRANSFER_STATE,
                      cms: StateTransferType.TRANSFER_STATE,
                    },
                  },
                },
             }),
          ]})
       export class SpartacusConfigurationModule {}
    2. create module `spartacus-features.module.TS`
       // All module imports like FooterNavigationModule, BreadcrumbModule etc.
    3. create module `spartacus.module.TS`
       // import above modules along with BaseStorefrontModule
       @NgModule({
          declarations: [],
          imports: [SpartacusFeaturesModule, SpartacusConfigurationModule, BaseStorefrontModule],
          exports: [BaseStorefrontModule]
       })
       export class SpartacusModule {}
    
2. app.module.TS
------------------
- Remove default angular module `AppRoutingModule` from import (if added when creating Angular project), else nothing will be displayed.
- import `spartacus.module.TS` that we created above, which had other SPARTACUS modules imported.

3. app.component.HTML
-----------------------
- Entire content is deleted and replaced by a single HTML tag
  <cx-storefront></cx-storefront>
  
NOTE: if missed some config, while creating app, it can be done later too
> ng g @spartacus/schematics:add-pwa                    // adds spartacus-specific PWA module
> ng g @spartacus/schematics:add-ssr                    // adds SSR configuration

NOTE: If not installed particular integration lib / feature lib (package) during initial set up of storefront like
@spartacus/asm | @spartacus/cart | @spartacus/checkout | @spartacus/product | @spartacus/smartedit | @spartacus/styles | @spartacus/user   install later using:
> ng add <package-name>
NOTE: a. Follow additional steps as per documentation for each package which is added later,
         as it might require some changes to `angular.json` and other config file(s), which had been done automatically, if added earlier while adding schematics.
      b. Adding these packages(whether earlier or later),adds `@import '..\..\styles-config';` to these features, which may cause ERROR, we can remove this import


MODULES / COMPONENTS / LAYOUT
=================================
> ng g m custom-pdp
> ng g c custom-pdp/custom-product-intro

// DO NOT import these feature modules to `APP.MODULE.TS` directly, but
// import them to  `spartacus-features.MODULE.TS` which is imported by  `spartacus.MODULE.TS` which is imported by `APP.MODULE.TS`
// This allows for LAZY-LOADING of modules that is handled by spartacus.

// To use feature components that are available via Spartacus Storefront, they are to be imported.
// `withConfig` defines that it is a CMS component.
// flexType or typeCode value that we receive from backend is used for mapping to our SPARTACUS component
custom-pdp.module.TS
----------------------
@NgModule({
    declarations: [CUSTOM-COMP-NAME],
    imports: [
        CommonModule,
        StarRatingModule,                                // module import from spartacus storefront
        ConfigModule.withConfig({
            cmsComponents: {
                TYPE-CODE-NAME: {
                    component: CUSTOM-COMP-NAME
                }
            }
        } as CmsConfig)
    ]
})
export class CustomPdpModule {}

custom-product-intro.comp.HTML
---------------------------------
<ng-container *ngIf = "product$ | async as product">
    <h1>{{product?.name}}</h1>
    <h3>{{product?.price?.formattedValue}}</h3>
    <cx-star-rating                                     // comp used from spartacus storefront, must be imported in that module
      [rating] = "product?.averageRating"
      [disabled] = "true">
    </cx-star-rating>
</ng-container>

layout-config.TS                    // a custom layout file to be provided to `spartacus-configuration-module.TS`
---------------------               // layouts(TEMPLATE key from pages API) rendered in <CX-PAGE-LAYOUT> and slots(POSITION keys from pages API) in <CX-PAGE-SLOT>
import { LayoutConfig } from '@spartacus/storefront';
export const layoutConfig: LayoutConfig = {                        // some layouts are pre-defined from SPARTACUS like header, navigation, footer
  layoutSlots: {
      header: {                                                    // <cx-page-layout class="header"></cx-page-layout>
        lg: { slots: ['PreHeader', 'SiteLogo', 'SearchBox'] },     // <cx-page-slot  class="PreHeader" position="PreHeader"></cx-page-slot>
        slots: ['PreHeader', 'SearchBox']                             // less than lg breakpoint, these slots will be rendered
      },
      navigation: {                                                // <cx-page-layout class="navigation"></cx-page-layout>, for NAVIGATION DRAWER container
        lg: { slots: ['MegaMenu'] },                               // lg(>=992px), these slots(position vals) will be rendered in <cx-page-slot>
        md: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] },     // md(>=768px)
        sm: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] },     // sm(>=576px)
        xs: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] }      // xs(<576px)
      },
      footer: {                                                    // <cx-page-layout class="footer"></cx-page-layout>
        slots: ['Footer']                                          // <cx-page-slot class="Footer" position="Footer"></cx-page-slot>
      },
      LandingPage2Template: {                                      // <cx-page-layout class="LandingPage2Template"></cx-page-layout>
        lg: {
          pageFold: 'UpSelling',                                   // Above-the-fold loading is an indication to speed up initial creation of slots
                                                                   // pageFold: indicates last page slot that should be rendered above the fold.
                                                                   // and are prioritized ahead of page slots that are “below the fold”/after this slot
          slots: ['Summary', 'UpSelling', 'Section2B']
        },
        pageFold: 'Section2B',
        slots: []
      },
      SearchResultsListPageTemplate: {
        slots: ['SearchDescription', 'SearchResultList']
      }
  }
}
NOTE: Components come from backend side.
An API call , /pages?lang=EN&curr=AUD , gets all components that are used.
Depending on current browser route URL, this API payload's QUERY-PARAMS change:
A. ContentPage  ( Eg: https://HOSTNAME.com/ROUTE )
   pageType: ContentPage, pageLabelOrId: /ROUTE
B. CategoryPage ( Eg: https://HOSTNAME.com/Categories/Kids/c/SUBCATEGORY )
   pageType: CategoryPage, code: SUBCATEGORY
C. ProductPage  ( Eg: https://HOSTNAME.com/Categories/Kids/Nursery/Dreambaby-Bed-Rail/p/PRODUCT-CODE )
   pageType: ProductPage, code: PRODUCT-CODE
It returns:
contentSlots: {
  contentSlot: [
    {
      components: {
          component: [
            {
              uid: "CustomTileWithTextResponsiveBannerComponent",
              typeCode: "FFCMSContainerComponent",                        // typecode or flexType: mapping to custom spartacus component in MODULE file
              flexType: "FFCMSContainerComponent"                         // NOTE: It depends on backend config, which one to use from these two
            }
          ]
      }
      name: "Tile With Text Banner Slot",
      position: "TileWithTextBanner",                                     // position: included in <cx-page-slot> and used in layout-config.TS
      slotId: "TileWithTextBannerSlot",
      slotShared: false,
      slotUuid: "eyJpdG"
    }
  ]
}
label: "search"
name: "Search Results Page"
robotTag: "INDEX_FOLLOW"
template: "SearchResultsListPageTemplate"                               // template: used in <cx-page-layout>
typeCode: "ContentPage"
uid: "search"
uuid: "eyJp==="


ADD CMS COMPONENT/DATA FROM SLOT, INSIDE ANGULAR COMPONENT
=============================================================
1. MODULE.TS                                    // NOTE: import this module, in SPARTACUS-FEATURES MODULE,
--------------                                  // so that COMP-NAME can render when matches [cxComponentWrapper]
@NgModule({
  providers: [
    provideConfig(<CmsConfig>{
      cmsComponents: {
        TYPE-CODE: {                            // TYPE-CODE is same value as given to  [cxComponentWrapper]  typeCode in COMP.HTML
          component: COMP-NAME,                 // COMP-NAME is component to render, when this typecode matches with [cxComponentWrapper]
        },
      },
    }),
  ],
  declarations: [COMP-NAME],
  exports: [COMP-NAME],
})
export class COMP-NAME-MODULE {}
2. COMP.MODULE.TS
----------------------
import {PageComponentModule} from '@spartacus/storefront';
@NgModule({
    imports: [PageComponentModule, COMP-NAME-MODULE]
})
3. COMP.HTML
---------------
<ng-container *ngIf="component.data$ | async as compData">
 <!-- A. add component using typecode / uid -->
  <ng-container                                // `[cxComponentWrapper]` provides a position for component to render, using `typeCode` value of comp in /pages API
   [cxComponentWrapper]="{                     // this is same as using `slots: ['SLOT-NAME']` in `layout.config.TS`, using `position` value of slot in /pages API
     flexType: compData?.productBrochure?.typeCode,
     typeCode: compData?.productBrochure?.typeCode,
     uid: compData?.productBrochure?.uid
   }">
  </ng-container>

 <!-- B. add data using key from response -->
  <span>{{ compData?.detailErrorMessage }}</span>
</ng-container>
4. COMP.TS
-------------
constructor(public component: CmsComponentData<CmsTabComponent>)


CMS COMPONENTS
========================
1. MODULE.TS
---------------
@NgModule({
  declarations: [CUSTOM-ParagraphComponent, CUSTOM-BannerComponent],
  imports: [
    SupplementHashAnchorsModule,
    ConfigModule.withConfig({
      cmsComponents: {
        CMSParagraphComponent: {
          component: CUSTOM-ParagraphComponent,
        },
        SimpleResponsiveBannerComponent: {
          component: CUSTOM-BannerComponent,
        },
        BannerComponent: {
          component: CUSTOM-BannerComponent,
        },
      },
    }),
  ],
})
export class CmsContentModule {}               // import in `spartacus-features.MODULE.TS`

A. PARAGRAPH COMPONENT
------------------------
  2. CUSTOM-COMP.TS
  --------------------
  import { ParagraphComponent } from '@spartacus/storefront';
  export class CUSTOM-ParagraphComponent extends ParagraphComponent {}
  3. CUSTOM-COMP.HTML
  ---------------------
  <div *ngIf="component.data$ | async as data" [innerHTML]="data.content ?? '' | cxSupplementHashAnchors | safeHtml"></div>

B. BANNER COMPONENT
------------------------
  2. CUSTOM-COMP.TS
  --------------------
  import { BannerComponent } from '@spartacus/storefront';
  export class CUSTOM-BannerComponent extends BannerComponent {}
  3. CUSTOM-COMP.HTML
  ---------------------
  <div *ngIf="component.data$ | async as data">
    <img *ngIf="data.media && data.media.src"
      [attr.src]="data.media.src"
      [attr.alt]="data.media.alt"
      [attr.role]="data.media.role"
    />
  </div>


LAUNCH-DIALOG SERVICE (POPUP/MODAL/DIALOG)
=============================================
1. MODEL.TS/ENUM.TS
----------------------
import '@spartacus/storefront';
declare module '@spartacus/storefront' {
  const enum LAUNCH_CALLER {
    FABRIC_SELECT = 'FABRIC_SELECT',
    NEAREST_STORES = 'NEAREST_STORES'
  }
}
2. MODULE.TS
---------------
export const defaultLaunchConfig: LayoutConfig = {
  launch: {
    [LAUNCH_CALLER.FABRIC_SELECT]: {
      inlineRoot: true,                          // Renders component directly inside <cx-storefront>, i.e. a global dialog
      component: PopupComponent_1,               // component to render
      dialogType: DIALOG_TYPE.DIALOG,            // POPOVER(no backdrop) | POPOVER_CENTER_BACKDROP(backdrop) | DIALOG(backdrop) | SIDEBAR_START | SIDEBAR_END
    },
    [LAUNCH_CALLER.NEAREST_STORES]: {
      inlineRoot: true,
      component: PopupComponent_2,
      dialogType: DIALOG_TYPE.DIALOG,
    }
}};
@NgModule({
  declarations: [],
  imports: [],
  providers: [provideDefaultConfig(defaultLaunchConfig)],
})
3. COMP.TS
-------------
import { LaunchDialogService, LAUNCH_CALLER } from '@spartacus/storefront';
@ViewChild('NearestStoreModalOpen') private dialogTriggerRef!: ElementRef;
constructor(private launchDialogService: LaunchDialogService) {}
A.
this.launchDialogService.openDialogAndSubscribe(LAUNCH_CALLER.NEAREST_STORES, this.dialogTriggerRef, {
  data_key_1: data_value_1,
  data_key_2: data_value_2
});
B.
this.launchDialogService.dialogClose.pipe(takeUntil(this.destroyed$)).subscribe((data: any) => {
  // TODO: data received from .popup.comp.TS on closing dialog
});
4. POPUP.COMP.TS
------------------
// Close on click outside the dialog window
@HostListener('click', ['$event'])
handleClick(evt: UIEvent): void {
  if ((evt.target as any).classList.contains('modal')) {
    this.close();
  }
}
A.
this.launchDialogService.data$.pipe(takeUntil(this.destroyed$)).subscribe((data: any) => {
  // TODO: data received from .comp.TS on opening dialog
});
B.
this.launchDialogService.closeDialog({
  data_key_1: data_value_1,
  data_key_2: data_value_2
});
5. POPUP.COMP.HTML
---------------------
<div class="modal-container">                      // styles applied to `.modal-container` from global STYLES.SCSS
  <div class="header-container">
    <span class="headline">TITLE</span>
    <button type="button" class="closeBtn" aria-label="Close" (click)="close()">
      <i class="fa fa-times"></i>
    </button>
  </div>
  <div class="body-container"></div>
</div>
6. STYLES.SCSS
---------------------
.modal {
  z-index: 1500 !important;
  display: flex !important;
  align-items: center;
  justify-content: center;

  .modal-container {
    width: 90%;
    background-color: var(--white);
    border-radius: 0.5rem;
    padding: 0.5rem;
    @include media-breakpoint-up(md) {
      width: 50%;
    }
  }
}


GLOBAL MESSAGE SERVICE (BANNER MESSAGE SHOWN AT TOP)
=========================================================
1. STYLES.SCSS
--------------------
cx-global-message {
  z-index: 999999;
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
}
2. COMP.TS
---------------------
import { GlobalMessageService, GlobalMessageType } from '@spartacus/core';
constructor(private globalMsgService: GlobalMessageService) {}
A.
this.globalMsgService.add(
  'MSG-STRING' || { key: 'KEY-FROM-TRANSLATIONS-FILE', params: { VARIABLE: VALUE-VARIABLE } },
  GlobalMessageType.MSG_TYPE_CONFIRMATION,                         // MSG_TYPE_CONFIRMATION | MSG_TYPE_ERROR | MSG_TYPE_INFO | MSG_TYPE_WARNING
  3000                                                             // Timeout in milliseconds
);
B.
this.globalMsgService.remove(GlobalMessageType.MSG_TYPE_ERROR);    // Remove message


PAGINATION WIDGET
========================
1. MODULE.TS
-----------------
import { PaginationModule } from '@spartacus/storefront';
@NgModule({
    imports: [PaginationModule]
})
OR
import {ListNavigationModule} from '@spartacus/storefront';
@NgModule({
    imports: [ListNavigationModule]
})
2. COMP.HTML
-----------------
<div *ngIf="(searchResult.pagination?.totalPages ?? 0) > 1">
    <cx-pagination [pagination]="searchResult.pagination" queryParam="currentPage" [defaultPage]="0"></cx-pagination>
    OR
    <cx-pagination [pagination]="OrderHistoryList?.pagination" (viewPageEvent)="pageChange($event)"></cx-pagination>
</div>
3. COMP.TS
------------------
this.searchResult = data;                // data from API response of /search , it will have
                                         // object "pagination": {"currentPage": 1,"pageSize": 24,"sort": "clear","totalPages": 3,"totalResults": 60}
4. APP.MODULE.TS
------------------
For global configuration of pagination widget, add here in app.module.ts
imports: [
 ConfigModule.withConfig({
  pagination: {
    addStart: true,
    addPrevious: true,
    addFirst: true,
    addDots: true,
    rangeCount: 3,
    addLast: true,
    addNext: true,
    addEnd: true,
  },
 })
]

INFINITE SCROLL
=========================
REFERENCE: https://help.sap.com/docs/SAP_COMMERCE_COMPOSABLE_STOREFRONT/eaef8c61b6d9477daf75bff9ac1b7eb4/d37bd1496c6c42d5b7a17740ba155e94.html
           https://microlearning.opensap.com/media/Infinite+Scroll+-+SAP+Commerce+Cloud/1_crd2801x
When infinite scroll is enabled in composable storefront, it applies to product search page, as well as category pages in both list and grid views.
When infinite scroll is disabled, composable storefront uses pagination instead. By default, infinite scroll is disabled in composable storefront.
1. APP.MODULE.TS
----------------------
imports: [
    ConfigModule.withConfig({
        view: {
            infiniteScroll: {
                active: true,             // enable / disable infinite scroll , auto loads without any limit/button until products are not found
                productLimit: 50,         // number of products user can scroll through before they are prompted to load more items using SHOW MORE button
                showMoreButton: false,    // true: auto sets "productLimit": 10  i.e. value for productLimit key is ignored | false: productLimit key considered
            },
        },
    })
]


SPINNER WIDGET (LOADER)
===========================
1. loader.MODULE.TS                                            // import this module in `APP.MODULE.TS`
----------------------
import { SpinnerModule } from '@spartacus/storefront';
@NgModule({
  declarations: [LoaderOverlayComponent],
  imports: [SpinnerModule],
  exports: [LoaderOverlayComponent],
})
export class LoaderOverlayModule { }
2. loader.COMP.HTML
-----------------------
<div class="spinner-wrapper" (click)="overlayClick($event)">
  <div class="cx-spinner">
    <cx-spinner></cx-spinner>
  </div>
</div>
3. loader.COMP.TS
-----------------------
overlayClick(evt: Event) {
  evt.preventDefault();
  evt.stopPropagation();
}
4. loader.SERVICE.TS                                            // Inject this loaderService in constructor of any component and use   .show() | .hide()
-----------------------
export class LoaderService {
  public loader$: BehaviorSubject<boolean>  = new BehaviorSubject<boolean>(true);
  show(): void {
    this.loader$.next(true);
  }
  hide(): void {
    this.loader$.next(false);
  }
}
5. APP.COMP.HTML
---------------------
<ff-loader-overlay *ngIf="loading"></ff-loader-overlay>
<cx-storefront></cx-storefront>
6. APP.COMP.TS
---------------------
import { RoutingService } from '@spartacus/core';
constructor(private routingService: RoutingService, private loaderService: LoaderService) { }
this.loaderService.loader$.pipe(takeUntil(this.destroyed$)).subscribe((loading: boolean) => {
    this.loading = loading;
    this.cd.markForCheck();
});
this.routingService.isNavigating().pipe(takeUntil(this.destroyed$)).subscribe((nav: boolean) => {
    if(nav) {
        this.loaderService.show();
    } else {
        this.loaderService.hide();
    }
});


ACTIONS
========================
Some API calls are handled by spartacus and we do not have control over their success response or failure response.
So, we can make use of actions from ngrx/effects.
Eg:
import { Actions, ofType } from '@ngrx/effects';
import { ProductActions } from '@spartacus/core';
import { CartActions } from '@spartacus/cart/base/core';
constructor(private actions$: Actions) { }
ngOnInit() {
  this.actions$.pipe(ofType(ProductActions.SEARCH_PRODUCTS_FAIL)).subscribe(() => {
     this.loaderService.hide();
  });
  this.actions$.pipe(ofType(CartActions.LOAD_CART_FAIL)).subscribe(() => {
     this.loaderService.hide();
  });
}


TRANSLATION SERVICE
=========================
1. MODULE.TS
--------------
import { I18nModule } from '@spartacus/core';
imports: [I18nModule]
export class COMP-MODULE {}
2. appTranslations.TS                                 // file configured in `spartacus-configuration.MODULE.TS`
------------------------
export const appTranslations = {
    en: {
        HEADER: {                                     // NOTE: same HEADER name inside HEADER
            HEADER: {
                KEY_1: 'VAL_1',
                KEY_2: 'VAL_2 {{VARIABLE}} VAL_2',    // NOTE: use of VARIABLE in {{ }}
            }
        }
    }
}
3.A. COMP.TS
----------------
import { TranslationService } from '@spartacus/core';
constructor(private translationService: TranslationService) { }
this.translationService.translate('HEADER.KEY_1').pipe(first()).subscribe((tData) => { this.val = tData; });
this.translationService.translate('HEADER.KEY_2', {VARIABLE: VAL-OF-VARIABLE}).pipe(first()).subscribe((tData) => { this.val = tData; });
OR
3.B. COMP.HTML
----------------
{{ 'HEADER.KEY_1' | cxTranslate }}
{{ 'HEADER.KEY_2' | cxTranslate: {VARIABLE: VAL-OF-VARIABLE} }}


BASESITE SERVICE
=========================
A.1.
On website initial load, a GET API call is made to `/basesites` i.e. `https://BASE-URL/PREFIX/basesites?fields=FULL&lang=en&curr=USD`
This is handled by spartacus default url mapping. NOTE: This API call response may not have all fields.
So, we can specify key `baseSites` inside ENDPOINTS.CONST.TS file(spartacus-configuration.MODULE.TS) i.e.
backend: { occ: { endpoints: { baseSites: 'basesites?fields=FULL' } } }
It returns all basesite related config and our application can use values depending on UID of basesite data.
A.2.
NOTE: If we specify `baseSite` value in `spartacus-configuration.module.ts`,
that baseSite gets picked up as an active basesite and components are returned accordingly from backoffice in /pages API response.
However, To have multiple domains(websites) having common/shared components, Eg: https://www.freedom.com.au/    and     https://www.freedomfurniture.co.nz/
we need only ONE code repository, also:
- Do NOT specify any basesite in `spartacus-configuration.module.ts` file
- Specify urlPatterns that are returned /basesite API response from backoffice that will determine,
  which domain is being hit from browser, and spartacus will pick it as an active basesite.
- There will be N components(N header, N footer, N banners) created from backoffice, one for each basesite,
  and only one of those will get returned in /pages API response, depending on active basesite.
- To ensure reusability of components, make sure to have colors, text, widgets to be shown/hidden as configurable in FE components that can work for all sites
  and relevant keys available in /pages API response for that component.
B.
import { BaseSiteService } from '@spartacus/core';
constructor(private baseSiteService: BaseSiteService) { }
public showReviewsWidget: boolean = false;
private activeSiteUID: string = '';
this.baseSiteService.get().pipe(takeUntil(this.destroyed$)).subscribe((baseSite) => {
    this.showReviewsWidget = (baseSite as BASESITE-INTERFACE).KEY-FROM-BASESITE;
    this.activeSiteUID = baseSite?.uid ?? '';
});


CMS SERVICE
==========================
import { CmsService, Page } from '@spartacus/core';
constructor(private cmsService: CmsService) { }
A.
public pageData!: Page;
this.cmsService.getCurrentPage().pipe(takeUntil(this.destroyed$)).subscribe((data) => {
    this.pageData = data;
}, () => {});
this.pageData?.template === PageTemplateENUM.VALUE-FROM-PAGES-API-TEMPLATE;
B.
this.cmsService.getComponentData('COMP-UID').pipe(takeUntil(this.destroyed$)).subscribe((compData: CmsComponent) => {
    this.navNode = compData?.navigationNode;
}, () => {});


NAVIGATION SERVICE (navigation menus)
=======================================
NOTE: REFER CODE SAMPLE IN   `misc/navigation-drawer.txt`
1. COMP.TS (mapped in module with navigation slot's comp)
--------------------------------------------------------------
import { NavigationService } from '@spartacus/storefront';
A.
constructor(public navService: NavigationService, public component: CmsComponentData<CmsNavigationComponent>) { }
this.component.data$.pipe(switchMap((compData) => {
  if (compData && compData?.navigationNode) {
    return this.navService.createNavigation(of(compData));
  } else {
    return of(null);
  }
}),
takeUntil(this.destroy$)
).subscribe((navigationNode) => {
  if (navigationNode) {
    this.navNode = navigationNode;
    this.cd.markForCheck();
  }
});
   OR
B.
constructor(public navService: NavigationService, private cmsService: CmsService) { }
this.cmsService.getComponentData('COMP-UID').pipe(switchMap((compData) => {
  if (compData && compData?.navigationNode) {
    return this.navService.createNavigation(of(compData));
  } else {
    return of(null);
  }
}),
takeUntil(this.destroy$)
).subscribe((navigationNode) => {
  if (navigationNode) {
    this.navNode = navigationNode;
    this.cd.markForCheck();
  }
});
2. COMP.HTML
----------------
<CUSTOM-MOBILE-NAVIGATION
  [node]="navNode"
  [resetMenuOnClose]="true">
</CUSTOM-MOBILE-NAVIGATION>


ROUTING
==============
Many routes are built-in with SPARTACUS, and render templates accordingly.
However, we can create CUSTOM routes too.
A
1. APP.MODULE.TS
-------------------
imports: [
    ConfigModule.withConfig({
      routing: {
        routes: {
          FE_PATH_1: { paths: ['BACKEND_PATH_FOR_PAGE_1'] },
          FE_PATH_2: { paths: ['BACKEND_PATH_FOR_PAGE_2'] },
        }
      }
    })
]
2. SPARTACUS-FEATURES.MODULE.TS
----------------------------------
imports: [
    CUSTOM_MODULE_1,
    CUSTOM_MODULE_2
]
3. COMP.TS
-------------------
import { RoutingService } from '@spartacus/core';
constructor(private routingService: RoutingService) {}
navigateFabricSamples() {
    this.routingService.go({
      cxRoute: 'FE_PATH_2',
    });
}

B
1. MODULE.TS
--------------------
import { RouterModule, Routes } from '@angular/router';
import { CmsPageGuard } from '@spartacus/storefront';
const STATIC_ROUTE: Routes = [{ path: 'PATH-TO-COMP', component: CUSTOM-Component, canActivate: [CmsPageGuard] }];
@NgModule({
  declarations: [CUSTOM-Component],
  imports: [CommonModule, RouterModule.forChild(STATIC_ROUTE)]
})
export class CUSTOM-Module { }


ROUTE GUARDS
===========================
It is similar to Angular route guards i.e. guard is a service which has canActivate() etc. methods, only difference is how we include these guards.
In Spartacus, it is added with config for mapping components, plus provide builtin guards like    AuthGuard | CheckoutDetailsLoadedGuard | CartNotEmptyGuard
ConfigModule.withConfig({
    cmsComponents: {
        TYPE-CODE: {
            component: FE-COMPONENT,
            guards: [CUSTOM-CheckoutAuthGuard, CartNotEmptyGuard]
        }
    }
})


HTTP REQUESTS (services)
===========================
1. SERVICE.TS
----------------
import { OccEndpointsService, OCC_USER_ID_ANONYMOUS } from '@spartacus/core';
readonly defaultUserId = OCC_USER_ID_ANONYMOUS;                                            // OCC_USER_ID_CURRENT | OCC_USER_ID_ANONYMOUS | OCC_USER_ID_GUEST
constructor(public httpClient: HttpClient, public occEndpointsService: OccEndpointsService) { }
A.
serviceMethod() {
  const url = this.occEndpointsService.buildUrl('KEY-FROM-ENDPOINTS-CONFIG-FILE', {       // eg:'KEY_2' , file configured in `spartacus-configuration.MODULE.TS`
    urlParams: {
      PARAM_1: this.defaultUserId,                                                        // variables in URL i.e. ${PARAM_1}
      PARAM_2: VAL_2,
    }
  }, { baseUrl: true, prefix: false, baseSite: false });
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
B.
serviceMethod() {
  const endpointURL = storeEndpoints.endpointURL_2;
  const url = this.occEndpointsService.buildUrl(endpointURL, {                           // NOTE: no use of '', because it is URL and not KEY
    urlParams: {
      PARAM_1: this.defaultUserId,
      PARAM_2: VAL_2,
    }
  }, { baseUrl: true, prefix: false, baseSite: false });
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
C.
serviceMethod() {
  const baseUrl = this.occEndpointsService.getBaseUrl();                                                    // baseUrl + prefix + baseSite from occ service
  const baseUrl = this.occEndpointsService.getBaseUrl({ baseUrl: true, prefix: false, baseSite: false });   // specified `false` for value that is not required
  const url = `${this.baseUrl}/users/${this.defaultUserId}/carts/${cartID}/findStore`;
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
2. ENDPOINTS.CONST.TS
------------------------
// NOTE: This file is configured in `spartacus-configuration.MODULE.TS`
// NOTE: If KEY is NOT found from here, it is referred from configs from SPARTACUS builtin like `defaultOccCartConfig`
export const storeEndpoints = {
  backend: {
    occ: {
      endpoints: {
        KEY_1: 'basesites?fields=FULL',
        KEY_2: 'users/${PARAM_1}/carts/${PARAM_2}?fields=FULL'
      },
    },
  },
  endpointURL_1: 'payment-token',
  endpointURL_2: 'users/${PARAM_1}/orders?cartId=${cartid}&fields=FULL'
};


CART SERVICES
===================
// API calls to /cart might not return complete data. To fix this add endpoint to config-file for fields=FULL i.e.
backend: { occ: { endpoints: {
           cart: 'users/${userId}/carts/${cartId}?fields=FULL',
           carts: 'users/${userId}/carts?fields=FULL',
           createCart: 'users/${userId}/carts?fields=FULL',
           addEntries: 'orgUsers/${userId}/carts/${cartId}/entries?fields=FULL&code=${code}&quantity=${quantity}',
           updateEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',
           removeEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',
  } } }
- APP.MODULE.TS
  import { ActiveCartService, CartAdapter, CartEntryAdapter, MultiCartService } from '@spartacus/cart/base/core';
  providers: [{ provide: CartAdapter, useClass: CUSTOM-CartAdapter}, { provide: ActiveCartService, useExisting: CUSTOM-CartService, multi: true }
              { provide: CartEntryAdapter, useClass: CUSTOM-CartEntryAdapterService } , MultiCartService]
- CUSTOM-CartAdapter.SERVICE.TS
  import { OccCartAdapter } from '@spartacus/cart/base/occ';
  import { Cart, CART_NORMALIZER } from '@spartacus/cart/base/root';
  import { ConverterService, Occ, OccEndpointsService } from '@spartacus/core';
  @Injectable({providedIn: 'root'})
  export class CUSTOM-CartAdapter extends OccCartAdapter {
    constructor(protected _http: HttpClient, protected _occEndpointsService: OccEndpointsService, protected _converterService: ConverterService) {
      super(_http, _occEndpointsService, _converterService);
    }
    override create(userId: string, oldCartId?: string, toMergeCartGuid?: string): Observable<Cart> {
      const toAdd = JSON.stringify({});
      const params = <any>{};
      if (oldCartId) {
        params['oldCartId'] = oldCartId;
      }
      if (toMergeCartGuid) {
        params['toMergeCartGuid'] = toMergeCartGuid;
      }
      params['fields'] = 'FULL';
      return this.http.post<Occ.Cart>(this._occEndpointsService.buildUrl('createCart', {urlParams: { userId }, queryParams: params }), toAdd)
                                     .pipe(this._converterService.pipeable(CART_NORMALIZER));
    }
  }
- CUSTOM-CartService.SERVICE.TS
  import { ActiveCartService, getCartIdByUserId, MultiCartService } from '@spartacus/cart/base/core';
  import { MultiCartFacade } from '@spartacus/cart/base/root';
  import { UserIdService, WindowRef } from '@spartacus/core';
  @Injectable({providedIn: 'root'})
  export class CUSTOM-CartService extends ActiveCartService {
    constructor(multiCartFacade: MultiCartFacade, userIdService: UserIdService, winRef: WindowRef, protected multiCartService: MultiCartService,
                protected http: HttpClient, protected occEndpointsService: OccEndpointsService) {
      super(multiCartFacade, userIdService, winRef);
    }
    override addEntry(productCode: string, quantity: number, pickupStore?: string): void {
      this.requireLoadedCart().pipe(withLatestFrom(this.userIdService.getUserId())).subscribe(([cart, userId]) => {
        this.multiCartService.addEntry(userId, getCartIdByUserId(cart, userId), productCode, quantity, pickupStore);
      });
    }
    addItemEntry(userId: string, cartId: string, code: string, quantity: number) {
      const url = this.occEndpointsService.buildUrl('addEntries', {
        urlParams: { userId, cartId, code, quantity },
      });
      const headers = new HttpHeaders({'Content-Type': 'application/json'});
      return this.http.post<CartModification>(url, { headers });
    }
  }
- CUSTOM-CartEntryAdapterService.SERVICE.TS
  import { OccCartEntryAdapter } from '@spartacus/cart/base/occ';
  import { CartModification, CART_MODIFICATION_NORMALIZER } from '@spartacus/cart/base/root';
  import { ConverterService, OccEndpointsService } from '@spartacus/core';
  @Injectable({ providedIn: 'root' })
  export class CUSTOM-CartEntryAdapterService extends OccCartEntryAdapter {
    constructor(protected _http: HttpClient, protected _occEndpointsService: OccEndpointsService, protected _converterService: ConverterService) {
      super(_http, _occEndpointsService, _converterService);
    }
    public override add(userId: string, cartId: string, productCode: string, quantity: number = 1, pickupStore?: string): Observable<CartModification> {
      const url = this.occEndpointsService.buildUrl('addEntries', {
        urlParams: { userId, cartId, quantity },
      });
      // Handle b2b case where the x-www-form-urlencoded is still used
      if (url.includes(`quantity=${quantity}`)) {
        const httpHeaders = new HttpHeaders({'Content-Type': 'application/x-www-form-urlencoded'});
        return this.http.post<CartModification>(url, {}, { headers: httpHeaders, params: { code: productCode } })
                        .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));
      }
      const toAdd = {
        orderEntries: [{quantity, product: { code: productCode }, ...(pickupStore && { deliveryPointOfService: { name: pickupStore } })}]
      };
      const headers = new HttpHeaders({'Content-Type': 'application/json'});
      return this.http.post<CartModification>(url, toAdd, { headers })
                      .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));
    }
  }
A.
// Create new cart if not exists by calling API, else return existing cart (REFER: localstorage of browser for cartID)
- COMP.TS
  import { MultiCartService } from '@spartacus/cart/base/core';
  constructor(private activeCartService: CUSTOM-CartService, private multiCartService: MultiCartService) {}
  this.activeCartService.requireLoadedCart().pipe(takeUntil(this.unsubscribe$)).subscribe((cart) => {
    if (cart.code) {
      this.cartId = cart.code;
      this.activeCartService.addItemEntry(OCC_USER_ID_CURRENT, cart.code, evt.product.code, evt.unitQuantity)
                            .pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
        // To Update Cart State in Spartacus Store, when calling our custom API
        this.multiCartService.reloadCart(this.cartId);              
      });
    }
  });
B.1.
- .MODULE.TS
  import { MultiCartService } from '@spartacus/cart/base/core';
  providers: [MultiCartService]
- COMP.TS
  // Subscribe to any cart related changes and get cart data
  this.activeCartService.getActive().pipe(takeUntil(this.unsubscribe$)).subscribe((cart: CART-TYPE) => {
    this.cartID = cart?.guid || cart?.code;
    this.cartData = cart;
    this.cdRef.markForCheck();
  });
B.2.
// Reload/Refresh cart at app level by calling API, to have changes if any reflected in getActive() cart subscription (REFER: B.1. point)
// Eg: A product is added to cart, and we need some UI change depending on updated cart data after this product is added to cart.
this.reloadSub = combineLatest([
    this.userIdService.getUserId().pipe(take(1)), this.activeCartService.getActiveCartId().pipe(take(1))
]).subscribe(([userId, cartId]: [string, string]) => {
      if (cartId && userId) {
        this.multiCartService.loadCart({
          userId,
          cartId,
          extraData: {
            active: true,
          },
        });
        if (this.reloadSub) {
          this.reloadSub.unsubscribe();
        }
      }
});
C.
// Cart can be updated using builtin endpoint KEYS like 'addEntries', 'updateEntries', 'removeEntries' from defaultOccCartConfig of spartacus
// Other KEYS and URLs value and what all path params (urlParams) it expects, can be checked from spartacus code repo.
constructor(protected cartService: CUSTOM-CartService) { }
C.1.
this.cartService.updateEntry(orderEntry.entryNumber, quantity);
C.2.
this.cartService.removeEntry(orderEntry);
D.
// A cart and all it's associated data is also deleted from BackOffice/HAC, depending on GUID or CODE
OR
- COMP.TS
  import { MultiCartService } from '@spartacus/cart/base/core';
  import { UserIdService } from '@spartacus/core';
  constructor(protected cartService: CUSTOM-CartService, private multiCartService: MultiCartService, private userIdService: UserIdService) { }
  this.cartService.getActiveCartId().pipe(withLatestFrom(this.userIdService.getUserId()), take(1), tap(([cartId, userId]) => {
    this.multiCartService.deleteCart(cartId, userId);
  })).subscribe(() => { });


ORDER / CHECKOUT SERVICES
============================
import { Order, OrderFacade } from '@spartacus/order/root';
constructor(private checkoutDeliveryAddressFacade: CheckoutDeliveryAddressFacade,
            private checkoutDeliveryModesFacade: CheckoutDeliveryModesFacade,
            private checkoutPaymentFacade: CheckoutPaymentFacade,
            private orderFacade: OrderFacade) { }
A.
backend: { occ: { endpoints: { setDeliveryAddress: 'orgUsers/${userId}/carts/${cartId}/addresses/delivery?addressId=${addressId}&fields=FULL' } } }
// Sets the delivery address to cart
this.checkoutDeliveryAddressFacade.setDeliveryAddress(DELIVERY-ADDRESS-OBJECT ?? {}).pipe(takeUntil(this.destroy$)).subscribe(
  (_) => { },
  (_) => { }
);
B.
backend: { occ: { endpoints: { setDeliveryMode: 'users/${userId}/carts/${cartId}/deliverymode?deliveryModeId=${deliveryModeId}' } } }
// Sets the provided delivery mode to current cart
this.checkoutDeliveryModesFacade.setDeliveryMode(DELIVERY-MODE-STRING ?? '').pipe(takeUntil(this.destroy$)).subscribe(
  (_) => { },
  (_) => { }
);
C.
// Sets the payment details to current cart
this.checkoutPaymentFacade.setPaymentDetails(PAYMENT-DETAILS-OBJECT ?? {}).pipe(takeUntil(this.destroy$)).subscribe(
  (_) => { },
  (_) => { }
);
D.
backend: { occ: { endpoints: { placeOrder: 'orgUsers/${userId}/orders?cartId=${cartId}&termsChecked=true&fields=FULL' } } }
// Places an order
this.orderFacade.placeOrder(true).pipe(takeUntil(this.unsubscribe$)).subscribe(
  (orderData: Order) => {
    this.router.navigate(['order-confirmation']);
  },
  (_) => { }
);


ORDER HISTORY SERVICE
============================
backend: { occ: { endpoints: { orderHistory: 'users/${userId}/orders?pageSize=${pageSize}&fields=FULL' } } }
import { OrderHistoryFacade, OrderHistoryList, Order } from '@spartacus/order/root';
constructor(private orderHistoryFacade: OrderHistoryFacade) { }
A.
A.1. COMP.MODULE.TS
-----------------------
import { PaginationModule } from '@spartacus/storefront';
@NgModule({
    imports: [PaginationModule]
})
A.2. COMP.TS
-----------------------
this.orderHistoryFacade.getOrderHistoryList(ORDER_HISTORY_PAGE_SIZE).pipe(takeUntil(this.unsubscribe$)).subscribe(
  (resp?: OrderHistoryList) => {
    this.OrderHistoryList = resp;
    setOrderHistoryParams(resp);
    this.cdRef.markForCheck();
  },
  () => {}
);
setOrderHistoryParams(orders?: OrderHistoryList) {
  this.sortOptions = orders?.sorts ?? [];
  this.sortType = orders?.pagination?.sort ?? '';
}
changeSortCode(sortCode: string): void {
  const event: OrderHistoryPage = {
    sortCode,
    currentPage: 0,
  };
  this.sortType = sortCode;
  this.fetchOrders(event);
}
pageChange(page: number): void {
  const event: OrderHistoryPage = {
    sortCode: this.sortType,
    currentPage: page,
  };
  this.fetchOrders(event);
}
private fetchOrders(event: OrderHistoryPage): void {
  this.orderHistoryFacade.loadOrderList(ORDER_HISTORY_PAGE_SIZE, event.currentPage, event.sortCode);
}
A.3. COMP.HTML
-----------------------
<select class="form-control" (change)="changeSortCode($any($event)?.target?.value ?? '')">
  <option *ngFor="let option of sortOptions" [value]="option.code" [selected]="option?.selected">
    {{ option.name || option.code }}
  </option>
</select>
<div *ngIf="(OrderHistoryList?.pagination?.totalPages ?? 0) > 1">
  <cx-pagination [pagination]="OrderHistoryList?.pagination" (viewPageEvent)="pageChange($event)"></cx-pagination>
</div>
B.
B.1. COMP.TS
----------------------
this.orderHistoryFacade.loadOrderDetails(orderId);
this.subscription = this.orderHistoryFacade.getOrderDetails()
                      .pipe(takeUntil(this.unsubscribe$)).subscribe(
                        (orderData?: Order) => {
                          this.currentOrder = orderData ?? {};
                          this.subscription?.unsubscribe();
                          this.cdRef.markForCheck();
                        },
                        () => {}
                      );


ORDER CONFIRMATION PAGE
============================
import { Order, OrderFacade } from '@spartacus/order/root';
constructor(private orderFacade: OrderFacade) { }
A.
// Returns the current order
this.orderFacade.getOrderDetails().pipe(takeUntil(this.unsubscribe$)).subscribe(
  (order?: Order) => {
    this.currentOrder = order;
    this.cdRef.markForCheck();
  },
  () => {}
);
B.
// Clears the current order
ngOnDestroy(): void {
  this.orderFacade.clearPlacedOrder();
}


PRODUCT SERVICES
============================
A.1.
On landing to PLP (Product Listing Page), composable storefront makes an API call for getting search data. This is handled by spartacus default url mapping.
NOTE: This API call response may not have all fields. So, we can specify productSearch URL in ENDPOINTS.CONST.TS file(spartacus-configuration.MODULE.TS) i.e.
backend: { occ: { endpoints: { productSearch: 'products/search?fields=FULL' } } }
A.2.
To use this response data , follow steps:
- APP.MODULE.TS
  import { ProductListComponentService } from '@spartacus/storefront';
  imports: [ConfigModule.withConfig({ view: { defaultPageSize: 24 } })],
  providers: [{ provide: ProductListComponentService, useClass: CUSTOM-ProductListCompService }]
- CUSTOM-ProductListCompService.SERVICE.TS
  import { ActivatedRoute, Router } from '@angular/router';
  import { CurrencyService, LanguageService, ProductSearchService, RoutingService } from '@spartacus/core';
  import { ProductListComponentService, ProductListRouteParams, ViewConfig } from '@spartacus/storefront';
  import { CUSTOM-SearchCriteria } from 'src/app/core/interfaces/CUSTOM-interface';
  @Injectable({
    providedIn: 'root',
  })
  export class CUSTOM-ProductListCompService extends ProductListComponentService {
    protected readonly RELEVANCE_ALLCATEGORIES = ':relevance:category:';
    constructor(
      protected override productSearchService: ProductSearchService, protected override routing: RoutingService,
      protected override activatedRoute: ActivatedRoute, protected override currencyService: CurrencyService,
      protected override languageService: LanguageService, protected override router: Router, protected override config: ViewConfig) {
        super(productSearchService, routing, activatedRoute, currencyService, languageService, router, config);
    }
    override search(criteria: CUSTOM-SearchCriteria): void {
      const currentPage = criteria.currentPage;
      const pageSize = criteria.pageSize;
      const sort = criteria.sortCode;
      this.productSearchService.search(criteria.query, Object.assign({}, { currentPage }, { pageSize }, { sort }));
    }
    override getCriteriaFromRoute(routeParams: ProductListRouteParams, queryParams: CUSTOM-SearchCriteria): CUSTOM-SearchCriteria {
      return {
        query: queryParams.query ? queryParams.query : this.getQueryFromRouteParams(routeParams),
        currentPage: queryParams.currentPage ?? 0,
        pageSize: queryParams.pageSize ?? this.config.view?.defaultPageSize,
        sortCode: queryParams.sortCode ?? (queryParams.query ? queryParams.query.split(':')[1] : 'relevance'),
      };
    }
    protected override getQueryFromRouteParams({ query, categoryCode, brandCode }: ProductListRouteParams): string {
      if (query) {
        return query;
      }
      if (categoryCode) {
        return this.RELEVANCE_ALLCATEGORIES + categoryCode;
      }
      if (brandCode) {
        return this.RELEVANCE_ALLCATEGORIES + brandCode;
      }
      return '';
    }
  }
- CUSTOM-PRODUCT-LIST-PAGE.COMP.TS
  constructor(private productListCompService: CUSTOM-ProductListCompService) { }
  a. TO GET PRODUCTS DATA
     this.productListCompService.model$.pipe(takeUntil(this.unsubscribe$)).subscribe(
      (res) => {
        this.products = res.products ?? [];
        this.sortOptions = res.sorts ?? [];
        this.defaultSort = res.sorts?.find((option) => option.selected)?.code ?? '';
        this.cdRef.markForCheck();
      },
      (_) => {}
     );
  b. TO APPLY SORT CODE
     this.productListCompService.sort(SORTCODE-VALUE);
- CUSTOM-PRODUCT-LEFT-REFINEMENT.COMP.TS
  FOR FACETS , REFER   `misc/facets.txt`   code
B.1.
On landing to PDP (Product Details Page), composable storefront makes an API call for getting product data. This is handled by spartacus default url mapping.
NOTE: This API call response may not have all fields. So, we can specify product URL in ENDPOINTS.CONST.TS file(spartacus-configuration.MODULE.TS) i.e.
backend: { occ: { endpoints: { product: 'products/${productCode}?fields=FULL' } } }
B.2.
To use this response data , follow:
- CUSTOM-PRODUCT-DETAILS-PAGE.COMP.TS
  import { ProductService } from '@spartacus/core';
  constructor(private productService: ProductService) { }
  this.selectedProduct$: Observable<ProductDetails> = this.productService.get(PRODUCT-CODE) as Observable<ProductDetails>;
  OR
  import { CurrentProductService } from '@spartacus/storefront';
  constructor(private currentProductSerice: CurrentProductService) { }
  this.productData$: Observable<ProductDetails> = this.currentProductSerice.getProduct() as Observable<ProductDetails>;


HAMBURGER-MENU SERVICE (navigation drawer)
==============================================
1. COMP.HTML
--------------------
<ng-container
   [cxComponentWrapper]="{
      flexType: 'HamburgerMenuComponent',
      typeCode: 'HamburgerMenuComponent'
   }">
</ng-container>
2. COMP.SCSS
--------------------
::ng-deep {
  cx-hamburger-menu {
    .hamburger-inner,
    .hamburger-inner::before,
    .hamburger-inner::after {
      background-color: var(--black);
    }
  }
}
3. COMP.TS
---------------------
import { HamburgerMenuService } from '@spartacus/storefront';
constructor(private hamburgerMenuService: HamburgerMenuService) { }
this.hamburgerMenuService.isExpanded.pipe(takeUntil(this.unsubscribe$)).subscribe((isExpanded: boolean) => { });


SIGNUP / LOGIN / LOGOUT SERVICES
======================================
A.
import { UserRegisterFacade } from '@spartacus/user/profile/root';
constructor(private userService: UserRegisterFacade) {}
this.userService.register(<any>{
  firstName: formData.firstName,
  lastName: formData.lastName,
  uid: formData.email.toLowerCase(),
  password: formData.passw,
  phoneNumber: formData.phone
}).pipe(takeUntil(this.unsubscribe$)).subscribe((_) => {}, (err: any) => {});
B.
import {AuthService} from '@spartacus/core';
constructor(protected auth: AuthService) { }
API call: POST | URL: https://BASE-URL-public.model-t.cc.commerce.ondemand.com/authorizationserver/oauth/token
          REQUEST BODY: {username, password} | RESPONSE: {access_token:'', refresh_token:'', expires_in:'', token_type:'', scope:''}
Redirect to: `LAST VISITED PAGE` on successful login
from(this.auth.loginWithCredentials(email.toLowerCase(), password)).pipe(        // backend accepts lowercase emails only
    withLatestFrom(this.auth.isUserLoggedIn()),
    tap(([_, isLoggedIn]) => {
        if (isLoggedIn) {
            this.globalMsgService.remove(GlobalMessageType.MSG_TYPE_ERROR);      // Remove error message on successful login (bad username/password combination)
        }
        this.cd.markForCheck();
    })
).subscribe((res) => {}, (err) => {});
C.
API call: POST | URL: https://BASE-URL-public.model-t.cc.commerce.ondemand.com/authorizationserver/oauth/revoke
          REQUEST BODY: {baseSite:'', token_type_hint:'', token:''} | RESPONSE: NA
Redirect to: `/login` on successful logout
this.auth.logout();


USER SERVICES
=========================
For complete data to be available in API response , add fields=FULL
A. USER PROFILE
--------------------
backend: { occ: { endpoints: { user: 'users/${userId}?fields=FULL' } } }
import { User, UserAccountFacade } from '@spartacus/user/account/root';
constructor(private userAccountService: UserAccountFacade) { }
A.1.
this.userAccountService.get().pipe(takeUntil(this.unsubscribe$)).subscribe((resp) => {
  this.userInfo = resp;
  this.cdRef.markForCheck();
}, (_) => {});

B. USER ADDRESS
----------------------
backend: { occ: { endpoints: { addresses: 'users/${userId}/addresses?fields=FULL' } } }
import { UserAddressService, Address } from '@spartacus/core';
constructor(private userAddressService: UserAddressService) { }
B.1.
this.userAddressService.addUserAddress({
      firstName: 'NEW FIRST NAME',
      lastName: 'NEW LAST NAME',
      line1: 'NEW Street Line 1',
      line2: 'NEW Street Line 2',
      town: 'NEW Town',
      postalCode: '2000',
      country: {
        isocode: 'AU',
        name: 'Australia',
      },
});
B.2.
a. this.userAddressService.loadAddresses();
   this.userAddressService.getAddresses().pipe(takeUntil(this.unsubscribe$)).subscribe((resp: Address[]) => {
     this.userAddresses = resp;
   }, (_) => {});
b. this.userAddressService.verifyAddress({
        firstName: 'NEW FIRST NAME',
        lastName: 'NEW LAST NAME',
        line1: 'NEW Street Line 1',
        town: 'NEW Town',
        postalCode: '2000',
        country: {
          isocode: 'AU',
          name: 'Australia',
        },
   }).pipe(takeUntil(this.destroy$)).subscribe((data) => { }, (_) => { });
B.3.
a. this.userAddressService.setAddressAsDefault(ADDRESS_ID);
b. this.userAddressService.updateUserAddress(ADDRESS_ID ?? '', {
      firstName: 'Rakshit',
      lastName: 'Kapoor',
      line1: 'Shastri Nagar',
      town: 'Amritsar',
   });
B.4.
this.userAddressService.deleteUserAddress(ADDRESS_ID);


NORMALIZERS
===============
Normalizers are used for data mapping that suits requirement of project.
Here in this example, seoTitle and description of page is modified, which is useful for SEO.
1. APP.MODULE.TS
--------------------
{ provide: CMS_PAGE_NORMALIZER, useClass: CUSTOM-PageNormalizer, multi: true }
2. CUSTOM-PageNormalizer.TS
-------------------------------
import { Converter } from '@spartacus/core';
@Injectable({ providedIn: 'root' })
export class CUSTOM-PageNormalizer implements Converter<CmsPage, CmsStructureModel> {
  convert(source: CmsPage, target: CmsStructureModel = {}): CmsStructureModel {
    return { ...target, page: {...target.page, description: source.description, seoTitle: source.seoTitle} };
  }
}


PAGE META RESOLVERS
======================
These allow for adding/changing page meta data like title, description, canonical url etc. , which is useful for SEO
1. APP.MODULE.TS
---------------------
providers: [
  provideConfig(CUSTOM-PageMetaConfig),
  { provide: SeoMetaService, useExisting: CUSTOM-SeoService },
  { provide: PageMetaService, useExisting: CUSTOM-PageMetaService },
  { provide: ProductPageMetaResolver, useExisting: CUSTOM-ProductPageMetaResolver },
  { provide: PageMetaResolver, useExisting: CUSTOM-CategoryPageMetaResolver, multi: true },
  { provide: PageMetaResolver, useExisting: CUSTOM-DepartmentPageMetaResolver, multi: true },
  { provide: SearchPageMetaResolver, useExisting: CUSTOM-SearchPageMetaResolver }
]
2. CUSTOM-PageMetaConfig.TS
------------------------------                                            // import in APP.MODULE.TS
import { PageMetaConfig } from "@spartacus/core";
export const CUSTOM-PageMetaConfig: PageMetaConfig = {
  pageMeta: {
    resolvers: [
      { property: 'title', method: 'resolveTitle'},
      { property: 'heading', method: 'resolveHeading'},
      { property: 'breadcrumbs', method: 'resolveBreadcrumbs' },
      { property: 'description', method: 'resolveDescription' },
      { property: 'image', method: 'resolveImage' },
      { property: 'robots', method: 'resolveRobots' },
      { property: 'canonicalUrl', method: 'resolveCanonicalUrl' }
    ],
    canonicalUrl: {
      forceHttps: true,
      forceWww: false,
      removeQueryParams: true,
      forceTrailingSlash: false,
    },
    enableInDevMode: false,
  }
};
3. CUSTOM-RESOLVERS.TS
-------------------------
NOTE: For CUSTOM-RESOLVERS implementations defined in `useExisting`, refer SPARTACUS DEMO-CODE REPO, cloned from GITHUB
Eg:
constructor(protected productSearchService: ProductSearchService, protected cms: CmsService, protected translation: TranslationService,
            protected basePageMetaResolver: BasePageMetaResolver) {
   super(productSearchService, cms, translation, basePageMetaResolver);
   this.pageType = PageType.CATEGORY_PAGE;
   this.pageTemplate = 'DepartmentPageTemplate';                                 // connect page resolver to specific pageTemplate
}
A. resolveTitle(): Observable<string> {
    return of('Custom title');
   }
B. resolveDescription(): Observable<string> {
    return this.productData$.pipe(
      switchMap((product) =>
        this.translation.translate('pageMetaResolver.product.description', {
          description: product.metaDescription,
        })));
   }
C. resolveCanonicalUrl(): Observable<string> {
    return combineLatest([this.baseSiteService.get(), this.product$]).pipe(
      map(([baseSite, product]) => {
        const baseUrl = (baseSite as any).configMap.entry.find(
          (obj: any) => obj.key === 'canonicalBaseUrl'
        ).value;
        const url = `${baseUrl}${product.url}`;
        return this.pageLinkService.getCanonicalUrl({}, url);}));
   }


OUTLETS
======================
REFERENCE: https://vranjan.dev/posts/sap-spartacus-overriding-components-using-outlets/
           https://sap.github.io/spartacus-docs/outlets/
It allows to customize UI that is provided by default and to plug custom UI into DOM.
It can be used in two ways Template-Driven Outlets and Component-Driven Outlets.
A. Template-Driven Outlets (via .HTML)
   - cxOutletRef: It is used to add reference to outlet. The cxOutletRef directive expects slot position or template name.
   - cxOutletPos: It is used to define where should the outlet render with respect to cxOutletRef defined, i.e.
                  [cxOutletPos]="outletPositionVAR.BEFORE" | [cxOutletPos]="outletPositionVAR.AFTER" | [cxOutletPos]="outletPositionVAR.REPLACE"
A.1 .module.TS
    ----------------
    import { OutletRefModule } from '@spartacus/storefront';
    imports: [ OutletRefModule ]
A.2 .comp.TS
    ----------------
    import { OutletPosition } from "@spartacus/storefront";
    outletPositionVAR = OutletPosition;
A.3 .comp.HTML
    ----------------
    <ng-template cxOutletRef="Section1" [cxOutletPos]="outletPositionVAR.BEFORE">
           <h1>Hot SALE</h1>
    </ng-template>
B. Component-Driven Outlets (via .TS)
   - id: Where we want change i.e. similar to `cxOutletRef`
   - positon: What we want to do with outlet i.e. replace, add before or add after i.e. similar to `cxOutletPos`
   - component: Which component we want to show.
B.1 .module.TS
    ----------------
    import { provideOutlet, OutletPosition } from '@spartacus/storefront';
    providers: [
      provideOutlet({
           id: 'ContentPage1Template',
           position: OutletPosition.REPLACE,
           component: CustomOutletsComponent,
      })
    ]


PAGE NOT FOUND REDIRECTION
==============================
REFER: code sample in `server.prod.ts`, `server/server-api`, `server/node.helper`, `server/baseurl-mappings` in `deployment` folder.
OR
Map `/not-found` page's `ErrorPageTemplate`s ErrorComponent from backend with custom angular component.
Spartacus automatically redirects to `/not-found` in case route does not exist.


STYLES
===============
A. SPARTA LIB + MIXINS
-------------------------
Spartacus provides default styling library called Sparta in the @spartacus/styles package.
This package should be imported into project through the `styles.scss` file.
src/styles.scss
------------------
$primary: #e502bf                                                          // if any new value to scss variables, has to be re-assigned.
$font-weight-normal: 500;                                                  // this is done before Sparta library import.
@import '@spartacus/styles/scss/cxbase/mixins';

B. BREAKPOINT SERVICE
-------------------------
Spartacus provides BreakpointService, which allows same control as media queries, within TS files.
It is better to use as it responds to resize event.
Create a `responsive.SERVICE.TS` file, that can be injected in any COMPONENT.
import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
import { WindowRef } from '@spartacus/core';
import { BREAKPOINT, BreakpointService, LayoutConfig } from '@spartacus/storefront';
import { Observable } from 'rxjs';
@Injectable({
  providedIn: 'root',
})
export class ResponsiveService extends BreakpointService {
  constructor(protected winRef: WindowRef, layoutConfig: LayoutConfig, @Inject(PLATFORM_ID) platform: any) {
    super(winRef, layoutConfig, platform);
  }
  isMobile$: Observable<boolean> = this.isDown(BREAKPOINT.sm);  // when referring DOWN, it picks up limit of next breakpoint, here sm < 768px
  isDesktop$: Observable<boolean> = this.isUp(BREAKPOINT.lg);   // when referring UP, it picks up limit of same breakpoint, here lg >= 992px
}
