Spartacus is Angular-based JavaScript storefront for SAP Commerce Cloud.
Spartacus talks to SAP Commerce Cloud exclusively through the Commerce REST API.
Starting with version 5.0, “SAP Commerce Cloud, Composable Storefront” is name for official release of project “Spartacus” libraries published by SAP.

Spartacus Code Repo, must be cloned on development machine, to have reference for builtin core features like cart, search etc.
GITHUB REPO: https://github.com/SAP/spartacus
REFERENCE  : https://help.sap.com/docs/SAP_COMMERCE_COMPOSABLE_STOREFRONT/cfcf687ce2544bba9799aa6c8314ecd0/e38d45609de04412920a7fc9c13d41e3.html

Storefront Version
REFERENCE: https://github.com/SAP/spartacus#requirements
For which version of    Node, Angular, Yarn, NPM    to use with Spartacus(Composable Storefront) version, refer above website

Storefront Update
REFERENCE: https://help.sap.com/docs/SAP_COMMERCE_COMPOSABLE_STOREFRONT/10a8bc7f635b4e3db6f6bb7880e58a7d/7266f6f01edb4328b4e09df299ea09be.html
NOTE: When update has finished running, inspect your code for comments that begin with // TODO:Spartacus
NOTE: Also update `manifest.json` file , present in 'js-storefront' directory
      So that CCv2 can pick correct version of NodeJS as per storefront version

SmartEdit
REFERENCE: https://help.sap.com/docs/SAP_COMMERCE_CLOUD_PUBLIC_CLOUD/e1391e5265574bfbb56ca4c0573ba1dc/a4b1ea8d8a7249d28ec4aa0e58ff5518.html
           https://sap.github.io/spartacus-docs/smartEdit-setup-instructions-for-spartacus/
Available via @spartacus/smartedit, it allows for creating new pages on website via an interactive GUI.
To access SmartEdit : https://backoffice.HOST-ENV-public.model-t.cc.commerce.ondemand.com/smartedit
`SmartEditFeatureModule` module is imported in `spartacus-features.module.ts`. Inside `SmartEditFeatureModule`, it is provided with config for allowed origins.
1. add browserURL for storefront be allowed inside `whiteListedStorefronts` of Configuration Editor(Settings icon in top right) of SmartEdit with admin login.
   NOTE: We can try adding port 443 to browserURL, if incase configuration does not work.
2. ensure that WCMS Cockpit Preview URL is set in BackOffice(Website > yoursite > WCMS Properties > WCMS Cockpit Preview URL),same as browserURL for storefront
   NOTE: We can try adding port 443 to browserURL, if incase configuration does not work.
3. a. from CCv2 -> Security -> HTTP Response Header Set -> Create
        Code: jsapps
        Name: Header for JSapps
        Description: Additional response header set for service jsapps
        HeaderName: X-Frame-Options
        HeaderValue: ''(leave this blank)
        ApplyAction: UNSET
        ApplyCondition: ALWAYS
   b. now move to Environments -> yourenvironemt -> JS-Storefront -> Add this `Header for JSapps` from dropdown to this environment
4. allowOrigin adds SmartEdit to storefront's list of permitted domains, so that it can be used to edit storefront in a cross-origin setup.
   NOTE: a. Port must be specified with origin (https is 443).
         b. Any `.`(dot) in origin should be added explicitly , because `*` wildcard can only replace just one subdomain and cannot replace `.`(dot)
         provideConfig(<SmartEditConfig>{
           smartEdit: {
             storefrontPreviewRoute: 'cx-preview',
             allowOrigin: 'localhost:9002, *.*.model-t.cc.commerce.ondemand.com:443, *.HOSTNAME.com:443' }
         })

ASM (Assisted Service Mode)
Available via @spartacus/asm, it allows for a Super-User functionality where an agent can login to any customer account and check their cart etc.
`AsmFeatureModule` module is imported in `spartacus-features.module.ts`.
To access ASM : append `?asm=true` to website. Eg: https://HOSTNAME.com?asm=true
A. 

B.
Login with credentials and custom backend API will let you know that logged in user is AGENT or NORMAL user.
If AGENT, then it will redirect to /selectCustomer component screen, to choose customer to emulate as.
We will set userId to as selected customer id and it is then available for entire application, to be passed in API calls.
On Logout, it will first logout from customer session and redirect to /selectCustomer component screen,
here again on /selectCustomer component screen, click of Logout, will logout AGENT.
B.1. Login component
-------------------------
this.customAsmService.checkIfAsmBranchManager(userId).subscribe((isAgent) => {
  if (isAgent) {
      this.customAsmService.authorizeCustomerSupportAgent(userId, password).then(() => {
              this.windowRef.localStorage?.setItem('user_login_type', LOGIN_TYPE.ASM);
              this.router.navigate(['/selectCustomer']);
              this.cd.markForCheck();
      })
      .catch((err) => {
              this.globalMessageService.remove(GlobalMessageType.MSG_TYPE_ERROR);
              this.invalidCredentials = true;
              this.cd.markForCheck();
      });
  } else {
          // NORMAL USER LOGIN , REFER: SIGNUP / LOGIN / LOGOUT SERVICES notes
  }
},
(error) => { }
);
B.2. On Logout
-------------------------
// IMPLEMENT CUSTOM-AUTH SERVICE , REFER: SIGNUP / LOGIN / LOGOUT SERVICES notes
override async coreLogout() {
    let isCustomerEmulated;
    this.userIdService
      .isEmulated()
      .subscribe((emulated) => (isCustomerEmulated = emulated))
      .unsubscribe();
    if (isCustomerEmulated) {
      this.windowRef.localStorage?.setItem('user_login_type', LOGIN_TYPE.ASM);
      this.router.navigate(['/selectCustomer']);
    } else {
      this.windowRef.localStorage?.setItem('user_login_type', LOGIN_TYPE.USER);
      super.coreLogout();
    }
}
B.3. CUSTOM-ASM.service.TS
-----------------------------
import { Store } from '@ngrx/store';
import { AsmAuthStorageService } from '@spartacus/asm/root';
import {AuthActions,AuthToken,OAuthLibWrapperService,OccEndpointsService,UserIdService,WindowRef} from '@spartacus/core';
export class CUSTOM-ASM-SERVICE {
  constructor(private occEndpointService: OccEndpointsService,private http: HttpClient,protected authStorageService: AsmAuthStorageService,
    protected userIdService: UserIdService,protected oAuthLibWrapperService: OAuthLibWrapperService,
    protected store: Store,protected windowRef: WindowRef) { 
      /* IF USER TRIES TO CHANGE URL FROM ADDRESS BAR WITHOUT SELECTING CUSTOMER, DO NOT ALLOW NAVIGATION */
      this.isCustomerSupportAgentLoggedIn().subscribe((isASMuser) => {
            if (isASMuser) { this.router.navigate(['/selectCustomer']); }
      });
  }

  public isCustomerSupportAgentLoggedIn(): Observable<boolean> {
    return this.authStorageService.getToken().pipe(map((token) =>
            Boolean(token?.access_token) && this.windowRef.localStorage?.getItem('user_login_type') === LOGIN_TYPE.ASM
        ));
  }

  async authorizeCustomerSupportAgent(userId: any, password: any): Promise<void> {
    try {
      await this.oAuthLibWrapperService.authorizeWithPasswordFlow(userId, password);
    } finally { }
  }

  // called after selecting customer on /selectCustomer component screen
  public startCustomerEmulationSession(customerId: string): void {
    this.store.dispatch(new AuthActions.Logout());
    this.userIdService.setUserId(customerId);
    this.store.dispatch(new AuthActions.Login());
    this.windowRef.localStorage?.setItem('user_login_type', LOGIN_TYPE.USER);
  }

  checkIfAsmBranchManager(name: string) {
    const url = this.occEndpointService.buildUrl('checkAsmBranchManager', { urlParams: { userName: name } });
    return this.http.get(url, {}).pipe(catchError((err) => throwError(err)));
  }
}
B.4. SELECT-CUSTOMER.comp.TS
-------------------------------
i. COMPONENT TO SELECT CUSTOMERS FOR EMULATION
import { UserIdService } from '@spartacus/core';
constructor(private userIdService: UserIdService) { 
  this.userIdService.clearUserId();
}
ii. ROUTE GUARD FOR /selectCustomer
/* Only ASM user can open select customer component. */
   REFER: ROUTE GUARDS notes
iii. ROUTE GUARD FOR /login
/*
Checks if there isn't any logged in user. Use to protect pages dedicated only for guests (eg. login page) so that ASM user cannot go back to /login page.
Added to LOGIN-PAGE-MODULE
ConfigModule.withConfig({ cmsComponents: { ReturningCustomerLoginComponent: {
      component: CUSTOM-LoginPageComponent,
      guards: [CUSTOM-NotAuthGuard],
}}})
*/
import { Router, UrlTree } from '@angular/router';
import { AuthService, SemanticPathService } from '@spartacus/core';
@Injectable({providedIn: 'root'})
export class CUSTOM-NotAuthGuard {
  constructor(protected authService: AuthService,private asmauthService: CUSTOM-ASM-Service,protected semanticPathService: SemanticPathService,
              protected router: Router) {}
  canActivate(): Observable<boolean | UrlTree> {
    return this.authService.isUserLoggedIn().pipe(
      withLatestFrom(this.asmauthService.isCustomerSupportAgentLoggedIn()),
      map(([isLoggedIn, isASMuser]) => {
        if (isLoggedIn) {
          if (isASMuser) {
            return this.router.createUrlTree(['/selectCustomer']);
          }
          return this.router.parseUrl(this.semanticPathService.get('home') ?? '');
        }
        return !isLoggedIn;
}));}}
B.5. comp.COMPONENT.TS
-----------------------------
1.
// Check if customer emulated session is ON
import { CsAgentAuthService } from '@spartacus/asm/root';
constructor(private csAgentAuthService: CsAgentAuthService) { }
this.csAgentAuthService.isCustomerEmulated().pipe(takeUntil(this.destroy$)).subscribe((isEnabled: boolean) => { this.isASMEnabled = isEnabled; });
OR
import { UserIdService } from '@spartacus/core';
constructor(private userIdService: UserIdService) { }
this.userIdService.isEmulated().pipe(takeUntil(this.destroy$)).subscribe((emulated) => { isCustomerEmulated = emulated });
2.
// GET current userId, this will be used in APIs to replace variable ${userId}
this.userIdService.getUserId().pipe(take(1)).subscribe((userId) => { this.userId = userId; });
OR
// in a service method
this.userIdService.takeUserId().pipe(switchMap((userID: string) => {
  return this.http.get(url); 
}));
B.6. USER-ID-INTERCEPTOR.TS
-------------------------------
import { UserIdService } from '@spartacus/core';
@Injectable()
export class UpdateUserIdInterceptor implements HttpInterceptor {
  constructor(private userIdService: UserIdService) {}
  intercept(req: HttpRequest<any>, handler: HttpHandler): Observable<HttpEvent<any>> {
    return this.userIdService.getUserId().pipe(take(1),switchMap((userId: any) => {
        let modifiedReq = req;
        // CHECK IF URL IS A PLP , PDP or ANY OTHER BUILT-IN SPARTACUS URL
        if (req.url.includes('fields=PLP_FULL') || req.url.includes('fields=PDP_FULL')) {
          if (userId) {
            const updatedUrl = modifiedReq.url.replace('${userId}', encodeURI(userId));
            modifiedReq = modifiedReq.clone({ url: updatedUrl });
          }
        }
        return handler.handle(modifiedReq);
      })
    );
  }
}


HAC (Hybris Administrative Console or BackOffice Admin Console)
It is for administrator to handle entire functions and operations in website like:
ImpEx (Import-Export), Groovy Script, Configuration, Cache, Cron Job
Use-Case-1: CORS issue: Check property 'allowedHeaders' through HAC , delete web application services for CORS , rerun CORS impex

RBSC (Repository Based Shipment Channel)
To install composable storefront, need to set up access to composable storefront libraries.
RBSC website: https://ui.repositories.cloud.sap/www/webapp/users/
- Create an S-user for RBSC that has the appropriate licenses to download the composable storefront libraries.
- An S-user account can see Composable Storefront License in list of licenses.
  If the Composable Storefront License does not appear in this list, there will be an error when downloading the packages.
- Click on Add User and create a technical user.
- In User Management tab of RBSC website, select the technical user and copy the generated NPM Base64 Credentials, required for .npmrc file in project

CCv2 (Commerce Cloud Version 2)
https://portal.commerce.ondemand.com
- Here we need to login with S-user ID.
- It allows to make a BUILD from configured repository's branch and then deploy to specific ENVIRONMENT.

SETUP
=============
> ng new <APP_NAME> --style=scss --routing=false
> cd <APP_NAME>
> create an .npmrc file with following content | NOTE: // in second line | NOTE: NPM-CREDENTIALS-FROM-RBSC copied as in above steps
      @spartacus:registry=https://73554900100900004337.npmsrv.base.repositories.cloud.sap/
      //73554900100900004337.npmsrv.base.repositories.cloud.sap/:_auth=NPM-CREDENTIALS-FROM-RBSC
      always-auth=true
> ng add @spartacus/schematics@VERSION --baseUrl <BACKEND_URL> --baseSite=<CONFIG> --ssr --pwa
      --baseUrl: url of backend
      --baseSite: name of storefront
      --ssr: enable SSR features of app
      --pwa: enable PWA features of app

B2B setup
----------------
When you run this command (ng add @spartacus/schematics), you are first asked to choose either a B2C or B2B configuration.
The only difference between the two options is that the B2B configuration has a few additional OCC endpoints and a different checkout configuration.
Specifically, the B2B configuration adds the `defaultB2bOccConfig` and `defaultB2bCheckoutConfig` from @spartacus/setup.
NOTE:
Spartacus does not support B2C and B2B storefronts running together in a single storefront application.
When you enable B2B Commerce Organization, the B2C storefront will load but not work properly.


1. It creates a directory named `spartacus` and inside it:
    1. creates module `spartacus-configuration.module.TS`
       // This will have all configs for spartacus like baseUrl, baseSite etc.
       import { environment } from 'src/environments/environment';
       import { storeEndpoints } from '../core/config/endpoints/store-endpoints.const';
       import { layoutConfig } from '../core/config/layout-config';
       import { appTranslations } from '../core/constants/translations';
       import { mediaConfig } from '../shared/media/media.config';
       @NgModule({
          declarations: [],
          imports: [],
          providers: [
             provideConfig(layoutConfig),               // custom page layout config file
             provideConfig(mediaConfig),                // media config file for images
             provideConfig({                            // image loading strategy
                imageLoadingStrategy: ImageLoadingStrategy.LAZY,
             } as MediaConfig),
             provideConfig(<OccConfig>{                 // base URL config
                backend: {
                  occ: {
                    baseUrl: environment.occBaseUrl,    // value only defined in `environment.ts`, however in `environment.prod.ts`(PRODUCTION) it is `undefined`
                                                           // For prod deployment use meta tag in INDEX.HTML,`content` attr is replaced with URL from CCv2 config
                                                           // i.e.  <meta name="occ-backend-base-url" content="OCC_BACKEND_BASE_URL_VALUE" />
                                                           // i.e.  <meta name="media-backend-base-url" content="MEDIA_BACKEND_BASE_URL_VALUE" />

                    prefix: '/app/v2/'                  // if not specified, the default('/occ/v2/') comes from Spartacus `defaultOccConfig`
                  },
                },
             }),
             provideConfig(<OccConfig>storeEndpoints),  // endpoints config file for OccEndpointsService
             provideConfig(<SiteContextConfig>{         // base SITE config
                context: {
                   currency: ['AUD'],
                   language: ['en'],
                   baseSite: ['PROJECT_NAME'],
                },
             }),
             provideConfig(<I18nConfig>{
                 i18n: {
                   resources: translations,
                   chunks: translationChunksConfig,
                   fallbackLang: 'en',
                 },
             }),
             provideConfig(<I18nConfig>{
                i18n: { resources: appTranslations },   // translations config file

                state: {                               // Spartacus runs XHR requests on server, and then again on client-side when application bootstraps.
                  ssrTransfer: {                       // Spartacus includes part of the NgRx state with the server-side rendered HTML
                    keys: {                            // This prevent unnecessary calls to back end for state that was already populated on server,
                      products: StateTransferType.TRANSFER_STATE,
                      cms: StateTransferType.TRANSFER_STATE,
                    },
                  },
                },
             }),
          ]})
       export class SpartacusConfigurationModule {}
    2. create module `spartacus-features.module.TS`
       // All module imports like FooterNavigationModule, BreadcrumbModule etc.
    3. create module `spartacus.module.TS`
       // import above modules along with BaseStorefrontModule
       @NgModule({
          declarations: [],
          imports: [SpartacusFeaturesModule, SpartacusConfigurationModule, BaseStorefrontModule],
          exports: [BaseStorefrontModule]
       })
       export class SpartacusModule {}
    
2. app.module.TS
------------------
- Remove default angular module `AppRoutingModule` from import (if added when creating Angular project), else nothing will be displayed.
- import `spartacus.module.TS` that we created above, which had other SPARTACUS modules imported.

3. app.component.HTML
-----------------------
- Entire content is deleted and replaced by a single HTML tag
  <cx-storefront></cx-storefront>
  
NOTE: if missed some config, while creating app, it can be done later too
> ng g @spartacus/schematics:add-pwa                    // adds spartacus-specific PWA module
> ng g @spartacus/schematics:add-ssr                    // adds SSR configuration

NOTE: If not installed particular integration lib / feature lib (package) during initial set up of storefront like
@spartacus/asm | @spartacus/cart | @spartacus/checkout | @spartacus/product | @spartacus/smartedit | @spartacus/styles | @spartacus/user   install later using:
> ng add <package-name>
NOTE: a. Follow additional steps as per documentation for each package which is added later,
         as it might require some changes to `angular.json` and other config file(s), which had been done automatically, if added earlier while adding schematics.
      b. Adding these packages(whether earlier or later),adds `@import '..\..\styles-config';` to these features, which may cause ERROR, we can remove this import


MODULES / COMPONENTS / LAYOUT
=================================
> ng g m custom-pdp
> ng g c custom-pdp/custom-product-intro

// DO NOT import these feature modules to `APP.MODULE.TS` directly, but
// import them to  `spartacus-features.MODULE.TS` which is imported by  `spartacus.MODULE.TS` which is imported by `APP.MODULE.TS`
// This allows for LAZY-LOADING of modules that is handled by spartacus.

// To use feature components that are available via Spartacus Storefront, they are to be imported.
// `withConfig` defines that it is a CMS component.
// flexType or typeCode value that we receive from backend is used for mapping to our SPARTACUS component
custom-pdp.module.TS
----------------------
@NgModule({
    declarations: [CUSTOM-COMP-NAME],
    imports: [
        CommonModule,
        StarRatingModule,                                // module import from spartacus storefront
        ConfigModule.withConfig({
            cmsComponents: {
                TYPE-CODE-NAME: {
                    component: CUSTOM-COMP-NAME
                }
            }
        } as CmsConfig)
    ]
})
export class CustomPdpModule {}

custom-product-intro.comp.HTML
---------------------------------
<ng-container *ngIf = "product$ | async as product">
    <h1>{{product?.name}}</h1>
    <h3>{{product?.price?.formattedValue}}</h3>
    <cx-star-rating                                     // comp used from spartacus storefront, must be imported in that module
      [rating] = "product?.averageRating"
      [disabled] = "true">
    </cx-star-rating>
</ng-container>

layout-config.TS                    // a custom layout file to be provided to `spartacus-configuration-module.TS`
---------------------               // layouts(TEMPLATE key from pages API) rendered in <CX-PAGE-LAYOUT> and slots(POSITION keys from pages API) in <CX-PAGE-SLOT>
import { LayoutConfig } from '@spartacus/storefront';
export const layoutConfig: LayoutConfig = {                        // some layouts are pre-defined from SPARTACUS like header, navigation, footer
  layoutSlots: {
      header: {                                                    // <cx-page-layout class="header"></cx-page-layout>
        lg: { slots: ['PreHeader', 'SiteLogo', 'SearchBox'] },     // <cx-page-slot  class="PreHeader" position="PreHeader"></cx-page-slot>
        slots: ['PreHeader', 'SearchBox']                             // less than lg breakpoint, these slots will be rendered
      },
      navigation: {                                                // <cx-page-layout class="navigation"></cx-page-layout>, for NAVIGATION DRAWER container
        lg: { slots: ['MegaMenu'] },                               // lg(>=992px), these slots(position vals) will be rendered in <cx-page-slot>
        md: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] },     // md(>=768px)
        sm: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] },     // sm(>=576px)
        xs: { slots: ['PreHeader', 'SearchBox', 'MegaMenu'] }      // xs(<576px)
      },
      footer: {                                                    // <cx-page-layout class="footer"></cx-page-layout>
        slots: ['Footer']                                          // <cx-page-slot class="Footer" position="Footer"></cx-page-slot>
      },
      LandingPage2Template: {                                      // <cx-page-layout class="LandingPage2Template"></cx-page-layout>
        lg: {
          pageFold: 'UpSelling',                                   // Above-the-fold loading is an indication to speed up initial creation of slots
                                                                   // pageFold: indicates last page slot that should be rendered above the fold.
                                                                   // and are prioritized ahead of page slots that are “below the fold”/after this slot
          slots: ['Summary', 'UpSelling', 'Section2B']
        },
        pageFold: 'Section2B',
        slots: []
      },
      SearchResultsListPageTemplate: {
        slots: ['SearchDescription', 'SearchResultList']
      }
  }
}
NOTE: Components come from backend side.
An API call , /pages?lang=EN&curr=AUD , gets all components that are used.
Depending on current browser route URL, this API payload's QUERY-PARAMS change:
A. ContentPage  ( Eg: https://HOSTNAME.com/ROUTE )
   pageType: ContentPage, pageLabelOrId: /ROUTE
B. CategoryPage ( Eg: https://HOSTNAME.com/Categories/Kids/c/SUBCATEGORY )
   pageType: CategoryPage, code: SUBCATEGORY
C. ProductPage  ( Eg: https://HOSTNAME.com/Categories/Kids/Nursery/Dreambaby-Bed-Rail/p/PRODUCT-CODE )
   pageType: ProductPage, code: PRODUCT-CODE
It returns:
contentSlots: {
  contentSlot: [
    {
      components: {
          component: [
            {
              uid: "CustomTileWithTextResponsiveBannerComponent",
              typeCode: "FFCMSContainerComponent",                        // typecode or flexType: mapping to custom spartacus component in MODULE file
              flexType: "FFCMSContainerComponent"                         // NOTE: It depends on backend config, which one to use from these two
            }
          ]
      }
      name: "Tile With Text Banner Slot",
      position: "TileWithTextBanner",                                     // position: included in <cx-page-slot> and used in layout-config.TS
      slotId: "TileWithTextBannerSlot",
      slotShared: false,
      slotUuid: "eyJpdG"
    }
  ]
}
label: "search"
name: "Search Results Page"
robotTag: "INDEX_FOLLOW"
template: "SearchResultsListPageTemplate"                               // template: used in <cx-page-layout>
typeCode: "ContentPage"
uid: "search"
uuid: "eyJp==="


ADD CMS COMPONENT/DATA FROM SLOT, INSIDE ANGULAR COMPONENT
=============================================================
1. MODULE.TS                                    // NOTE: import this module, in SPARTACUS-FEATURES MODULE,
--------------                                  // so that COMP-NAME can render when matches [cxComponentWrapper]
@NgModule({
  providers: [
    provideConfig(<CmsConfig>{
      cmsComponents: {
        TYPE-CODE: {                            // TYPE-CODE is same value as given to  [cxComponentWrapper]  typeCode in COMP.HTML
          component: COMP-NAME,                 // COMP-NAME is component to render, when this typecode matches with [cxComponentWrapper]
        },
      },
    }),
  ],
  declarations: [COMP-NAME],
  exports: [COMP-NAME],
})
export class COMP-NAME-MODULE {}
2. COMP.MODULE.TS
----------------------
import {PageComponentModule} from '@spartacus/storefront';
@NgModule({
    imports: [PageComponentModule, COMP-NAME-MODULE]
})
3. COMP.HTML
---------------
<ng-container *ngIf="component.data$ | async as compData">
 <!-- A. add component using typecode / uid -->
  <ng-container                                // `[cxComponentWrapper]` provides a position for component to render, using `typeCode` value of comp in /pages API
   [cxComponentWrapper]="{                     // this is same as using `slots: ['SLOT-NAME']` in `layout.config.TS`, using `position` value of slot in /pages API
     flexType: compData?.productBrochure?.typeCode,
     typeCode: compData?.productBrochure?.typeCode,
     uid: compData?.productBrochure?.uid
   }">
  </ng-container>

 <!-- B. add data using key from response -->
  <span>{{ compData?.detailErrorMessage }}</span>
</ng-container>
4. COMP.TS
-------------
constructor(public component: CmsComponentData<CmsTabComponent>)


CMS COMPONENTS
========================
1. MODULE.TS
---------------
@NgModule({
  declarations: [CUSTOM-ParagraphComponent, CUSTOM-BannerComponent],
  imports: [
    SupplementHashAnchorsModule,
    ConfigModule.withConfig({
      cmsComponents: {
        CMSParagraphComponent: {
          component: CUSTOM-ParagraphComponent,
        },
        SimpleResponsiveBannerComponent: {
          component: CUSTOM-BannerComponent,
        },
        BannerComponent: {
          component: CUSTOM-BannerComponent,
        },
      },
    }),
  ],
})
export class CmsContentModule {}               // import in `spartacus-features.MODULE.TS`

A. PARAGRAPH COMPONENT
------------------------
  2. CUSTOM-COMP.TS
  --------------------
  import { ParagraphComponent } from '@spartacus/storefront';
  export class CUSTOM-ParagraphComponent extends ParagraphComponent {}
  3. CUSTOM-COMP.HTML
  ---------------------
  <div *ngIf="component.data$ | async as data" [innerHTML]="data.content ?? '' | cxSupplementHashAnchors | safeHtml"></div>

B. BANNER COMPONENT
------------------------
  2. CUSTOM-COMP.TS
  --------------------
  import { BannerComponent } from '@spartacus/storefront';
  export class CUSTOM-BannerComponent extends BannerComponent {}
  3. CUSTOM-COMP.HTML
  ---------------------
  <div *ngIf="component.data$ | async as data">
    <img *ngIf="data.media && data.media.src"
      [attr.src]="data.media.src"
      [attr.alt]="data.media.alt"
      [attr.role]="data.media.role"
    />
  </div>


LAUNCH-DIALOG SERVICE (POPUP/MODAL/DIALOG)
=============================================
1. MODEL.TS/ENUM.TS
----------------------
import '@spartacus/storefront';
declare module '@spartacus/storefront' {
  const enum LAUNCH_CALLER {
    FABRIC_SELECT = 'FABRIC_SELECT',
    NEAREST_STORES = 'NEAREST_STORES'
  }
}
2. MODULE.TS
---------------
export const defaultLaunchConfig: LayoutConfig = {
  launch: {
    [LAUNCH_CALLER.FABRIC_SELECT]: {
      inlineRoot: true,                          // Renders component directly inside <cx-storefront>, i.e. a global dialog
      component: PopupComponent_1,               // component to render
      dialogType: DIALOG_TYPE.DIALOG,            // POPOVER(no backdrop) | POPOVER_CENTER_BACKDROP(backdrop) | DIALOG(backdrop) | SIDEBAR_START | SIDEBAR_END
    },
    [LAUNCH_CALLER.NEAREST_STORES]: {
      inlineRoot: true,
      component: PopupComponent_2,
      dialogType: DIALOG_TYPE.DIALOG,
    }
}};
@NgModule({
  declarations: [],
  imports: [],
  providers: [provideDefaultConfig(defaultLaunchConfig)],
})
3. COMP.TS
-------------
import { LaunchDialogService, LAUNCH_CALLER } from '@spartacus/storefront';
@ViewChild('NearestStoreModalOpen') private dialogTriggerRef!: ElementRef;
constructor(private launchDialogService: LaunchDialogService) {}
A.
this.launchDialogService.openDialogAndSubscribe(LAUNCH_CALLER.NEAREST_STORES, this.dialogTriggerRef, {
  data_key_1: data_value_1,
  data_key_2: data_value_2
});
B.
this.launchDialogService.dialogClose.pipe(takeUntil(this.destroyed$)).subscribe((data: any) => {
  // TODO: data received from .popup.comp.TS on closing dialog
});
4. POPUP.COMP.TS
------------------
// Close on click outside the dialog window
@HostListener('click', ['$event'])
handleClick(evt: UIEvent): void {
  if ((evt.target as any).classList.contains('modal')) {
    this.close();
  }
}
A.
this.launchDialogService.data$.pipe(takeUntil(this.destroyed$)).subscribe((data: any) => {
  // TODO: data received from .comp.TS on opening dialog
});
B.
this.launchDialogService.closeDialog({
  data_key_1: data_value_1,
  data_key_2: data_value_2
});
5. POPUP.COMP.HTML
---------------------
<div class="modal-container">                      // styles applied to `.modal-container` from global STYLES.SCSS
  <div class="header-container">
    <span class="headline">TITLE</span>
    <button type="button" class="closeBtn" aria-label="Close" (click)="close()">
      <i class="fa fa-times"></i>
    </button>
  </div>
  <div class="body-container"></div>
</div>
6. STYLES.SCSS
---------------------
.modal {
  z-index: 1500 !important;
  display: flex !important;
  align-items: center;
  justify-content: center;

  .modal-container {
    width: 90%;
    background-color: var(--white);
    border-radius: 0.5rem;
    padding: 0.5rem;
    @include media-breakpoint-up(md) {
      width: 50%;
    }
  }
}


GLOBAL MESSAGE SERVICE (BANNER MESSAGE SHOWN AT TOP)
=========================================================
1. STYLES.SCSS
--------------------
cx-global-message {
  z-index: 999999;
  position: fixed;
  left: 0;
  right: 0;
  top: 0;
}
2. COMP.TS
---------------------
import { GlobalMessageService, GlobalMessageType } from '@spartacus/core';
constructor(private globalMsgService: GlobalMessageService) {}
A.
this.globalMsgService.add(
  'MSG-STRING' || { key: 'KEY-FROM-TRANSLATIONS-FILE', params: { VARIABLE: VALUE-VARIABLE } },
  GlobalMessageType.MSG_TYPE_CONFIRMATION,                         // MSG_TYPE_CONFIRMATION | MSG_TYPE_ERROR | MSG_TYPE_INFO | MSG_TYPE_WARNING
  3000                                                             // Timeout in milliseconds
);
B.
this.globalMsgService.remove(GlobalMessageType.MSG_TYPE_ERROR);    // Remove message


PAGINATION WIDGET
========================
1. MODULE.TS
-----------------
import { PaginationModule } from '@spartacus/storefront';
@NgModule({
    imports: [PaginationModule]
})
OR
import {ListNavigationModule} from '@spartacus/storefront';
@NgModule({
    imports: [ListNavigationModule]
})
2. COMP.HTML
-----------------
<div *ngIf="(searchResult.pagination?.totalPages ?? 0) > 1">
    <cx-pagination [pagination]="searchResult.pagination" queryParam="currentPage" [defaultPage]="0"></cx-pagination>
    OR
    <cx-pagination [pagination]="OrderHistoryList?.pagination" (viewPageEvent)="pageChange($event)"></cx-pagination>
</div>
3. COMP.TS
------------------
this.searchResult = data;                // data from API response of /search , it will have
                                         // object "pagination": {"currentPage": 1,"pageSize": 24,"sort": "clear","totalPages": 3,"totalResults": 60}
4. APP.MODULE.TS
------------------
For global configuration of pagination widget, add here in app.module.ts
imports: [
 ConfigModule.withConfig({
  pagination: {
    addStart: true,
    addPrevious: true,
    addFirst: true,
    addDots: true,
    rangeCount: 3,
    addLast: true,
    addNext: true,
    addEnd: true,
    substituteDotsForSingularPage: true,
  },
 })
]

INFINITE SCROLL
=========================
REFERENCE: https://help.sap.com/docs/SAP_COMMERCE_COMPOSABLE_STOREFRONT/eaef8c61b6d9477daf75bff9ac1b7eb4/d37bd1496c6c42d5b7a17740ba155e94.html
           https://microlearning.opensap.com/media/Infinite+Scroll+-+SAP+Commerce+Cloud/1_crd2801x
When infinite scroll is enabled in composable storefront, it applies to product search page, as well as category pages in both list and grid views.
When infinite scroll is disabled, composable storefront uses pagination instead. By default, infinite scroll is disabled in composable storefront.
1. APP.MODULE.TS
----------------------
imports: [
    ConfigModule.withConfig({
        view: {
            infiniteScroll: {
                active: true,             // enable / disable infinite scroll , auto loads without any limit/button until products are not found
                productLimit: 50,         // number of products user can scroll through before they are prompted to load more items using SHOW MORE button
                showMoreButton: false,    // true: auto sets "productLimit": 10  i.e. value for productLimit key is ignored | false: productLimit key considered
            },
        },
    })
]


SPINNER WIDGET (LOADER)
===========================
1. loader.MODULE.TS                                            // import this module in `APP.MODULE.TS`
----------------------
import { SpinnerModule } from '@spartacus/storefront';
@NgModule({
  declarations: [LoaderOverlayComponent],
  imports: [SpinnerModule],
  exports: [LoaderOverlayComponent],
})
export class LoaderOverlayModule { }
2. loader.COMP.HTML
-----------------------
<div class="spinner-wrapper" (click)="overlayClick($event)">
  <div class="cx-spinner">
    <cx-spinner></cx-spinner>
  </div>
</div>
3. loader.COMP.TS
-----------------------
overlayClick(evt: Event) {
  evt.preventDefault();
  evt.stopPropagation();
}
4. loader.SERVICE.TS                                            // Inject this loaderService in constructor of any component and use   .show() | .hide()
-----------------------
export class LoaderService {
  public loader$: BehaviorSubject<boolean>  = new BehaviorSubject<boolean>(true);
  show(): void {
    this.loader$.next(true);
  }
  hide(): void {
    this.loader$.next(false);
  }
}
5. APP.COMP.HTML
---------------------
<ff-loader-overlay *ngIf="loading"></ff-loader-overlay>
<cx-storefront></cx-storefront>
6. APP.COMP.TS
---------------------
import { RoutingService } from '@spartacus/core';
constructor(private routingService: RoutingService, private loaderService: LoaderService) { }
this.loaderService.loader$.pipe(takeUntil(this.destroyed$)).subscribe((loading: boolean) => {
    this.loading = loading;
    this.cd.markForCheck();
});
this.routingService.isNavigating().pipe(takeUntil(this.destroyed$)).subscribe((nav: boolean) => {
    if(nav) {
        this.loaderService.show();
    } else {
        this.loaderService.hide();
    }
});


SCROLL TO TOP
=========================
Scroll to top button appears once user scrolls down a page, and disappears when already on top.
It has a default CSS of fixed postion to bottom right.
1. footer.MODULE.TS
-----------------------
import { ScrollToTopModule } from '@spartacus/storefront';
imports: [ScrollToTopModule]
2. footer.COMP.HTML
-----------------------
<cx-scroll-to-top></cx-scroll-to-top>


ACTIONS
========================
Some API calls are handled by spartacus and we do not have control over their success response or failure response.
So, we can make use of actions from ngrx/effects.
Eg:
import { Actions, ofType } from '@ngrx/effects';
import { ProductActions } from '@spartacus/core';
import { CartActions } from '@spartacus/cart/base/core';
constructor(private actions$: Actions) { }
ngOnInit() {
  this.actions$.pipe(ofType(ProductActions.SEARCH_PRODUCTS_FAIL)).subscribe(() => {
     this.loaderService.hide();
  });
  this.actions$.pipe(ofType(CartActions.LOAD_CART_FAIL)).subscribe(() => {
     this.loaderService.hide();
  });
}


TRANSLATION SERVICE
=========================
1. MODULE.TS
--------------
import { I18nModule } from '@spartacus/core';
imports: [I18nModule]
export class COMP-MODULE {}
2. appTranslations.TS                                 // file configured in `spartacus-configuration.MODULE.TS`
------------------------
export const appTranslations = {
    en: {
        HEADER: {                                     // NOTE: same HEADER name inside HEADER
            HEADER: {
                KEY_1: 'VAL_1',
                KEY_2: 'VAL_2 {{VARIABLE}} VAL_2',    // NOTE: use of VARIABLE in {{ }}
            }
        }
    }
}
3.A. COMP.TS
----------------
import { TranslationService } from '@spartacus/core';
constructor(private translationService: TranslationService) { }
this.translationService.translate('HEADER.KEY_1').pipe(first()).subscribe((tData) => { this.val = tData; });
this.translationService.translate('HEADER.KEY_2', {VARIABLE: VAL-OF-VARIABLE}).pipe(first()).subscribe((tData) => { this.val = tData; });
OR
3.B. COMP.HTML
----------------
{{ 'HEADER.KEY_1' | cxTranslate }}
{{ 'HEADER.KEY_2' | cxTranslate: {VARIABLE: VAL-OF-VARIABLE} }}


BASESITE SERVICE
=========================
A.1.
On website initial load, a GET API call is made to `/basesites` i.e. `https://BASE-URL/PREFIX/basesites?fields=FULL&lang=en&curr=USD`
This is handled by spartacus default url mapping. NOTE: This API call response may not have all fields.
So, we can specify key `baseSites` inside ENDPOINTS.CONST.TS file(spartacus-configuration.MODULE.TS) i.e.
backend: { occ: { endpoints: { baseSites: 'basesites?fields=FULL' } } }
It returns all basesite related config and our application can use values depending on UID of basesite data.
A.2.
NOTE: If we specify `baseSite` value in `spartacus-configuration.module.ts`,
that baseSite gets picked up as an active basesite and components are returned accordingly from backoffice in /pages API response.
However, To have multiple domains(websites) having common/shared components, Eg: https://www.freedom.com.au/    and     https://www.freedomfurniture.co.nz/
we need only ONE code repository, also:
- Do NOT specify any basesite in `spartacus-configuration.module.ts` file
- Specify urlPatterns that are returned /basesite API response from backoffice that will determine,
  which domain is being hit from browser, and spartacus will pick it as an active basesite.
- There will be N components(N header, N footer, N banners) created from backoffice, one for each basesite,
  and only one of those will get returned in /pages API response, depending on active basesite.
- To ensure reusability of components, make sure to have colors, text, widgets to be shown/hidden as configurable in FE components that can work for all sites
  and relevant keys available in /pages API response for that component.
B.
import { BaseSiteService } from '@spartacus/core';
constructor(private baseSiteService: BaseSiteService) { }
public showReviewsWidget: boolean = false;
private activeSiteUID: string = '';
this.baseSiteService.get().pipe(takeUntil(this.destroyed$)).subscribe((baseSite) => {
    this.showReviewsWidget = (baseSite as BASESITE-INTERFACE).KEY-FROM-BASESITE;
    this.activeSiteUID = baseSite?.uid ?? '';
});


CMS SERVICE
==========================
import { CmsService, Page } from '@spartacus/core';
constructor(private cmsService: CmsService) { }
A.
public pageData!: Page;
this.cmsService.getCurrentPage().pipe(takeUntil(this.destroyed$)).subscribe((data) => {
    this.pageData = data;
}, () => {});
this.pageData?.template === PageTemplateENUM.VALUE-FROM-PAGES-API-TEMPLATE;
B.
this.cmsService.getComponentData('COMP-UID').pipe(takeUntil(this.destroyed$)).subscribe((compData: CmsComponent) => {
    this.navNode = compData?.navigationNode;
}, () => {});


NAVIGATION SERVICE (navigation menus)
=======================================
NOTE: REFER CODE SAMPLE IN   `misc/navigation-drawer.txt`
1. COMP.TS (mapped in module with navigation slot's comp)
--------------------------------------------------------------
import { NavigationService } from '@spartacus/storefront';
A.
constructor(public navService: NavigationService, public component: CmsComponentData<CmsNavigationComponent>) { }
this.component.data$.pipe(switchMap((compData) => {
  if (compData && compData?.navigationNode) {
    return this.navService.createNavigation(of(compData));
  } else {
    return of(null);
  }
}),
takeUntil(this.destroy$)
).subscribe((navigationNode) => {
  if (navigationNode) {
    this.navNode = navigationNode;
    this.cd.markForCheck();
  }
});
   OR
B.
constructor(public navService: NavigationService, private cmsService: CmsService) { }
this.cmsService.getComponentData('COMP-UID').pipe(switchMap((compData) => {
  if (compData && compData?.navigationNode) {
    return this.navService.createNavigation(of(compData));
  } else {
    return of(null);
  }
}),
takeUntil(this.destroy$)
).subscribe((navigationNode) => {
  if (navigationNode) {
    this.navNode = navigationNode;
    this.cd.markForCheck();
  }
});
2. COMP.HTML
----------------
<CUSTOM-MOBILE-NAVIGATION
  [node]="navNode"
  [resetMenuOnClose]="true">
</CUSTOM-MOBILE-NAVIGATION>


ROUTING
==============
Many routes are built-in with SPARTACUS, and render templates accordingly.
However, we can create CUSTOM routes too.
A
=======
1. APP.MODULE.TS
-------------------
imports: [
    ConfigModule.withConfig({
      routing: {
        routes: {
          FE_PATH_1: { paths: ['BACKEND_PATH_FOR_PAGE_1'] },
          FE_PATH_2: { paths: ['BACKEND_PATH_FOR_PAGE_2'] },
        }
      }
    })
]
2. SPARTACUS-FEATURES.MODULE.TS
----------------------------------
imports: [
    CUSTOM_MODULE_1,
    CUSTOM_MODULE_2
]
3. COMP.TS
-------------------
import { RoutingService } from '@spartacus/core';
constructor(private routingService: RoutingService) {}
navigateFabricSamples() {
    this.routingService.go({
      cxRoute: 'FE_PATH_2',
    });
}
B
======
1. MODULE.TS
--------------------
import { RouterModule, Routes } from '@angular/router';
import { CmsPageGuard } from '@spartacus/storefront';
const STATIC_ROUTE: Routes = [{ path: 'PATH-TO-COMP', component: CUSTOM-Component, canActivate: [CmsPageGuard] }];
@NgModule({
  declarations: [CUSTOM-Component],
  imports: [CommonModule, RouterModule.forChild(STATIC_ROUTE)]
})
export class CUSTOM-Module { }


ROUTE GUARDS
===========================
It is similar to Angular route guards i.e. guard is a service which has canActivate() etc. methods, only difference is how we include these guards.
In Spartacus, it is added with config for mapping components, plus provide builtin guards like    AuthGuard | CheckoutDetailsLoadedGuard | CartNotEmptyGuard
ConfigModule.withConfig({
    cmsComponents: {
        TYPE-CODE: {
            component: FE-COMPONENT,
            guards: [CUSTOM-CheckoutAuthGuard, CartNotEmptyGuard]
        }
    }
})
A. CUSTOM-GUARD.TS
----------------------
// example custom guard for preventing route to /selectCustomer component , REFER: ASM notes
import { AuthRedirectService, AuthService, SemanticPathService } from '@spartacus/core';
@Injectable({providedIn: 'root'})
export class selectCustomerGuard implements CanActivate {
  constructor(protected authService: AuthService,protected authRedirectService: AuthRedirectService,protected semanticPathService: SemanticPathService) {}
  canActivate(): Observable<boolean | UrlTree> {
    return this.asmService.isCustomerSupportAgentLoggedIn().pipe(
      map((isLoggedIn) => {
        if (!isLoggedIn) {
          this.authRedirectService.saveCurrentNavigationUrl();
          return this.router.parseUrl(this.semanticPathService.get('login') ?? '');
        }
        return isLoggedIn;
}));}}


Redirect URL configuration
==============================
On navigation to a page, browser keeps track of last visited page.
So that after logout, when user logs in again, it redirects back to last visited page automatically.
To override this behavior we can use `AuthRedirectStorageService`:
import { AuthRedirectStorageService } from '@spartacus/core';
constructor(private redirectService: AuthRedirectStorageService) { }
A.
this.redirectService.getRedirectUrl().pipe(takeUntil(this.destroy$)).subscribe((url) => { });
B.
this.redirectService.setRedirectUrl('/');


DEFER LOADING OF COMPs
========================
It defers loading of components on page, till they are visible in users viewport
import { DeferLoadingStrategy } from '@spartacus/core';
ConfigModule.withConfig({
    cmsComponents: {
        TYPE-CODE: {
            component: FE-COMPONENT,
             deferLoading: DeferLoadingStrategy.DEFER
        }
    }
})


HTTP REQUESTS (services)
===========================
1. SERVICE.TS
----------------
import { OccEndpointsService, OCC_USER_ID_ANONYMOUS } from '@spartacus/core';
readonly defaultUserId = OCC_USER_ID_ANONYMOUS;                                            // OCC_USER_ID_CURRENT | OCC_USER_ID_ANONYMOUS | OCC_USER_ID_GUEST
constructor(public httpClient: HttpClient, public occEndpointsService: OccEndpointsService) { }
A.
serviceMethod() {
  const url = this.occEndpointsService.buildUrl('KEY-FROM-ENDPOINTS-CONFIG-FILE', {       // eg:'KEY_2' , file configured in `spartacus-configuration.MODULE.TS`
    urlParams: {
      PARAM_1: this.defaultUserId,                                                        // variables in URL i.e. ${PARAM_1}
      PARAM_2: VAL_2,
    }
  }, { baseUrl: true, prefix: false, baseSite: false });
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
B.
serviceMethod() {
  const endpointURL = storeEndpoints.endpointURL_2;
  const url = this.occEndpointsService.buildUrl(endpointURL, {                           // NOTE: no use of '', because it is URL and not KEY
    urlParams: {
      PARAM_1: this.defaultUserId,
      PARAM_2: VAL_2,
    }
  }, { baseUrl: true, prefix: false, baseSite: false });
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
C.
serviceMethod() {
  const baseUrl = this.occEndpointsService.getBaseUrl();                                                    // baseUrl + prefix + baseSite from occ service
  const baseUrl = this.occEndpointsService.getBaseUrl({ baseUrl: true, prefix: false, baseSite: false });   // specified `false` for value that is not required
  const url = `${this.baseUrl}/users/${this.defaultUserId}/carts/${cartID}/findStore`;
  return this.httpClient.post(url, body, httpOptions).pipe(catchError((err: Error) => throwError(err)));
}
2. ENDPOINTS.CONST.TS
------------------------
// NOTE: This file is configured in `spartacus-configuration.MODULE.TS`
// NOTE: If KEY is NOT found from here, it is referred from configs from SPARTACUS builtin like `defaultOccCartConfig`
export const storeEndpoints = {
  backend: {
    occ: {
      endpoints: {
        KEY_1: 'basesites?fields=FULL',
        KEY_2: 'users/${PARAM_1}/carts/${PARAM_2}?fields=FULL'
      },
    },
  },
  endpointURL_1: 'payment-token',
  endpointURL_2: 'users/${PARAM_1}/orders?cartId=${cartid}&fields=FULL'
};


CART SERVICES
===================
// API calls to /cart might not return complete data. To fix this add endpoint to config-file for fields=FULL i.e.
backend: { occ: { endpoints: {
           cart: 'users/${userId}/carts/${cartId}?fields=FULL',
           carts: 'users/${userId}/carts?fields=FULL',
           createCart: 'users/${userId}/carts?fields=FULL',
           addEntries: 'orgUsers/${userId}/carts/${cartId}/entries?fields=FULL&code=${code}&quantity=${quantity}',
           updateEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',
           removeEntries: 'users/${userId}/carts/${cartId}/entries/${entryNumber}',
  } } }
- APP.MODULE.TS
  import { ActiveCartService, CartAdapter, CartEntryAdapter, MultiCartService } from '@spartacus/cart/base/core';
  providers: [{provide: CartAdapter, useClass: CUSTOM-CartAdapter}, {provide: ActiveCartService, useExisting: CUSTOM-CartService, multi: true}
              {provide: CartEntryAdapter, useClass: CUSTOM-CartEntryAdapterService}, {provide: MultiCartService, useExisting: CUSTOM-MultiCartService}]
- CUSTOM-CartAdapter.SERVICE.TS
  import { OccCartAdapter } from '@spartacus/cart/base/occ';
  import { Cart, CART_NORMALIZER } from '@spartacus/cart/base/root';
  import { ConverterService, Occ, OccEndpointsService } from '@spartacus/core';
  @Injectable({providedIn: 'root'})
  export class CUSTOM-CartAdapter extends OccCartAdapter {
    constructor(protected _http: HttpClient, protected _occEndpointsService: OccEndpointsService, protected _converterService: ConverterService) {
      super(_http, _occEndpointsService, _converterService);
    }
    override create(userId: string, oldCartId?: string, toMergeCartGuid?: string): Observable<Cart> {
      const toAdd = JSON.stringify({});
      const params = <any>{};
      if (oldCartId) {
        params['oldCartId'] = oldCartId;
      }
      if (toMergeCartGuid) {
        params['toMergeCartGuid'] = toMergeCartGuid;
      }
      params['fields'] = 'FULL';
      return this.http.post<Occ.Cart>(this._occEndpointsService.buildUrl('createCart', {urlParams: { userId }, queryParams: params }), toAdd)
                                     .pipe(this._converterService.pipeable(CART_NORMALIZER));
    }
  }
- CUSTOM-CartService.SERVICE.TS
  import { ActiveCartService, getCartIdByUserId, MultiCartService } from '@spartacus/cart/base/core';
  import { MultiCartFacade } from '@spartacus/cart/base/root';
  import { UserIdService, WindowRef } from '@spartacus/core';
  @Injectable({providedIn: 'root'})
  export class CUSTOM-CartService extends ActiveCartService {
    constructor(multiCartFacade: MultiCartFacade, userIdService: UserIdService, winRef: WindowRef, protected multiCartService: MultiCartService,
                protected http: HttpClient, protected occEndpointsService: OccEndpointsService) {
      super(multiCartFacade, userIdService, winRef);
    }
    override addEntry(productCode: string, quantity: number, pickupStore?: string): void {
      this.requireLoadedCart().pipe(withLatestFrom(this.userIdService.getUserId())).subscribe(([cart, userId]) => {
        this.multiCartService.addEntry(userId, getCartIdByUserId(cart, userId), productCode, quantity, pickupStore);
      });
    }
    override removeEntry(entry: OrderEntry, recalculateCart?: boolean): void {
      this.activeCartId$.pipe(withLatestFrom(this.userIdService.getUserId()), take(1)).subscribe(([cartId, userId]) => {
        this.multiCartService.removeEntry(userId, cartId, entry.entryNumber as number, recalculateCart);
      });
    }
    addItemEntry(userId: string, cartId: string, code: string, quantity: number) {
      const url = this.occEndpointsService.buildUrl('addEntries', {
        urlParams: { userId, cartId, code, quantity },
      });
      const headers = new HttpHeaders({'Content-Type': 'application/json'});
      return this.http.post<CartModification>(url, { headers });
    }
  }
- CUSTOM-MultiCartService.SERVICE.TS
  import { Store } from '@ngrx/store';
  import { CartActions, MultiCartService, StateWithMultiCart } from '@spartacus/cart/base/core';
  import { CART_NORMALIZER } from '@spartacus/cart/base/root';
  import { ConverterService, Occ, OccEndpointsService, UserIdService } from '@spartacus/core';
  @Injectable({providedIn: 'root'})
  export class CUSTOM-MultiCartService extends MultiCartService {
    constructor(store: Store<StateWithMultiCart>,userIdService: UserIdService,protected occEndpointsService: OccEndpointsService,
                protected http: HttpClient,protected converterService: ConverterService) { super(store, userIdService); }
    /**
     * Overrides the reloadCart method from Spartacus.
     * @param cartId - CartId to reload
     * @param extraData - Additional parameters such as active flag(from spartacus) and force calculate flag.
     */
    override reloadCart(cartId: string, extraData?: { active?: boolean; forceCalculate?: boolean }): void {
      this.userIdService.takeUserId().subscribe((userId) => this.loadMyCart(userId, cartId, extraData?.forceCalculate));
    }

   /**
    * Overrides the removeEntry method from Spartacus.
    * @param userId - The ID of the user.
    * @param cartId - The ID of the cart.
    * @param entryNumber - The entry number to be removed.
    * @param recalculateCart - Optional flag to trigger cart recalculation.
   */
   override removeEntry(userId: string, cartId: string, entryNumber: number, recalculateCart?: boolean): void {
     // Delegate the removal process to the custom method.
     this.removeMyEntry(userId, cartId, entryNumber, recalculateCart);
   }

   /**
    * Loads the cart and dispatches appropriate actions.
    * @param userId - The ID of the user.
    * @param cartId - The ID of the cart to load.
    * @param forceCalculate - Optional flag to notify the backend when force cart calculation is required.
    */
    private loadMyCart(userId: string, cartId: string, forceCalculate?: boolean): void {
     this.http.get<Occ.Cart>(this.occEndpointsService.buildUrl('cart', { urlParams: { userId, cartId }, queryParams: { forceCalculate } }))
      .pipe(this.converterService.pipeable(CART_NORMALIZER)).subscribe((cart) => {
        if (cart) {
          // Dispatch success action when the cart is successfully loaded to update store.
          this.store.dispatch(new CartActions.LoadCartSuccess({ userId, cart, cartId }));
        }
        // Note: Failure cases are not handled here, as Spartacus does not handle them either.
        // Add failure handling if required.
      });
    }

    /**
     * @param userId - The ID of the user.
     * @param cartId - The ID of the cart.
     * @param entryNumber - The entry number to be removed.
     * @param recalculateCart - Optional flag to trigger cart recalculation.
     */
    private removeMyEntry(userId: string, cartId: string, entryNumber: number, recalculateCart?: boolean): void {
      const headers = new HttpHeaders({'Content-Type': 'application/x-www-form-urlencoded'});
      const url = this.occEndpointsService.buildUrl('removeEntries', {urlParams: {userId,cartId,entryNumber}});
      this.http.delete(url, { headers }).subscribe(() => {
        this.loadMyCart(userId, cartId, recalculateCart);
        // Note: Failure cases are not handled here, as Spartacus does not handle them either.
        // Add failure handling if required.
      });
    }
  }
- CUSTOM-CartEntryAdapterService.SERVICE.TS
  import { OccCartEntryAdapter } from '@spartacus/cart/base/occ';
  import { CartModification, CART_MODIFICATION_NORMALIZER } from '@spartacus/cart/base/root';
  import { ConverterService, OccEndpointsService } from '@spartacus/core';
  @Injectable({ providedIn: 'root' })
  export class CUSTOM-CartEntryAdapterService extends OccCartEntryAdapter {
    constructor(protected _http: HttpClient, protected _occEndpointsService: OccEndpointsService, protected _converterService: ConverterService) {
      super(_http, _occEndpointsService, _converterService);
    }
    public override add(userId: string, cartId: string, productCode: string, quantity: number = 1, pickupStore?: string): Observable<CartModification> {
      const url = this.occEndpointsService.buildUrl('addEntries', {
        urlParams: { userId, cartId, quantity },
      });
      // Handle b2b case where the x-www-form-urlencoded is still used
      if (url.includes(`quantity=${quantity}`)) {
        const httpHeaders = new HttpHeaders({'Content-Type': 'application/x-www-form-urlencoded'});
        return this.http.post<CartModification>(url, {}, { headers: httpHeaders, params: { code: productCode } })
                        .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));
      }
      const toAdd = {
        orderEntries: [{quantity, product: { code: productCode }, ...(pickupStore && { deliveryPointOfService: { name: pickupStore } })}]
      };
      const headers = new HttpHeaders({'Content-Type': 'application/json'});
      return this.http.post<CartModification>(url, toAdd, { headers })
                      .pipe(this.converterService.pipeable(CART_MODIFICATION_NORMALIZER));
    }
  }
A.
// Create new cart if not exists by calling API, else return existing cart (REFER: localstorage of browser for cartID)
- COMP.TS
  import { MultiCartService } from '@spartacus/cart/base/core';
  constructor(private activeCartService: CUSTOM-CartService, private multiCartService: MultiCartService) {}
  this.activeCartService.requireLoadedCart().pipe(takeUntil(this.unsubscribe$)).subscribe((cart) => {
    if (cart.code) {
      this.cartId = cart.code;
      this.activeCartService.addItemEntry(OCC_USER_ID_CURRENT, cart.code, evt.product.code, evt.unitQuantity).pipe(takeUntil(this.unsubscribe$))
            .subscribe(() => {
                  // To Update Cart State in Spartacus Store, when calling our custom API
                  this.multiCartService.reloadCart(this.cartId);              
            });
    }
  });
B.1.
- COMP.TS
  // Subscribe to any cart related changes and get cart data
  this.activeCartService.getActive().pipe(takeUntil(this.unsubscribe$)).subscribe((cart: CART-TYPE) => {
    this.cartID = cart?.guid || cart?.code;
    this.cartData = cart;
    this.cdRef.markForCheck();
  });
B.2.
// Reload/Refresh cart at app level by calling API, to have changes if any reflected in getActive() cart subscription (REFER: B.1. point)
// Eg: A product is added to cart, and we need some UI change depending on updated cart data after this product is added to cart.
i.
this.multiCartService.reloadCart(this.cartData.code ?? '', { forceCalculate: true });
ii.
this.reloadSub = combineLatest([
    this.userIdService.getUserId().pipe(take(1)), this.activeCartService.getActiveCartId().pipe(take(1))
]).subscribe(([userId, cartId]: [string, string]) => {
      if (cartId && userId) {
        this.multiCartService.loadCart({
          userId,
          cartId,
          extraData: {
            active: true,
          },
        });
        if (this.reloadSub) {
          this.reloadSub.unsubscribe();
        }
      }
});
this.multiCartService.isStable(cartId).pipe(takeUntil(this.destroy$)).subscribe((isloaded: boolean) => {
   if (isloaded) { window.location.reload(); }
});
C.
// Cart can be updated using builtin endpoint KEYS like 'addEntries', 'updateEntries', 'removeEntries' from defaultOccCartConfig of spartacus
// Other KEYS and URLs value and what all path params (urlParams) it expects, can be checked from spartacus code repo.
constructor(protected cartService: CUSTOM-CartService) { }
C.1.
this.cartService.updateEntry(orderEntry.entryNumber, quantity);
C.2.
this.cartService.removeEntry(orderEntry, true);
D.
// A cart and all it's associated data is also deleted from BackOffice/HAC, depending on GUID or CODE
OR
- COMP.TS
  import { MultiCartService } from '@spartacus/cart/base/core';
  import { UserIdService } from '@spartacus/core';
  constructor(protected cartService: CUSTOM-CartService, private multiCartService: MultiCartService, private userIdService: UserIdService) { }
  this.cartService.getActiveCartId().pipe(withLatestFrom(this.userIdService.getUserId()), take(1), tap(([cartId, userId]) => {
    this.multiCartService.deleteCart(cartId, userId);
  })).subscribe(() => { });


ORDER / CHECKOUT SERVICES
============================
import { Order, OrderFacade } from '@spartacus/order/root';
import { MultiCartService } from '@spartacus/cart/base/core';
constructor(private checkoutDeliveryAddressFacade: CheckoutDeliveryAddressFacade,
            private checkoutDeliveryModesFacade: CheckoutDeliveryModesFacade,
            private checkoutPaymentFacade: CheckoutPaymentFacade,
            private orderFacade: OrderFacade) { }
A.
backend: { occ: { endpoints: { setDeliveryAddress: 'orgUsers/${userId}/carts/${cartId}/addresses/delivery?addressId=${addressId}&fields=FULL' } } }
// Sets the delivery address to cart
this.checkoutDeliveryAddressFacade.setDeliveryAddress(DELIVERY-ADDRESS-OBJECT ?? {}).pipe(takeUntil(this.destroy$)).subscribe(
  (_) => { },
  (_) => { }
);
B.
backend: { occ: { endpoints: { setDeliveryMode: 'users/${userId}/carts/${cartId}/deliverymode?deliveryModeId=${deliveryModeId}' } } }
// Sets the provided delivery mode to current cart
this.checkoutDeliveryModesFacade.setDeliveryMode(DELIVERY-MODE-STRING ?? '').pipe(takeUntil(this.destroy$)).subscribe(
  (_) => { },
  (_) => { }
);
C.
// Sets the payment details to current cart
this.checkoutPaymentFacade.setPaymentDetails(PAYMENT-DETAILS-OBJECT ?? {}).pipe(takeUntil(this.destroy$)).subscribe(
  (_) => { },
  (_) => { }
);
D.
backend: { occ: { endpoints: { placeOrder: 'orgUsers/${userId}/orders?cartId=${cartId}&termsChecked=true&fields=FULL' } } }
// Places an order
this.orderFacade.placeOrder(true).pipe(takeUntil(this.unsubscribe$)).subscribe(
  (orderData: Order) => { this.router.navigate(['order-confirmation']); },
  (_) => { }
);
// Sets provided order as current
this.orderFacade.setPlacedOrder(orderData);


ORDER HISTORY SERVICE
============================
backend: { occ: { endpoints: {
      orderHistory: 'users/${userId}/orders/list?fields=FULL',
      orderDetail: 'users/${userId}/orders/${orderId}?fields=FULL'
} } }
A.
A.1. src\app\spartacus\features\order\order-feature.module.ts - ORDER-FEATURE.MODULE.TS
---------------------------------------------------------------------------------------------
import { OrderModule } from '@spartacus/order';
import { orderTranslationChunksConfig, orderTranslations } from '@spartacus/order/assets';
import { OrderHistoryAdapter } from '@spartacus/order/core';
import { OrderRootModule } from '@spartacus/order/root';
import { CUSTOM-OrderHistoryAdapterService } from 'src/app/shared/services/order-history-adapter.service';
@NgModule({
  declarations: [],
  imports: [OrderRootModule, OrderModule],
  providers: [
    { provide: OrderHistoryAdapter, useClass: CUSTOM-OrderHistoryAdapterService },
    provideConfig(<I18nConfig>{i18n: { resources: orderTranslations,chunks: orderTranslationChunksConfig },
  })]
})
export class OrderFeatureModule {}
A.2. CUSTOM-OrderHistoryAdapterService.SERVICE.TS
--------------------------------------------------------
import { ConverterService, Occ, OccEndpointsService } from '@spartacus/core';
import { OrderHistoryAdapter } from '@spartacus/order/core';
import { OccOrderHistoryAdapter } from '@spartacus/order/occ';
import { ORDER_HISTORY_NORMALIZER, OrderHistoryList } from '@spartacus/order/root';
import { CUSTOM-OrderHistoryService } from './order-history.service';
@Injectable({providedIn: 'root'})
export class CUSTOM-OrderHistoryAdapterService extends OccOrderHistoryAdapter implements OrderHistoryAdapter {
  constructor(protected override http: HttpClient,protected override occEndpoints: OccEndpointsService,
              protected override converter: ConverterService,private orderHistoryService: CUSTOM-OrderHistoryService) {
                super(http, occEndpoints, converter);
  }
  public override loadHistory(userId: string,pageSize?: number,currentPage?: number,sort?: string): Observable<OrderHistoryList> {
    const params: { [key: string]: string } = {};
    if (pageSize) { params['pageSize'] = pageSize.toString(); }
    if (currentPage) { params['currentPage'] = currentPage.toString(); }
    if (sort) { params['sort'] = sort.toString(); }
    // NOTE: change keys based on filters available in facet and sent to API
    this.orderHistoryService.getselectedFilters().pipe(take(2)).subscribe((data) => {
        params['orderNumber'] = data?.orderNumber ?? null;
        params['fromDate'] = data?.fromDate ?? null;
        params['toDate'] = data?.toDate ?? null;
        params['selectedOrderStatus'] = data?.orderStatuses ?? null;
        params['selectedOrderType'] = data?.orderTypes ?? null;
    });
    const url = this.occEndpoints.buildUrl('orderHistory', {urlParams: { userId }, queryParams: params});
    return this.http.get<Occ.OrderHistoryList>(url).pipe(this.converter.pipeable(ORDER_HISTORY_NORMALIZER),
      tap((response) => {this.orderHistoryService.setOrderHistory(response);}),
      map((data: any) => { return {
          // NOTE: change keys as per response received in API
          orders: data.searchPageData.results.map((data: any) => {
            return {code: data.orderNumber,placed: data.orderPlaced,status: data.orderStatus,total: data.total}
          }),
          pagination: data.searchPageData.pagination,
          sorts: data.searchPageData.sorts,
          isEmptyOrderList: !data.searchPageData.results.length,
        };
      })
    );
  }
}
A.3. CUSTOM-OrderHistoryService.SERVICE.TS
---------------------------------------------
@Injectable({providedIn: 'root'})
export class CUSTOM-OrderHistoryService {
  constructor(protected http: HttpClient, private occEndpointsService: OccEndpointsService) {}
  private orderHistory = new BehaviorSubject<any>({});
  private selectedFilter = new BehaviorSubject<any>({});
  fetchOrderHistory = new Subject<void>();
  private _isSelectedFilterCleared = new BehaviorSubject<boolean>(false);
  setOrderHistory(data: any) {
    this.orderHistory.next(data);
  }
  getOrderHistory() {
    return this.orderHistory.asObservable();
  }
  updateSelectedFilters(data: any) {
    this.selectedFilter.next(data);
  }
  getselectedFilters() {
    return this.selectedFilter.asObservable();
  }
  getselectedFiltersValue() {
    return this.selectedFilter.value;
  }
  isSelectedFilterCleared() {
    return this._isSelectedFilterCleared.value;
  }
  setClearFilterFlag() {
    this._isSelectedFilterCleared.next(true);
  }
  clear() {
    this.orderHistory.next({});
    this.selectedFilter.next({});
    this.fetchOrderHistory.next();
    this._isSelectedFilterCleared.next(false);
  }
  // NOTE: change keys based on filters available in facet and sent to API
  getSelectedData(): boolean {
    let selectedFilter = this.getselectedFiltersValue();
    return !!(selectedFilter?.orderNumber || selectedFilter?.fromDate || selectedFilter?.toDate || selectedFilter?.orderTypes);
}}
A.4. LISTING-PAGE-COMP.TS
----------------------------
import { Order, OrderHistoryFacade, OrderHistoryList } from '@spartacus/order/root';
import { CUSTOM-OrderHistoryService } from 'src/app/shared/services/order-history.service';
export class OrderHistoryComponent implements OnInit, OnDestroy {
  OrderHistoryList?: OrderHistoryList;
  constructor(private orderHistoryFacade: OrderHistoryFacade,private orderService: CUSTOM-OrderHistoryService) {}
  ngOnInit(): void {
    this.loaderService.show();
    this.orderHistoryFacade.getOrderHistoryListLoaded().pipe(takeUntil(this.unsubscribe$)).subscribe(
        (isLoaded: boolean) => { isLoaded ? this.loaderService.hide() : this.loaderService.show(); },
        () => { this.loaderService.hide(); }
    );
    this.getOrderHistoryList();
    this.orderService.fetchOrderHistory.pipe(takeUntil(this.unsubscribe$)).subscribe(() => {
      this.loaderService.show();
      this.orderHistoryFacade.loadOrderList(ORDER_HISTORY_PAGE_SIZE, 0, this.sortType);
    });
  }
  // NOTE: change keys based on filters available in facet and sent to API
  getSelectedData(): boolean {
    let selectedFilter = this.orderService.getselectedFiltersValue();
    let isSelectedFilterCleared = this.orderService.isSelectedFilterCleared();
    return (!!(selectedFilter?.orderNumber || selectedFilter?.fromDate || selectedFilter?.toDate) || isSelectedFilterCleared);
  }
  getOrderHistoryList() {
    this.loaderService.show();
    this.orderHistoryFacade.loadOrderList(ORDER_HISTORY_PAGE_SIZE);
    this.orderHistoryFacade.getOrderHistoryList(ORDER_HISTORY_PAGE_SIZE).pipe(
        filter((resp?: any) => { return !!(resp?.orders?.length || resp?.isEmptyOrderList); }),
        takeUntil(this.unsubscribe$)
      ).subscribe((resp?: OrderHistoryList) => {
          this.OrderHistoryList = resp;
          setTimeout(() => { this.loaderService.hide(); }, 500);
          this.cdRef.markForCheck();
        },
        () => {
          setTimeout(() => { this.loaderService.hide(); }, 500);
        }
      );
  }
  getOrderDetails(order: Order) {
    this.router.navigate(['my-account/order', order.code]);
  }
  changeSortCode(sortCode: string): void {
    const event: OrderHistoryPage = { sortCode, currentPage: 0 };
    this.fetchOrders(event);
  }
  pageChange(page: number): void {
    const event: OrderHistoryPage = { sortCode: this.sortType, currentPage: page };
    this.fetchOrders(event);
  }
  private fetchOrders(event: OrderHistoryPage): void {
    this.loaderService.show();
    this.orderHistoryFacade.loadOrderList(ORDER_HISTORY_PAGE_SIZE, event.currentPage, event.sortCode);
  }
}
A.5. LISTING-PAGE-COMP.HTML
------------------------------
<ng-container *ngIf="OrderHistoryList?.orders?.length || getSelectedData(); else noOrders">
  <div *ngFor="let order of orderHistoryList.orders; let i = index">
    <a (click)="getOrderDetails(order)">VIEW DETAILS</a>
  </div>
  <div class="OrderPagination" *ngIf="(OrderHistoryList?.pagination?.totalPages ?? 0) > 1">
    <cx-pagination [pagination]="OrderHistoryList?.pagination" (viewPageEvent)="pageChange($event)"></cx-pagination>
  </div>
</ng-container>
A.6. LISTING-PAGE-FACET.COMP.TS
-------------------------------------
NOTE: ALSO REFER `SPARTACUS/MISC/FACETS.TXT` NOTES, WHERE PRODUCTFACETNAVIGATIONCOMPONENT AND FACETLISTCOMPONENT ARE EXTENDED
import { CUSTOM-OrderHistoryService } from 'src/app/shared/services/order-history.service';
export class OrderHistoryRefinementComponent implements OnInit, OnDestroy {
  public orderHistoryFilters: any;
  selectedFilter: any = {};
  constructor(public orderService: CUSTOM-OrderHistoryService) {}
  ngOnInit(): void {
    this.orderService.getOrderHistory().pipe(takeUntil(this.unsubscribe$)).subscribe((res: any) => {
        if (res) { this.orderHistoryFilters = res; this.cdRef.markForCheck(); }
    });
  }
  handleFilteredData(value: any) {
    this.loaderService.show();
    this.selectedFilter = value;
    this.orderService.updateSelectedFilters(value);
    this.orderService.fetchOrderHistory.next();
  }
  clearAll(value: any) {
    this.loaderService.show();
    this.selectedFilter = value;
    this.orderService.updateSelectedFilters(value);
    this.orderService.setClearFilterFlag();
    this.orderService.fetchOrderHistory.next();
  }
}
A.7. LISTING-PAGE-FACET.COMP.HTML
-------------------------------------
NOTE: ALSO REFER `SPARTACUS/MISC/FACETS.TXT` NOTES, WHERE PRODUCTFACETNAVIGATIONCOMPONENT AND FACETLISTCOMPONENT ARE EXTENDED
B.
B.1. DETAILS-PAGE-COMP.TS
----------------------------
import { Order, OrderHistoryFacade } from '@spartacus/order/root';
constructor(private orderHistoryFacade: OrderHistoryFacade, private route: ActivatedRoute) {}
ngOnInit(): void {
      this.loaderService.show();
      this.orderHistoryFacade.getOrderDetails().pipe(takeUntil(this.unsubscribe$)).subscribe(
        (orderData?: Order) => {
            this.currentOrder = orderData ?? {};
            this.loaderService.hide();
            this.cdRef.markForCheck();
        },
        () => {
            this.currentOrder = {};
            this.loaderService.hide();
            this.cdRef.markForCheck();
        }
      );

    this.route.params.pipe(takeUntil(this.unsubscribe$)).subscribe((params) => {
      this.orderID = params['orderCode'] ?? '';
      if (this.orderID) { this.orderHistoryFacade.loadOrderDetails(this.orderID); }
    });
}


ORDER CONFIRMATION PAGE
==============================
import { Order, OrderFacade } from '@spartacus/order/root';
constructor(private orderFacade: OrderFacade) { }
A.
// Returns the current order
this.orderFacade.getOrderDetails().pipe(takeUntil(this.unsubscribe$)).subscribe(
  (order?: Order) => {
    this.currentOrder = order;
    this.cdRef.markForCheck();
  },
  () => {}
);
// This will clear current Active Cart and create new cart for the user
this.cartService.reloadActiveCart();
B.
// Clears the current order
ngOnDestroy(): void {
  this.orderFacade.clearPlacedOrder();
}


PRODUCT SERVICES
============================
A.1.
On landing to PLP (Product Listing Page), composable storefront makes an API call for getting search data. This is handled by spartacus default url mapping.
NOTE: This API call response may not have all fields. So, we can specify productSearch URL in ENDPOINTS.CONST.TS file(spartacus-configuration.MODULE.TS) i.e.
backend: { occ: { endpoints: { productSearch: 'products/search?fields=FULL' } } }
A.2.
To use this response data , follow steps:
- APP.MODULE.TS
  import { ProductListComponentService } from '@spartacus/storefront';
  imports: [ConfigModule.withConfig({ view: { defaultPageSize: 24 } })],
  providers: [{ provide: ProductListComponentService, useClass: CUSTOM-ProductListCompService }]
- CUSTOM-ProductListCompService.SERVICE.TS
  import { ActivatedRoute, Router } from '@angular/router';
  import { CurrencyService, LanguageService, ProductSearchService, RoutingService } from '@spartacus/core';
  import { ProductListComponentService, ProductListRouteParams, ViewConfig } from '@spartacus/storefront';
  import { CUSTOM-SearchCriteria } from 'src/app/core/interfaces/CUSTOM-interface';
  @Injectable({
    providedIn: 'root',
  })
  export class CUSTOM-ProductListCompService extends ProductListComponentService {
    protected readonly RELEVANCE_ALLCATEGORIES = ':relevance:category:';
    constructor(
      protected override productSearchService: ProductSearchService, protected override routing: RoutingService,
      protected override activatedRoute: ActivatedRoute, protected override currencyService: CurrencyService,
      protected override languageService: LanguageService, protected override router: Router, protected override config: ViewConfig) {
        super(productSearchService, routing, activatedRoute, currencyService, languageService, router, config);
    }
    override search(criteria: CUSTOM-SearchCriteria): void {
      const currentPage = criteria.currentPage;
      const pageSize = criteria.pageSize;
      const sort = criteria.sortCode;
      this.productSearchService.search(criteria.query, Object.assign({}, { currentPage }, { pageSize }, { sort }));
    }
    override getCriteriaFromRoute(routeParams: ProductListRouteParams, queryParams: CUSTOM-SearchCriteria): CUSTOM-SearchCriteria {
      return {
        query: queryParams.query ? queryParams.query : this.getQueryFromRouteParams(routeParams),
        currentPage: queryParams.currentPage ?? 0,
        pageSize: queryParams.pageSize ?? this.config.view?.defaultPageSize,
        sortCode: queryParams.sortCode ?? (queryParams.query ? queryParams.query.split(':')[1] : 'relevance'),
      };
    }
    protected override getQueryFromRouteParams({ query, categoryCode, brandCode }: ProductListRouteParams): string {
      if (query) {
        return query;
      }
      if (categoryCode) {
        return this.RELEVANCE_ALLCATEGORIES + categoryCode;
      }
      if (brandCode) {
        return this.RELEVANCE_ALLCATEGORIES + brandCode;
      }
      return '';
    }
  }
- CUSTOM-PRODUCT-LIST-PAGE.COMP.TS
  constructor(private productListCompService: CUSTOM-ProductListCompService) { }
  a. TO GET PRODUCTS DATA
     this.productListCompService.model$.pipe(takeUntil(this.unsubscribe$)).subscribe(
      (res) => {
        this.products = res.products ?? [];
        this.sortOptions = res.sorts ?? [];
        this.defaultSort = res.sorts?.find((option) => option.selected)?.code ?? '';
        this.cdRef.markForCheck();
      },
      (_) => {}
     );
  b. TO APPLY SORT CODE
     this.productListCompService.sort(SORTCODE-VALUE);
- CUSTOM-PRODUCT-LEFT-REFINEMENT.COMP.TS
  FOR FACETS , REFER   `misc/facets.txt`   code
B.1.
On landing to PDP (Product Details Page), composable storefront makes an API call for getting product data. This is handled by spartacus default url mapping.
NOTE: This API call response may not have all fields. So, we can specify product URL in ENDPOINTS.CONST.TS file(spartacus-configuration.MODULE.TS) i.e.
backend: { occ: { endpoints: { product: 'products/${productCode}?fields=FULL' } } }
B.2.
To use this response data , follow:
- CUSTOM-PRODUCT-DETAILS-PAGE.COMP.TS
  import { ProductService } from '@spartacus/core';
  constructor(private productService: ProductService) { }
  this.selectedProduct$: Observable<ProductDetails> = this.productService.get(PRODUCT-CODE) as Observable<ProductDetails>;
  OR
  import { CurrentProductService } from '@spartacus/storefront';
  constructor(private currentProductSerice: CurrentProductService) { }
  this.productData$: Observable<ProductDetails> = this.currentProductSerice.getProduct() as Observable<ProductDetails>;


HAMBURGER-MENU SERVICE (navigation drawer)
==============================================
1. COMP.HTML
--------------------
<ng-container
   [cxComponentWrapper]="{
      flexType: 'HamburgerMenuComponent',
      typeCode: 'HamburgerMenuComponent'
   }">
</ng-container>
2. COMP.SCSS
--------------------
::ng-deep {
  cx-hamburger-menu {
    .hamburger-inner,
    .hamburger-inner::before,
    .hamburger-inner::after {
      background-color: var(--black);
    }
  }
}
3. COMP.TS
---------------------
import { HamburgerMenuService } from '@spartacus/storefront';
constructor(private hamburgerMenuService: HamburgerMenuService) { }
this.hamburgerMenuService.isExpanded.pipe(takeUntil(this.unsubscribe$)).subscribe((isExpanded: boolean) => { });


SIGNUP / LOGIN / LOGOUT SERVICES
======================================
A.
import { UserRegisterFacade } from '@spartacus/user/profile/root';
constructor(private userService: UserRegisterFacade) {}
this.userService.register(<any>{
  firstName: formData.firstName,
  lastName: formData.lastName,
  uid: formData.email.toLowerCase(),
  password: formData.passw,
  phoneNumber: formData.phone
}).pipe(takeUntil(this.unsubscribe$)).subscribe((_) => {}, (err: any) => {});
B.
import {AuthService} from '@spartacus/core';
constructor(protected auth: AuthService) { }
API call: POST | URL: https://BASE-URL-public.model-t.cc.commerce.ondemand.com/authorizationserver/oauth/token
          REQUEST BODY: {username, password} | RESPONSE: {access_token:'', refresh_token:'', expires_in:'', token_type:'', scope:''}
Redirect to: `LAST VISITED PAGE` on successful login
from(this.auth.loginWithCredentials(email.toLowerCase(), password)).pipe(        // backend accepts lowercase emails only
    withLatestFrom(this.auth.isUserLoggedIn()),
    tap(([_, isLoggedIn]) => {
        if (isLoggedIn) {
            this.globalMsgService.remove(GlobalMessageType.MSG_TYPE_ERROR);      // Remove error message on successful login (bad username/password combination)
        }
        this.cd.markForCheck();
    })
).subscribe((res) => {}, (err) => {});
C.
API call: POST | URL: https://BASE-URL-public.model-t.cc.commerce.ondemand.com/authorizationserver/oauth/revoke
          REQUEST BODY: {baseSite:'', token_type_hint:'', token:''} | RESPONSE: NA
Redirect to: `/login` on successful logout
this.auth.logout();
D.
Overriding AuthService
D.1.
app.module.TS
--------------------
import { AuthService } from '@spartacus/core';
providers: [{ provide: AuthService, useExisting: CUSTOM-AuthService }];

D.2.
CUSTOM-AuthService.service.TS
----------------------------------
import { Store } from '@ngrx/store';
import {AuthRedirectService,AuthService,AuthStorageService,OAuthLibWrapperService,RoutingService,StateWithClientAuth,UserIdService} from '@spartacus/core';
@Injectable({ providedIn: 'root' })
export class CUSTOM-AuthService extends AuthService {
  constructor(store: Store<StateWithClientAuth>,userIdService: UserIdService,oAuthLibWrapperService: OAuthLibWrapperService,
    authStorageService: AuthStorageService,authRedirectService: AuthRedirectService,routingService: RoutingService) {
      super(store, userIdService, oAuthLibWrapperService, authStorageService, authRedirectService, routingService);
  }

  override async loginWithCredentials(userId: string, password: string) {
    await super.loginWithCredentials(userId, password).then(() => this.performPostLoginActions());
  }

  override async coreLogout() {
    super.coreLogout().then(() => this.performPostLogoutActions());
  }

  private performPostLoginActions(): void {
    this.cartService.requireLoadedCart().subscribe();
  }

  private performPostLogoutActions(): void { }
}


USER SERVICES
=========================
For complete data to be available in API response , add fields=FULL
A. USER PROFILE
--------------------
backend: { occ: { endpoints: { user: 'users/${userId}?fields=FULL' } } }
import { User, UserAccountFacade } from '@spartacus/user/account/root';
constructor(private userAccountService: UserAccountFacade) { }
A.1.
this.userAccountService.get().pipe(takeUntil(this.unsubscribe$)).subscribe((resp) => {
  this.userInfo = resp;
  this.cdRef.markForCheck();
}, (_) => {});

B. USER ADDRESS
----------------------
backend: { occ: { endpoints: { addresses: 'users/${userId}/addresses?fields=FULL' } } }
import { UserAddressService, Address } from '@spartacus/core';
constructor(private userAddressService: UserAddressService) { }
B.1.
this.userAddressService.addUserAddress({
      firstName: 'NEW FIRST NAME',
      lastName: 'NEW LAST NAME',
      line1: 'NEW Street Line 1',
      line2: 'NEW Street Line 2',
      town: 'NEW Town',
      postalCode: '2000',
      country: {
        isocode: 'AU',
        name: 'Australia',
      },
});
B.2.
a. this.userAddressService.loadAddresses();
   this.userAddressService.getAddresses().pipe(takeUntil(this.unsubscribe$)).subscribe((resp: Address[]) => {
     this.userAddresses = resp;
   }, (_) => {});
b. this.userAddressService.verifyAddress({
        firstName: 'NEW FIRST NAME',
        lastName: 'NEW LAST NAME',
        line1: 'NEW Street Line 1',
        town: 'NEW Town',
        postalCode: '2000',
        country: {
          isocode: 'AU',
          name: 'Australia',
        },
   }).pipe(takeUntil(this.destroy$)).subscribe((data) => { }, (_) => { });
B.3.
a. this.userAddressService.setAddressAsDefault(ADDRESS_ID);
b. this.userAddressService.updateUserAddress(ADDRESS_ID ?? '', {
      firstName: 'Rakshit',
      lastName: 'Kapoor',
      line1: 'Shastri Nagar',
      town: 'Amritsar',
   });
B.4.
this.userAddressService.deleteUserAddress(ADDRESS_ID);


NORMALIZERS
===============
Normalizers are used for data mapping that suits requirement of project.
Here in this example, seoTitle and description of page is modified, which is useful for SEO.
1. APP.MODULE.TS
--------------------
{ provide: CMS_PAGE_NORMALIZER, useClass: CUSTOM-PageNormalizer, multi: true }
2. CUSTOM-PageNormalizer.TS
-------------------------------
import { Converter } from '@spartacus/core';
@Injectable({ providedIn: 'root' })
export class CUSTOM-PageNormalizer implements Converter<CmsPage, CmsStructureModel> {
  convert(source: CmsPage, target: CmsStructureModel = {}): CmsStructureModel {
    return { ...target, page: {...target.page, description: source.description, seoTitle: source.seoTitle} };
  }
}


PAGE META RESOLVERS
======================
These allow for adding/changing page meta data like title, description, canonical url etc. , which is useful for SEO
1. APP.MODULE.TS
---------------------
providers: [
  provideConfig(CUSTOM-PageMetaConfig),
  { provide: SeoMetaService, useExisting: CUSTOM-SeoService },
  { provide: PageMetaService, useExisting: CUSTOM-PageMetaService },
  { provide: ProductPageMetaResolver, useExisting: CUSTOM-ProductPageMetaResolver },
  { provide: PageMetaResolver, useExisting: CUSTOM-CategoryPageMetaResolver, multi: true },
  { provide: PageMetaResolver, useExisting: CUSTOM-DepartmentPageMetaResolver, multi: true },
  { provide: SearchPageMetaResolver, useExisting: CUSTOM-SearchPageMetaResolver }
]
2. CUSTOM-PageMetaConfig.TS
------------------------------                                            // import in APP.MODULE.TS
import { PageMetaConfig } from "@spartacus/core";
export const CUSTOM-PageMetaConfig: PageMetaConfig = {
  pageMeta: {
    resolvers: [
      { property: 'title', method: 'resolveTitle'},
      { property: 'heading', method: 'resolveHeading'},
      { property: 'breadcrumbs', method: 'resolveBreadcrumbs' },
      { property: 'description', method: 'resolveDescription' },
      { property: 'image', method: 'resolveImage' },
      { property: 'robots', method: 'resolveRobots' },
      { property: 'canonicalUrl', method: 'resolveCanonicalUrl' }
    ],
    canonicalUrl: {
      forceHttps: true,
      forceWww: false,
      removeQueryParams: true,
      forceTrailingSlash: false,
    },
    enableInDevMode: false,
  }
};
3. CUSTOM-RESOLVERS.TS
-------------------------
NOTE: For CUSTOM-RESOLVERS implementations defined in `useExisting`, refer SPARTACUS DEMO-CODE REPO, cloned from GITHUB
Eg:
constructor(protected productSearchService: ProductSearchService, protected cms: CmsService, protected translation: TranslationService,
            protected basePageMetaResolver: BasePageMetaResolver) {
   super(productSearchService, cms, translation, basePageMetaResolver);
   this.pageType = PageType.CATEGORY_PAGE;
   this.pageTemplate = 'DepartmentPageTemplate';                                 // connect page resolver to specific pageTemplate
}
A.1. override resolveTitle(): Observable<string> {                               // class CUSTOM-RESOLVER extends ProductPageMetaResolver
      return this.productData$.pipe(                                             // productData$: Observable<any> = this.currentProductSerice.getProduct();
      switchMap((product) =>
        this.translation.translate('pageMetaResolver.product.title', {
          productName: product.product.name,
        })
       )
      );
     }
A.2. override resolveTitle(): Observable<string> {                               // class CUSTOM-RESOLVER extends CategoryPageMetaResolver
      return (<Observable<ProductSearchPage>>this.searchPage$).pipe(
      switchMap((p: any) =>
        this.translation.translate('pageMetaResolver.category.title', {
          query:
            p?.category && p?.category?.seoTitle
              ? p?.category?.seoTitle
              : p.category && p.category?.name
              ? p?.category?.name
              : undefined,
        })
      ));
     }
     protected override searchPage$: Observable<ProductSearchPage | Page> = this.cms.getCurrentPage().pipe(
      filter((page) => Boolean(page)),
      switchMap((page: Page) =>
      // only the existence of a plp component tells us if products
      // are rendered or if this is an ordinary content page
      this.hasProductListComponent(page)
        ? this.productSearchService.getResults().pipe(filter((result) => Boolean(result)))
        : of(page)
      )
     );
     protected override hasProductListComponent(page: Page): boolean {
      return !!Object.keys(page.slots || {}).find(
      (key) =>
        !!page.slots?.[key].components?.find(
          (comp) =>
            comp.flexType === 'ProductListComponent' ||
            comp.typeCode === 'CMSProductListComponent' ||
            comp.typeCode === 'ProductGridComponent'
        )
      );
     }
B.1. resolveDescription(): Observable<string> {                                 // class CUSTOM-RESOLVER extends ProductPageMetaResolver
      return this.productData$.pipe(                                            // productData$: Observable<any> = this.currentProductSerice.getProduct();
      switchMap((product) =>
        this.translation.translate('pageMetaResolver.product.description', {
          description: product.metaDescription,
        })));
     }
B.2. resolveDescription(): Observable<string> {                                // class CUSTOM-RESOLVER extends CategoryPageMetaResolver
      return this.cms.getCurrentPage().pipe(
      filter((p) => Boolean(p)),
      map((data: Page) => {
        return data.description?.trim();
      }),
      switchMap((value?: string) => {
        return of(value);
      })
      );
     }
B.3. resolveDescription(): Observable<string> {                               // class CUSTOM-RESOLVER extends SearchPageMetaResolver
      return this.query$.pipe(
      mergeMap((query) => {
        return this.translation.translate('pageMetaResolver.search.description', {
          query,
        });
      })
      );
     }
C. resolveCanonicalUrl(): Observable<string> {
    return combineLatest([this.baseSiteService.get(), this.product$]).pipe(
      map(([baseSite, product]) => {
        const baseUrl = (baseSite as any).configMap.entry.find(
          (obj: any) => obj.key === 'canonicalBaseUrl'
        ).value;
        const url = `${baseUrl}${product.url}`;
        return this.pageLinkService.getCanonicalUrl({}, url);}));
   }


OUTLETS
======================
REFERENCE: https://vranjan.dev/posts/sap-spartacus-overriding-components-using-outlets/
           https://sap.github.io/spartacus-docs/outlets/
It allows to customize UI that is provided by default and to plug custom UI into DOM.
It can be used in two ways Template-Driven Outlets and Component-Driven Outlets.
A. Template-Driven Outlets (via .HTML)
   - cxOutletRef: It is used to add reference to outlet. The cxOutletRef directive expects slot position or template name.
   - cxOutletPos: It is used to define where should the outlet render with respect to cxOutletRef defined, i.e.
                  [cxOutletPos]="outletPositionVAR.BEFORE" | [cxOutletPos]="outletPositionVAR.AFTER" | [cxOutletPos]="outletPositionVAR.REPLACE"
A.1 .module.TS
    ----------------
    import { OutletRefModule } from '@spartacus/storefront';
    imports: [ OutletRefModule ]
A.2 .comp.TS
    ----------------
    import { OutletPosition } from "@spartacus/storefront";
    outletPositionVAR = OutletPosition;
A.3 .comp.HTML
    ----------------
    <ng-template cxOutletRef="Section1" [cxOutletPos]="outletPositionVAR.BEFORE">
           <h1>Hot SALE</h1>
    </ng-template>
B. Component-Driven Outlets (via .TS)
   - id: Where we want change i.e. similar to `cxOutletRef`
   - positon: What we want to do with outlet i.e. replace, add before or add after i.e. similar to `cxOutletPos`
   - component: Which component we want to show.
B.1 .module.TS
    ----------------
    import { provideOutlet, OutletPosition } from '@spartacus/storefront';
    providers: [
      provideOutlet({
           id: 'ContentPage1Template',
           position: OutletPosition.REPLACE,
           component: CustomOutletsComponent,
      })
    ]


PAGE NOT FOUND REDIRECTION
==============================
REFER: code sample in `server.prod.ts`, `server/server-api`, `server/node.helper`, `server/baseurl-mappings` in `deployment` folder.
OR
Map `/not-found` page's `ErrorPageTemplate`s ErrorComponent from backend with custom angular component.
Spartacus automatically redirects to `/not-found` in case route does not exist.


STYLES
===============
A. SPARTA LIB + MIXINS
-------------------------
Spartacus provides default styling library called Sparta in the @spartacus/styles package.
This package should be imported into project through the `styles.scss` file.
src/styles.scss
------------------
$primary: #e502bf                                                          // if any new value to scss variables, has to be re-assigned.
$font-weight-normal: 500;                                                  // this is done before Sparta library import.
@import '@spartacus/styles/scss/cxbase/mixins';

B. BREAKPOINT SERVICE
-------------------------
Spartacus provides BreakpointService, which allows same control as media queries, within TS files.
It is better to use as it responds to resize event.
Create a `responsive.SERVICE.TS` file, that can be injected in any COMPONENT.
import { Inject, Injectable, PLATFORM_ID } from '@angular/core';
import { WindowRef } from '@spartacus/core';
import { BREAKPOINT, BreakpointService, LayoutConfig } from '@spartacus/storefront';
import { Observable } from 'rxjs';
@Injectable({
  providedIn: 'root',
})
export class ResponsiveService extends BreakpointService {
  constructor(protected winRef: WindowRef, layoutConfig: LayoutConfig, @Inject(PLATFORM_ID) platform: any) {
    super(winRef, layoutConfig, platform);
  }
  isMobile$: Observable<boolean> = this.isDown(BREAKPOINT.sm);  // when referring DOWN, it picks up limit of next breakpoint, here sm < 768px
  isDesktop$: Observable<boolean> = this.isUp(BREAKPOINT.lg);   // when referring UP, it picks up limit of same breakpoint, here lg >= 992px
}
